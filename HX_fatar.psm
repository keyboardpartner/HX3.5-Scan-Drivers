                             ;
                             ; ##############################################################################
                             ; ############ KCPSM6 PicoBlaze Keyboard Scanner by cm 10/2010 #################
                             ; #################### for 12 BIT ADDRESS ROM (4096 Words) #####################
                             ; ##############################################################################
                             ;
                             ; 13.06.2024 #44 Differenzierter Key Click, etwas schwächer
                             ; 29.06.2022 #42 MIDI IN/GenTranspose jetzt für alle, KeyTranspose (Offset) nur MIDI OUT
                             ; 11.01.2022 #41 Extrem verbessertes Timing, 500µs Scan-Loop, einfacheres RAM-Handling
                             ; 31.12.2021 #40 Key Reverse State beim Verlassen der Endstellung, sendet früher, Noise etwas verringert
                             ; 18.10.2021 #39 Octave Shift für Upper und Lower in Manual Scan
                             ; 30.07.2021 #37 Sendet AllNotesOff bei Split-Änderungen, SplitMode 5 (AddPedalToLower)
                             ; 18.05.2021 #36 Andere Noise-Berechnung
                             ; 12.01.2021 #33 Bug in ResetDynTimers behoben
                             ; 12.01.2021 #31 Dynamik-Ermittlung über variables Timer-Dekrement (1/t)
                             ; 09.01.2021 #30 Scan-Dynamik jetzt per Statemachine
                             ; 03.09.2020 #28 Keine Übersetzung Sostenuto mehr
                             ; 22.02.2020 #25 Auch Kanal +3 an AVR für Touchpad
                             ; 20.11.2019 #23 MIDI-Dispatcher verbessert, wird öfter ausgeführt
                             ; 10.11.2019 #20 Local Enables auf SPI $2E
                             ; 21.02.2018 #19 Kleine Verzögerung vor Auslesen der Tastenkontakte wg. Emils Geisternoten
                             ; 13.02.2018 #18 Bug in Key Transpose behoben
                             ; 22.11.2018 #17 Split-Handling jetzt nur noch in Tastatur-Scan
                             ; 12.09.2018 #15 Bug in Midi-Kanalwahl behoben
                             ; 14.08.2018 #14 Bug in local_states_off (Dyn. 1 gesendet) behoben
                             ; 09.08.2018 #12 Sostenuto-Controller 42 geändert auf 45, HOLD2-Pedal wg. NI B4-PERC Konflikt
                             ; 24.04.2018 #11 Bugfixes für Fatar
                             ; 20.10.2017 #10 Zusätzlicher MIDI-Ausgang für SAM5504
                             ; 10.10.2017 Angepasst für KCPSM6, Inputs für Cancel Manual und HW-Sostenuto/Sustain auf PL Auxiliary
                             ; Pins schalten nach Masse!
                             ; Pin 6 = Bit 5 Sustain Upper
                             ; Pin 5 = Bit 4 Sostenuto Upper
                             ; Pin 4 = Bit 3 Sustain Lower
                             ; Pin 3 = Bit 2 Sostenuto Lower
                             ; Pin 2 = Bit 1 Cancel MIDI Kanal invert., 11 = Cancel Off, 10 = Cancel Upper,
                             ; Pin 1 = Bit 0 Cancel MIDI Kanal invert., 01 = Cancel Lower, 00 = Cancel Pedal
                             ;
                             CONSTANT c_corevers, 51                 ; $50=SR4014, $51=Fatar, $52=Opto, $53=MIDI RcvOnly
                             CONSTANT c_corerevi, 44                 ; Revisionsnummer
                             CONSTANT c_dyn_threshold, 28            ; MIDI-Dynamikschwelle für full click
                             CONSTANT c_midi_mindyn, 10              ; MIDI-Minimaldynamik langsame Taste (div 2)
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             ; Je nach Tastaturumfang sind anzupassen:
                             CONSTANT c_maxkeys, 60'd                ; längste vorhandene Tastatur (44/49/61) +1
                             CONSTANT c_maxkeys_plus_one, 61'd       ; längste vorhandene Tastatur (44/49/61) +1
                             CONSTANT c_maxbasskeys, 25'd            ; Anzahl der Pedal-Tasten an AuxPort PL8
                             CONSTANT c_midi_firstkey, 24'd
                             CONSTANT c_midi_lastkey_plus_one, 109'd
                             CONSTANT c_gen_firstkey, 36'd           ; Tonumfang INPUT MIDI-Notennummern
                             CONSTANT c_gen_lastkey_plus_one, 97'd   ; 96+1 wg. COMPARE
                             CONSTANT c_midi_offset, 36'd            ; Offset zu unterster MIDI-Note "C" bei 5 Oktaven (default 36)
                             CONSTANT c_scankey_delay, 29'd          ; Delay pro Taste für 600 µs Scandurchlauf in SYNC-Ticks (20,833 µs)
                             ;
                             ; nach Assemblierung DAT-Datei für Upload
                             ; erstellen mit Tool hex2dat_kcpsm6.exe oder Batch convert_xxx.bat
                             ;
                             ; ##############################################################################
                             ; ############################ MPX-RAM-Organisation ###########################
                             ; ##############################################################################
                             ;
                             ; Ein/Ausschalten der HX3-Tastenkontakte erfolgt durch Schreiben der
                             ; Kontaktdaten in ein Dual-Port-RAM, das sogerannte MPX-RAM.
                             ; Jede Taste(nspalte) belegt eine Adresse,
                             ; so dass das tiefste "C" immer Adresse 0 hat, das höchste "C" Adresse 60.
                             ; Für jedes Manual stehen 8 Bits des 18-Bit-Datenbusses zur Verfügung,
                             ; für das Pedal 2 (sonst ungenutzte Paritätsbits). Jeder Teil kann getrennt geschrieben/gelesen werden.
                             ; MPX-RAM besteht aus 16 Pages je 64 Worte, 16 Bit plus zwei "Parity"-Bits,
                             ; die hier für den Pedal-Status benutzt werden. Auswahl der Page über RAM_PAGE.
                             ; MSB, LSB und Parity-Bits können getrennt über STROBEs geschrieben werden.
                             ; Page 0 dient direkt als Freigabe für Tastenkontakte:
                             ; ##### LOWER #####   ##### UPPER #####  -  Bytes
                             ; 7 MSN 4  3 LSN 0    7 MSN 4  3 LSN 0   -  Nibbles
                             ; #NOISE#  #STEAD#    #NOISE#  #STEAD#
                             ; - C B A  L C B A    - C B A  L C B A   -  Bits
                             ; mit ABC = Anzahl eingeschalteter Tastenkontakte, L = Level-Bit,
                             ; Dabei wird Wert ABC jeweils anhand des folgenden Schemas dekodiert:
                             ; 76543210 ; Busbar CONTACT-Bit 0 = 16'. Bit 7 schaltet sowohl 1' als auch 1 1/3' ein!
                             ; 00000000 ; Stufe 0, alle aus
                             ; 00100000 ; Stufe 1...
                             ; 00100100
                             ; 01100100
                             ; 01100110
                             ; 11100110
                             ; 11101111
                             ; 11111111 ; bis Stufe 7, alle an bzw. alle noisy
                             ; Level-Bit L gelangt direkt zum CONTACT-Level-Bit 8.
                             ; Ist STEADY komplett an, ist der Wert des Noise-Gates egal, da Werte verODERt werden.
                             ; Pedalkontakt CONT_PEDAL ist an Bit(0) angeschlossen, Bit (1) kann als Scratch dienen.
                             ; Die Nibbles können in pb_scanif.vhd einzeln gelesen werden!
                             ; PAGE 1 als Soft-Timer für Tastenkontakte
                             ; PAGE 2 als Soft-Timer für Noise
                             ; PAGEs 6 bis 15 können nach Belieben verwendet werden.
                             ;
                             ; MPX RAM_PAGE Offsets
                             ; Seitenaufteilung in 64-Byte-Seiten, Auswahl über RAM_PAGE
                             ;
                             CONSTANT c_page_vcontacts, 00           ; virtuelle Tastenkontakte, 0..60, direktes Lesen und Schreiben
                             CONSTANT c_page_dyntimer, 01            ; Dynamik-Timer 0..60 für Tastatur-Scan
                             CONSTANT c_page_noisetimer, 02          ; Noise-Timer 0..60
                             CONSTANT c_page_keystate, 03            ; State Machine Tastenspalte 0..60
                             CONSTANT c_page_velocity, 04            ; Über Timer-Berechnung ermittelte Keyboard-Dynamik für Tasten 0..60
                             CONSTANT c_page_earlystep, 05           ; Eigene Tastatur Early-Zustand für Tasten 0..60
                             CONSTANT c_page_latestep, 06            ; Eigene Tastatur 2 Stufen für Tasten 0..60, aus Dynamik errechnet
                             CONSTANT c_page_sostenuto, 07           ; Sostenuto-Flags 0..60
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Portadressen bidirektional
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             ; $00 bis $07 Einzelbits SCANPORT Eingang, für Opto und Fatar
                             CONSTANT SCANPIO1, 00
                             CONSTANT SCANPIO2, 01
                             CONSTANT SCANPIO3, 02
                             CONSTANT SCANPIO4, 03
                             CONSTANT SCANPIO5, 04
                             CONSTANT SCANPIO6, 05
                             CONSTANT SCANPIO7, 06
                             CONSTANT SCANPIN8, 07
                             ; $00 bis $07 Einzelbits AUXPORT Eingang, für OrganScan/HOAX5 mit 4014 und Bass13/25
                             CONSTANT AUXPIO1, 08
                             CONSTANT AUXPIO2, 09
                             CONSTANT AUXPIO3, 0A
                             CONSTANT AUXPIO4, 0B
                             CONSTANT AUXPIO5, 0C
                             CONSTANT AUXPIO6, 0D
                             CONSTANT AUXPIO7, 0E
                             CONSTANT AUXPIN8, 0F
                             ;
                             CONSTANT SCANPIN, 10                    ; Scan Port gesamt Leser
                             CONSTANT SCANPORT, 10                   ; Scan Port gesamt Schreiben
                             CONSTANT SCANPORT_DDR, 11               ; Data Direction für Scan IF
                             CONSTANT AUXPIN, 18                     ; Auxiliary Port gesamt
                             CONSTANT AUXPORT, 18
                             CONSTANT AUXPORT_DDR, 19                ; Data Direction für Scan IF
                             CONSTANT PRESCANPIN, 32                 ; (50), PresetScan
                             CONSTANT PRESCANPORT, 28                ; (40) Preset-Scan-Port
                             CONSTANT PRESCANPORT_DDR, 29            ; (41) Preset - Scan - PortDirection
                             ; Output ports
                             CONSTANT c_strobe_mask, 20              ; für indirektes Schreiben
                             CONSTANT UPPER_STROBE, 20               ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Upper (1 Byte)
                             CONSTANT LOWER_STROBE, 21               ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Lower (1 Byte)
                             CONSTANT PEDAL_STROBE, 22               ; Schreibzugriff erzeugt Write für Pedal-Bits (2 Bits)
                             CONSTANT MIDI_CMD, 30                   ; MIDI-Befehl
                             CONSTANT MIDI_DB1, 31
                             CONSTANT MIDI_DB2, 32
                             CONSTANT MIDI_STR, 33                   ; MIDI Strobe für AVR, neg. Flanke
                             CONSTANT STATUS, 34                     ; STATUS an AVR SPI, Bit 0 bis 3 durch PB schreibbar, Bit 4 und 5 direkt SPI MIDI FIFO STAT
                             CONSTANT KEYS_ON_UPR, 35                ; Bit 0: auf Upper sind Tasten gedrückt
                             CONSTANT KEYS_ON_LWR, 36                ; Bit 0: auf Lower sind Tasten gedrückt
                             ; CONSTANT BASS_ENV, 37                 ; UNUSED
                             CONSTANT PEDAL_DOWN, 38                 ; Bit 0
                             CONSTANT PED_ACC_ENA, 39                ; für pedal click noise
                             CONSTANT MIDI_OUT_SEL, 3A               ; auf 4-fach Multiplexer,
                             ; MIDI_OUT_SEL: 0 = MIDI_TX_1, 1 = MIDI_IN_1, 2 = MIDI_IN_2, 3 = MIDI_FROM_SAM (USB)
                             ; Universal-Timer, hier für Scan-Durchlauf, 255 = 5,22 ms
                             ; wird mit jedem SYNC alle 20,48 µs dekrementiert bis 0 erreicht
                             CONSTANT SCANTIMER_VAL, 3D              ; Schreiben des neuen Wertes startet Timer
                             CONSTANT SCANTIMER_ZERO, 3E             ; Flag wenn 0 erreicht
                             CONSTANT NOISE_FREQ, 3F                 ; bestimmt Noise-Frequenz
                             CONSTANT RAM_PAGE, 40                   ; Seitenadresse zum einfacheren Zugriff, Page 0 = MPX Dual Port
                             CONSTANT RAM_ADDR, 41                   ; für alle Zugriffe gültig
                             CONSTANT RAM_WRDATA, 42                 ; zu schreibende Daten
                             CONSTANT MIDI_TX_1, 80                  ; MIDI UART-Tx-FIFO MAIN
                             CONSTANT MIDI_TX_2, 81                  ; MIDI UART-Tx-FIFO VENT (intern an Ventilator oder Mini-GM-Modul)
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Input Ports
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Flags für SPI-Empfang:
                             ; Bit 0 = Daten wurden geschrieben (wird durch Lesen der SPI-Register gelöscht)
                             ; Bit 1 = AVR-MIDI FIFO Daten im Buffer,
                             ; Bit 2 = AVR-MIDI FIFO Buffer halb voll
                             ; Bit 3 = AVR-MIDI FIFO Buffer voll
                             CONSTANT SPI_FLAG, 30                   ; "0000000" & spiflag
                             CONSTANT TX_STATUS, 31                  ; Bit 0 = Buffer halbvoll, Bit 1 = Buffer voll
                             CONSTANT c_read_mask, 34                ; für indirektes Lesen
                             CONSTANT RD_UPPER, 34                   ; Upper-Byte vom MPX-RAM
                             CONSTANT RD_LOWER, 35                   ; Lower-Byte vom MPX-RAM
                             CONSTANT RD_PEDAL, 36                   ; Pedal-Bits vom MPX-RAM (1:0)
                             CONSTANT MIDI_IN1, 38
                             CONSTANT MIDI_IN1_STATUS, 39            ; "0000" & midi_1_full & midi_1_half & midi_1_datapresent & '0';
                             CONSTANT MIDI_IN2, 3A
                             CONSTANT MIDI_IN2_STATUS, 3B            ; "0000" & midi_2_full & midi_2_half & midi_2_datapresent & '0';
                             CONSTANT MIDI_AVR, 3C                   ; MIDI vom AVR über SPI
                             CONSTANT MIDI_AVR_STATUS, 3D            ; "0000" & avrfifo_full & avrfifo_half & avrfifo_datapresent & avrmidiflag
                             CONSTANT RND_NUMBER, 3F                 ; Zufallswert 8 Bit
                             ; Werte vom AVR-SPI
                             CONSTANT SPI_MIDICH, 24                 ; Adresse $04 von außen (AVR)
                             CONSTANT SPI_MIDIOPT, 25
                             CONSTANT SPI_SPLITMODE, 26
                             CONSTANT SPI_SPLITON, 27                ; 7 von außen (AVR)
                             CONSTANT SPI_SPLITPOINT, 28             ; 8 von außen (AVR)
                             CONSTANT SPI_CLICKLEN, 29
                             CONSTANT SPI_GENTRANSPOSE, 2A           ; 10 = Generator Transpose
                             CONSTANT SPI_CONFIG_1, 2B               ; 11 = EARLY_KEY (Bit 0), VelocityFactor (Bit 7..2)
                             ; SPI_AVR_MIDI, 2C ; AVR-MIDI-Daten, FIFO-Eingang
                             CONSTANT SPI_KEYTRANSPOSE, 2D           ; Key Transpose (local keyboard)
                             CONSTANT SPI_LOCALDISABLES, 2E
                             ;
                             CONSTANT c_state_idle, 00               ; für Tastenabfrage-Timer, OFF gesendet
                             CONSTANT c_state_forward, 01            ; für Tastenabfrage-Timer, zählend
                             CONSTANT c_state_stopped, 02            ; für Tastenabfrage-Timer, angehalten
                             CONSTANT c_state_reverse, 03            ; für Tastenabfrage-Timer, bewegt sich zurück
                             CONSTANT c_state_idle_pedal, 00         ; für Tastenabfrage-Timer, Ruhezustand
                             CONSTANT c_state_stopped_pedal, 01      ; für Tastenabfrage-Timer, angehalten
                             ;
                             CONSTANT c_key_idle, 00                 ; für Tastenabfrage, Ruhezustand
                             CONSTANT c_key_moving, 01               ; für Tastenabfrage, in Bewegung
                             CONSTANT c_key_dirty, 02                ; für Tastenabfrage, Ende erreicht (dirty)
                             CONSTANT c_key_on, 03                   ; für Tastenabfrage, Ende erreicht
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Picoblaze Scratchpad Memory
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             CONSTANT s_keystatus_upper, 00          ; für Tastenabfrage, vorheriger Tastenzustand - NOCH NICHT BENUTZT!
                             CONSTANT s_keystatus_lower, 01
                             CONSTANT s_keystatus_pedal, 02
                             CONSTANT s_transpose, 03                ; Tongenerator/MIDI-IN-Transpose
                             ;CONSTANT s_keytranspose, 04             ; Tastatur-Transpose MIDI OUT
                             CONSTANT s_split_on, 05                 ; Letzter Split-Zustand
                             CONSTANT s_velocityfac, 06              ; Faktor für Timer-Dekrement
                             CONSTANT s_timerval, 07                 ; für Timer-Dekrement
                             CONSTANT s_splitpoint, 08               ; Tastennummer von SPI-AVR
                             CONSTANT s_splitmode, 09
                             ; 10..29 MIDI-Daten für Interpreter/Dispatcher
                             CONSTANT s_midi_cmd, 10'd
                             CONSTANT s_midi_data1, 11'd
                             CONSTANT s_midi_data2, 12'd
                             CONSTANT s_midi_len, 13'd
                             CONSTANT s_midi_cmd_masked, 14'd        ; upper Nibble
                             CONSTANT s_midi_chan_masked, 15'd       ; lower Nibble
                             ; MIDI-Daten per Polling vom FIFO, Port 1
                             CONSTANT s_midi_1_cmd, 16'd
                             CONSTANT s_midi_1_data1, 17'd
                             CONSTANT s_midi_1_data2, 18'd
                             CONSTANT s_midi_1_len, 19'd
                             CONSTANT s_midi_1_counter, 20'd
                             ; MIDI-Daten per Polling vom FIFO, Port 2
                             CONSTANT s_midi_2_cmd, 21'd
                             CONSTANT s_midi_2_data1, 22'd
                             CONSTANT s_midi_2_data2, 23'd
                             CONSTANT s_midi_2_len, 24'd
                             CONSTANT s_midi_2_counter, 25'd
                             ; MIDI-Daten per Polling vom AVR-FIFO
                             CONSTANT s_midi_3_cmd, 26'd
                             CONSTANT s_midi_3_data1, 27'd
                             CONSTANT s_midi_3_data2, 28'd
                             CONSTANT s_midi_3_len, 29'd
                             CONSTANT s_midi_3_counter, 30'd
                             CONSTANT s_midi_3_SysExFlag, 31'd
                             ;
                             CONSTANT s_keycount_upper, 32'd
                             CONSTANT s_keycount_lower, 33'd
                             CONSTANT s_keycount_pedal, 33'd
                             CONSTANT s_midi_activesensing, 35'd     ; Zähler/Timer für MIDI Active Sensing
                             CONSTANT s_scan_key_save, 36'd
                             CONSTANT s_group_matrix, 37'd           ; für FATAR
                             CONSTANT s_noisetimerval, 38'd
                             CONSTANT s_pedal_on, 39'd               ; Bass-Flag Trigger für Hüllkurve
                             CONSTANT s_midich, 40'd                 ; eingestellter MIDI-Kanal
                             CONSTANT s_midi_1_ignoreflag, 41'd      ; MIDI-Datenempfang: System Commons und deren Daten ignorieren
                             CONSTANT s_midi_2_ignoreflag, 42'd
                             CONSTANT s_switches_old, 43'd           ; kommt als Bit 1 von Split_ON (0000 00X0)
                             CONSTANT s_sustain_upr, 44'd
                             CONSTANT s_sustain_lwr, 45'd
                             ; 46 Dummy für Pedal, immer 0, nicht belegen!
                             CONSTANT s_sosten_upr, 47'd             ; Empfangenes CC 64, Sostenuto aktiv
                             CONSTANT s_sosten_lwr, 48'd
                             ; 49 Dummy für Pedal, immer 0, nicht belegen!
                             CONSTANT s_local_key, 50'd              ; für local out, enthält aktuelle Taste einschließlich Offset
                             CONSTANT s_local_dyn, 51'd
                             CONSTANT s_pedal_noisecounter, 52'd
                             CONSTANT s_scanloop_counter, 53'd
                             CONSTANT s_lastkey_on, 54'd             ; letzte gedrückte Taste für Split
                             CONSTANT s_clicklen, 55'd               ; Timer-Startwert
                             CONSTANT s_last_key_velocity, 56'd
                             CONSTANT s_scan_addr, 57'd
                             CONSTANT s_temp_s0, 58'd
                             CONSTANT s_temp_s1, 59'd
                             CONSTANT s_temp_s2, 60'd
                             CONSTANT s_vcont_upper, 61'd            ; gleichzeitig von Event gelesene Kontakt-Zustände
                             CONSTANT s_vcont_lower, 62'd
                             CONSTANT s_vcont_pedal, 63'd
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Register Renames
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             NAMEREG sF, midi_1_rxflag
                             NAMEREG sE, midi_2_rxflag
                             NAMEREG sD, midi_1_SysExFlag
                             NAMEREG sC, midi_2_SysExFlag
                             NAMEREG sB, midi_3_rxflag
                             ; häufig benutzte Variablen
                             NAMEREG sA, matrix_key                  ; Für FatarScan-Abfrage, Taste innerhalb Gruppe, nur in local_ benutzt
                             NAMEREG s9, manual_select               ; aktuelles Manual, 0 = upper, 1 = lower, 2 = bass
                             NAMEREG s8, s8_msb                      ; Zustand gedrückte Taste MIDI-Empfang, msb für Multiply
                             NAMEREG s7, s7_lsb                      ; Zustand gedrückte Taste eigene Manuale, lsb für Multiply
                             NAMEREG s6, idx_ptr                     ; universeller Index-Zeiger, auch für page select
                             NAMEREG s5, scan_addr                   ; aktuelle Taste, Zähler ab 0 bis Tastenanzahl
                             NAMEREG s4, s4_contacts                 ; Für Event-Routine
                             NAMEREG s3, s3_key_status               ; Zustand gedrückte Taste Manual und allgemein
                             ; s0, s1, s2 als Universal-Akkus
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                 cold_start: 
                             ; Einsprungpunkt nach Laden des Scan Cores
                             DISABLE INTERRUPT
                             CALL port_init
                             CALL scan_init
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             INPUT s0, SPI_MIDIOPT                   ; Bit 7 (MSB): USE SOST/SUSTAIN
                             AND s0, 80
                             JUMP NZ, main_loop
                             LOAD s0, 00
                             STORE s0, s_sustain_upr
                             STORE s0, s_sustain_lwr
                             STORE s0, s_sosten_upr
                             STORE s0, s_sosten_lwr
                             STORE s0, s_pedal_noisecounter
                             STORE s0, s_scanloop_counter
                  main_loop: 
                             CALL midi_dispatch                      ; MIDI-Daten empfangen? - ca. 1,7 µs
                             ; auf Scan-Freigabe durch Timer warten und neu setzen
                             INPUT s0, SCANTIMER_ZERO                ; auf Scan-Freigabe warten
                             COMPARE s0, 00                          ; warte auf Timer-Tick
                             JUMP Z, main_loop
                             ; Gesamtbedarf mit 25-Tasten-Pedal 380 µs
                             LOAD s0, 01
                             OUTPUT s0, SCANPIO2                     ; Test für Timing-Analyse
                             CALL scan_wait_init                     ; Scan-Timer neu starten
                             CALL scan_config                        ; Parameter-Änderungen? - ca. 3,4µs
                             CALL handle_sustain_switches            ; Sustain/Sostenuto-Eingangspins
                             ;
                             FETCH s0, s_scanloop_counter
                             ADD s0, 01
                             STORE s0, s_scanloop_counter
                             TEST s0, 01                             ; AND -> Z-Flag, Bit 5
                             CALL NZ, update_noisetimers             ; alle Timer updaten - ca. 26 µs, in 1 ms Abstand
                             ;
                             LOAD s0, 00
                             OUTPUT s0, SCANPIO2                     ; Test für Timing-Analyse
                             ; CALL active_sensing                   ; ca. 1,3 µs
                             CALL local_scan_manuals                 ; alle Manualtasten in RAM eintragen - ca. 244 µs
                             ; MIDI hat Timing-mäßig Vorrang vor eigener Tastatur,
                             ; um Buffer-Überläufe zu verhindern
                             CALL midi_dispatch                      ; MIDI-Daten empfangen? - ca. 1,7 µs
                             LOAD s0, 01
                             OUTPUT s0, SCANPIO6                     ; Test für Timing-Analyse
                             CALL event_handling                     ; Tasten auswerten, ca. 106 µs
                             LOAD s0, 00
                             OUTPUT s0, SCANPIO6                     ; Test für Timing-Analyse
                             ;
                             JUMP main_loop
                             ;
                             ; ###############################################################################
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; +++++++++++++++++++++ Scanboard-spezifischer Teil, +++++++++++++++++++++++++++
                             ; +++++++++++++++++++++++++++++ Hauptschleife ++++++++++++++++++++++++++++++++++
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; ###############################################################################
                             ;
                             ; Hilfsroutinen: Zubehör für Scan-Routinen, Initialisierungen
                             ;
                  port_init: 
                             ; Scan-Ports initialisieren
                             LOAD s0, 33                             ; für Fatar-/Opto-Interface
                             OUTPUT s0, SCANPORT_DDR
                             LOAD s0, 03                             ; für Bass/Aux-Interface
                             OUTPUT s0, AUXPORT_DDR
                             LOAD s0, 00                             ; Sustainpedal, alles Eingänge
                             OUTPUT s0, PRESCANPORT_DDR
                             RETURN 
                             ;
                             ; ###############################################################################
                             ;
          clock_delay_short: 
                             LOAD s0, 02
     clock_delay_short_loop: 
                             SUB s0, 01
                             JUMP NZ, clock_delay_loop
                             RETURN 
                             ;
                clock_delay: 
                             LOAD s0, 04
           clock_delay_loop: 
                             SUB s0, 01
                             JUMP NZ, clock_delay_loop
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
    handle_sustain_switches: 
                             ; abhängig vom PL16-Bits Flag in s_sustain_xxx oder s_sosten_xxx setzen/löschen
                             INPUT s3_key_status, PRESCANPIN         ; Bit 5 ist Sustain upper, Bit 3 lower
                             XOR s3_key_status, FF                   ; invertiert!
                             AND s3_key_status, 3C
                             FETCH s0, s_switches_old                ; alter Schalterzustand
                             XOR s0, s3_key_status                   ; geänderte Bits jetzt auf 1 in s0
                             RETURN Z                                ; nichts geändert
                             ; Es hat sich etwas geändert, jetzt einzeln verzweigen
                             FETCH s0, s_switches_old
                             AND s0, 20                              ; Pin 6 = Bit 5 Sustain Upper
                             LOAD s1, s3_key_status
                             AND s1, 20                              ; Pin 6 = Bit 5 Sustain Upper
                             XOR s0, s1                              ; geändertes Bit jetzt auf 1
                             CALL NZ, handle_sust_upr_changed
                             ;
                             FETCH s0, s_switches_old
                             AND s0, 10                              ; Pin 5 = Bit 4 Sostenuto Upper
                             LOAD s1, s3_key_status
                             AND s1, 10                              ; Pin 5 = Bit 4 Sostenuto Upper
                             XOR s0, s1                              ; geändertes Bit jetzt auf 1
                             CALL NZ, handle_sosten_upr_changed
                             ;
                             FETCH s0, s_switches_old
                             AND s0, 08                              ; Pin 4 = Bit 3 Sustain Lower
                             LOAD s1, s3_key_status
                             AND s1, 08                              ; Pin 4 = Bit 3 Sustain Lower
                             XOR s0, s1                              ; geändertes Bit jetzt auf 1
                             CALL NZ, handle_sust_lwr_changed
                             ;
                             FETCH s0, s_switches_old
                             AND s0, 04                              ; Pin 3 = Bit 2 Sostenuto Lower
                             LOAD s1, s3_key_status
                             AND s1, 04                              ; Pin 3 = Bit 2 Sostenuto Lower
                             XOR s0, s1                              ; geändertes Bit jetzt auf 1
                             CALL NZ, handle_sosten_lwr_changed
                             ;
                             STORE s3_key_status, s_switches_old
                             RETURN 
                             ;
                             ; aktuelles Switch-Bit in s1
    handle_sust_upr_changed: 
                             LOAD manual_select, 00
                             JUMP handle_sustain_changed_0
    handle_sust_lwr_changed: 
                             LOAD manual_select, 01
   handle_sustain_changed_0: 
                             CALL NZ, test_s1_set_s2                 ; s2 auf $7F wenn ein Switch-Bit gesetzt ist
                             LOAD idx_ptr, s_sustain_upr
                             ADD idx_ptr, manual_select
                             STORE s2, (idx_ptr)
                             LOAD s1, 40                             ; Sustain-Controller
                             JUMP local_send_fs
                             ;
                             ;
  handle_sosten_upr_changed: 
                             LOAD manual_select, 00
                             JUMP handle_sosten_changed_0
  handle_sosten_lwr_changed: 
                             LOAD manual_select, 01
    handle_sosten_changed_0: 
                             ;
                             CALL NZ, test_s1_set_s2                 ; s2 auf $7F wenn ein Switch-Bit gesetzt ist
                             LOAD idx_ptr, s_sosten_upr
                             ADD idx_ptr, manual_select
                             STORE s2, (idx_ptr)
                             LOAD s1, 45                             ; HOLD2-Sostenuto-Controller
                             JUMP local_send_fs
                             ;
             test_s1_set_s2: 
                             LOAD s2, 00
                             TEST s1, 3C
                             RETURN Z
                             LOAD s2, 7F
                             RETURN 
                             ;
                             ; Fußschalter-MIDI senden. Hier kommen wir nur hin, wenn sich etwas geändert hat.
                             ; aktueller Schalterzustand in s2, Controller in s1, Kanal in manual_select
              local_send_fs: 
                             INPUT s0, SPI_MIDIOPT                   ; Bit 7 (MSB): USE SOST/SUSTAIN
                             AND s0, 80
                             RETURN Z
                             STORE s2, s_temp_s2
                             STORE s1, s_temp_s1
                             FETCH s0, s_midich                      ; eingestellter Kanal
                             ADD s0, manual_select                   ; Manual-Nummer addieren
                             OR s0, B0
                             CALL midi_tx_both
                             FETCH s0, s_temp_s1                     ; Controllernummer
                             CALL midi_tx_both
                             FETCH s0, s_temp_s2                     ; Wert
                             ;
               midi_tx_both: 
                             CALL midi_out_waitbuf                   ; benutzt s1!
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf beiden Ports
                             OUTPUT s0, MIDI_TX_2
                             LOAD s1, 00
                             STORE s1, s_midi_activesensing          ; Active Sensing Reset
                             RETURN 
                             ;
                             ;
                             ; ###############################################################################
                             ; ################################ SCAN LOOP ####################################
                             ; ###############################################################################
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; FATAR SCAN und PEDAL
                             ; Inc 4024, Pin 1 (D0) - Key-Select innerhalb Gruppe, 0..7
                             ; Reset 4024, Pin 2 (D1)
                             ; Inc 4017, Pin 5 (D4) - Gruppen-Select 0..7
                             ; Reset 4017, Pin 6 (D5)
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
         local_scan_manuals: 
                             ; Tastenzustand aller Manuale ermitteln und behandeln
                             CALL local_fatar_aux_reset              ; SR-Daten Pedal übernehmen, Reset 4024, Pin 2 (D1), Reset 4017, Pin 6 (D5)
                             LOAD scan_addr, FF
                             ;
                             FETCH s0, s_split_on
                             AND s0, 03
                             JUMP Z, local_scan_loop_unsplitted      ; Split OFF
                             ;
                             FETCH s0, s_splitmode
                             COMPARE s0, 00
                             JUMP Z, local_scan_loop_split_0         ; 0 = Pedal to Lower
                             COMPARE s0, 01
                             JUMP Z, local_scan_loop_split_1         ; 1 = Lower to Upper
                             COMPARE s0, 02
                             JUMP Z, local_scan_loop_split_2         ; 2 = Pedal to Upper
                             COMPARE s0, 03
                             JUMP Z, local_scan_loop_split_3         ; 3 = Lower to Upper +1 Oktave
                             COMPARE s0, 04
                             JUMP Z, local_scan_loop_split_4         ; 4 = Lower to Upper +2 Oktaven
                             JUMP local_scan_loop_split_5            ; 5 = Add Pedal to Lower
                             ;
    local_scan_loop_split_0: ; 0 = Pedal to Lower
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_scan_split_0
                             CALL local_fatar_aux_clock
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_scan_loop_split_0        ; kurze 8-Tasten-Schleife
                             CALL local_fatar_groupclock
                             JUMP local_scan_loop_split_0
                             ;
    local_scan_loop_split_1: ; 1 = Lower to Upper
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_scan_split_1
                             CALL local_fatar_aux_clock              ; Inc 4017, Pin 5 (D4) und Shift SR
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_scan_loop_split_1        ; kurze 8-Tasten-Schleife
                             CALL local_fatar_groupclock
                             JUMP local_scan_loop_split_1
                             ;
    local_scan_loop_split_2: ; 2 = Pedal to Upper
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_scan_split_2
                             CALL local_fatar_aux_clock              ; Inc 4017, Pin 5 (D4) und Shift SR
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_scan_loop_split_2
                             CALL local_fatar_groupclock
                             JUMP local_scan_loop_split_2
                             ;
    local_scan_loop_split_3: ; 3 = Lower to Upper +1 Oktave
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_scan_split_3
                             CALL local_fatar_aux_clock              ; Inc 4017, Pin 5 (D4) und Shift SR
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_scan_loop_split_3        ; kurze 8-Tasten-Schleife
                             CALL local_fatar_groupclock
                             JUMP local_scan_loop_split_3
                             ;
    local_scan_loop_split_4: ; 4 = Lower to Upper +2 Oktaven
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_scan_split_4
                             CALL local_fatar_aux_clock              ; Inc 4017, Pin 5 (D4) und Shift SR
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_scan_loop_split_4        ; kurze 8-Tasten-Schleife
                             CALL local_fatar_groupclock
                             JUMP local_scan_loop_split_4
                             ;
    local_scan_loop_split_5: ; 5 = Add Pedal to Lower
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_scan_split_5
                             CALL local_fatar_aux_clock              ; Inc 4017, Pin 5 (D4) und Shift SR
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_scan_loop_split_5        ; kurze 8-Tasten-Schleife
                             CALL local_fatar_groupclock
                             JUMP local_scan_loop_split_5
                             ;
 local_scan_loop_unsplitted: ; unsplitted, ca. 285 µs Gesamtzeit
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_scan_normal_upper
                             CALL local_scan_normal_lower
                             CALL local_scan_normal_pedal
                             CALL local_fatar_aux_clock              ; Inc 4017, Pin 5 (D4) und Shift SR
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_scan_loop_unsplitted     ; kurze 8-Tasten-Schleife
                             CALL local_fatar_groupclock
                             JUMP local_scan_loop_unsplitted
                             ;
                             ; ------------------------------------------------------------------------------
                             ;
     local_fatar_groupclock: 
                             ; FatarScan2: Inc 4024, Reset 4017, inc s_group_matrix
                             LOAD s0, 01
                             OUTPUT s0, SCANPIO6                     ; Reset 4017, Pin 6 (D5)
                             OUTPUT s0, SCANPIO1                     ; Inc 4024, Pin 1 (D0) pos. Impuls
                             FETCH s0, s_group_matrix                ; inkrementieren
                             ADD s0, 01
                             STORE s0, s_group_matrix
                             LOAD matrix_key, 00
                             CALL clock_delay_short                  ; s0 ist jetzt 0
                             OUTPUT s0, SCANPIO6                     ; Reset aufheben
                             OUTPUT s0, SCANPIO1                     ; Pin 1 (D0) auf 0
                             CALL clock_delay_short                  ; s0 ist jetzt 0
                             RETURN 
                             ;
      local_fatar_aux_clock: 
                             ; pos. Impuls auf Scanport Pin 5 und Auxport 1 (SR AUX), Shift SR
                             ; liefert in matrix_key inkrementierten Wert
                             LOAD s0, 01
                             OUTPUT s0, SCANPIO5                     ; FatarScan 4017 Inc
                             OUTPUT s0, AUXPIO1                      ; SR Clk
                             ADD matrix_key, 01
                             CALL clock_delay_short                  ; s0 ist jetzt 0
                             OUTPUT s0, SCANPIO5
                             OUTPUT s0, AUXPIO1
                             CALL clock_delay_short                  ; s0 ist jetzt 0
                             RETURN 
                             ;
      local_fatar_aux_reset: 
                             ; pos. Impuls auf Scanport Pin 2 (4024) und 6 (4017), SR-Daten übernehmen
                             LOAD s0, 01
                             OUTPUT s0, AUXPIO2                      ; SR-Load vorbereiten
                             OUTPUT s0, SCANPIO2
                             OUTPUT s0, SCANPIO6
                             OUTPUT s0, AUXPIO1                      ; SR-Clk-Impuls für SR-Load
                             LOAD matrix_key, 00
                             CALL clock_delay_short                  ; s0 ist jetzt 0
                             STORE s0, s_group_matrix
                             OUTPUT s0, AUXPIO1
                             OUTPUT s0, SCANPIO2
                             OUTPUT s0, SCANPIO6
                             OUTPUT s0, AUXPIO2
                             CALL clock_delay_short                  ; s0 ist jetzt 0
                             RETURN 
                             ;
                             ; ------------------------------------------------------------------------------
                             ; Für Split-Bedienung: Auf Loslassen aller Tasten warten
                             ; ------------------------------------------------------------------------------
                             ;
   local_wait_keys_released: 
                             LOAD s8_msb, 00
                             CALL local_acc_keys_in_s8
                             COMPARE s8_msb, 00                      ; keine Tasten mehr gedrückt?
                             RETURN Z
                             JUMP local_wait_keys_released
                             ;
       local_acc_keys_in_s8: 
                             CALL local_fatar_aux_reset              ; SR-Daten Pedal übernehmen, Reset 4024, Pin 2 (D1), Reset 4017, Pin 6 (D5)
                             LOAD scan_addr, FF
     local_acc_keys_in_s8_0: 
                             ; Tastenzustand aktuelle Taste ermitteln und auf Loslassen warten
                             ADD scan_addr, 01                       ; nächste Taste
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             RETURN Z
                             CALL local_get_upper
                             OR s8_msb, s3_key_status
                             CALL local_get_lower
                             OR s8_msb, s3_key_status
                             CALL local_get_pedal
                             OR s8_msb, s3_key_status
                             ; inc 4017 (Key) und Shift SR, liefert in s0 inkrementierten Wert von s_key_matrix
                             CALL local_fatar_aux_clock
                             COMPARE matrix_key, 08                  ; Ende der Gruppe?
                             JUMP NZ, local_acc_keys_in_s8_0         ; kurze 8-Tasten-Schleife
                             CALL local_fatar_groupclock
                             JUMP local_acc_keys_in_s8_0
                             ;
                             ; ###############################################################################
                             ; ############################### TASTENABFRAGE #################################
                             ; ###############################################################################
                             ;
                             ; Manual-Tastenzustände holen
                             ; 0 = Taste AUS
                             ; 1 = Kontakt 1. Schließer
                             ; 2 = Kontakt 2. Schließer
                             ; 3 = beide Kontakte, Taste voll gedrückt
                             ;
                             ; Tastenzustand in s3_key_status holen - abhängig vom Scan-Board
            local_get_upper: 
                             INPUT s3_key_status, SCANPIO3           ; 1. Schließer
                             INPUT s1, SCANPIO4                      ; 2. Schließer
                             SL0 s1
                             OR s3_key_status, s1
                             RETURN 
            local_get_lower: 
                             INPUT s3_key_status, SCANPIO7           ; 1. Schließer
                             INPUT s1, SCANPIN8                      ; 2. Schließer
                             SL0 s1
                             OR s3_key_status, s1
                             RETURN 
            local_get_pedal: 
                             INPUT s3_key_status, AUXPIO5            ; Pedalkontakt
                             XOR s3_key_status, 01                   ; ist jetzt 0 oder 1, keine Dynamik!
                             LOAD s1, s3_key_status
                             SL0 s1                                  ; 2. Kontakt simulieren
                             OR s3_key_status, s1
                             RETURN 
                             ;
                             ;
                             ; ###############################################################################
                             ; ######################### LOCAL KEYBOARD HANDLING #############################
                             ; ################## sollte bei allen Scan-Boards gleich sein ##################
                             ; ###############################################################################
                             ;
                             ; Split Mode:
                             ; 0 = Pedal to Lower
                             ; 1 = Lower to Upper
                             ; 2 = Pedal to Upper
                             ; 3 = Lower to Upper +1 Oktave
                             ; 4 = Lower to Upper +2 Oktaven
                             ; 5 = Add Pedal to Lower
                             ;
             local_sub12_s0: 
                             ; Shift Upper -1 Oktave
                             SUB s0, 12'd                            ; transp. Key in s0
                             RETURN 
                             ;
                             ; ------------------------------------------------------------------------------
                             ;
    local_lowerkey_to_pedal: 
                             CALL local_get_lower                    ; Mode 0, Lower manual key auf Pedal schreiben
                             JUMP local_write_pedal
    local_upperkey_to_lower: 
                             CALL local_get_upper                    ; Mode 1, Upper manual key auf Lower schreiben
                             JUMP local_write_lower
    local_upperkey_to_pedal: 
                             CALL local_get_upper                    ; Mode 2, Upper manual key auf Pedal schreiben
                             JUMP local_write_pedal
  local_upperkey_to_lower_1: 
                             CALL local_get_upper                    ; Mode 3, Upper manual key +12 auf Lower schreiben
                             LOAD manual_select, 01
                             FETCH s0, s_transpose
                             ADD s0, scan_addr
                             ; Falls Bit 5 in SPI_SPLITON gesetzt, Oktav-Shift ausführen
                             FETCH s1, s_split_on
                             TEST s1, 20                             ; AND -> Z-Flag, Bit 5
                             CALL NZ, local_sub12_s0                 ; Octave Shift?
                             ADD s0, 12'd
                             STORE s0, s_local_key                   ; Für Event-MPX und MIDI Send
                             JUMP local_states                       ; und zurück
  local_upperkey_to_lower_2: 
                             CALL local_get_upper                    ; Mode 4, Upper manual key +24 auf Lower schreiben
                             LOAD manual_select, 01                  ; Lower
                             FETCH s0, s_transpose
                             ADD s0, scan_addr
                             ; Falls Bit 5 in SPI_SPLITON gesetzt, Oktav-Shift ausführen
                             FETCH s1, s_split_on
                             TEST s1, 20                             ; AND -> Z-Flag, Bit 5
                             CALL NZ, local_sub12_s0                 ; Octave Shift?
                             ADD s0, 24'd
                             STORE s0, s_local_key                   ; Für Event-MPX und MIDI Send
                             JUMP local_states                       ; und zurück
                             ;
    local_scan_normal_upper: 
                             LOAD manual_select, 00                  ; für MIDI OUTPUT Upper
                             FETCH s0, s_transpose
                             ADD s0, scan_addr
                             ; Falls Bits 4 in SPI_SPLITON gesetzt, Oktav-Shift ausführen
                             FETCH s1, s_split_on
                             TEST s1, 10                             ; AND -> Z-Flag, Bit 4
                             CALL NZ, local_sub12_s0                 ; Octave Shift?
                             STORE s0, s_local_key                   ; Für Event-MPX und MIDI Send
                             CALL local_get_upper                    ; Tastenzustand in s3_key_status holen
                             JUMP local_states                       ; und zurück
                             ;
    local_scan_normal_lower: 
                             CALL local_get_lower                    ; Tastenzustand in s3_key_status holen
          local_write_lower: 
                             LOAD manual_select, 01                  ; für MIDI OUTPUT Lower
                             FETCH s0, s_transpose
                             ADD s0, scan_addr
                             ; Falls Bit 5 in SPI_SPLITON gesetzt, Oktav-Shift ausführen
                             FETCH s1, s_split_on
                             TEST s1, 20                             ; AND -> Z-Flag, Bit 5
                             CALL NZ, local_sub12_s0                 ; Octave Shift?
                             STORE s0, s_local_key                   ; Für Event-MPX und MIDI Send
                             JUMP local_states                       ; und zurück
                             ;
    local_scan_normal_pedal: 
                             CALL local_get_pedal
          local_write_pedal: 
                             COMPARE scan_addr, c_maxbasskeys
                             RETURN NC                               ; wenn scan_addr > c_maxbasskeys
                             INPUT s0, SPI_CONFIG_1                  ; Early-Action-Mode?
                             TEST s0, 01                             ; AND -> Z-Flag
                             JUMP NZ, local_write_pedal_0            ; Wenn Early Action ON
                             ;
                             SR0 s3_key_status                       ; nur Schließer 2 berücksichtigen
        local_write_pedal_0: 
                             AND s3_key_status, 01
                             LOAD manual_select, 02                  ; für MIDI OUTPUT Lower
                             FETCH s0, s_transpose
                             ADD s0, scan_addr
                             STORE s0, s_local_key                   ; Für Event-MPX und MIDI Send
                             JUMP local_states_pedal                 ; und zurück
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Tasten"spalte" für alle Manuale abfragen
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
         local_scan_split_0: 
                             ; 0 = Pedal to Lower
                             CALL local_scan_normal_upper
                             FETCH s0, s_splitpoint
                             COMPARE scan_addr, s0
                             JUMP NC, local_scan_normal_lower        ; JUMP wenn scan_addr > splitpoint
                             COMPARE scan_addr, c_maxbasskeys
                             RETURN NC                               ; wenn scan_addr > c_maxbasskeys
                             JUMP local_lowerkey_to_pedal            ; Lower key auch auf Pedal schreiben
                             ;
         local_scan_split_1: 
                             ; 1 = Lower to Upper
                             CALL local_scan_normal_pedal
                             FETCH s0, s_splitpoint
                             COMPARE scan_addr, s0
                             JUMP NC, local_scan_normal_upper        ; JUMP wenn scan_addr > splitpoint
                             JUMP local_upperkey_to_lower            ; JUMP wenn scan_addr < splitpoint
                             ;
         local_scan_split_2: 
                             ; 2 = Pedal to Upper
                             CALL local_scan_normal_lower
                             FETCH s0, s_splitpoint
                             COMPARE scan_addr, s0
                             JUMP NC, local_scan_normal_upper        ; JUMP wenn scan_addr > splitpoint
                             COMPARE scan_addr, c_maxbasskeys
                             RETURN NC                               ; wenn scan_addr > c_maxbasskeys
                             JUMP local_upperkey_to_pedal            ; JUMP wenn scan_addr < splitpoint
                             ;
         local_scan_split_3: 
                             ; 3 = Lower to Upper +1 Oktave
                             CALL local_scan_normal_pedal
                             FETCH s0, s_splitpoint
                             COMPARE scan_addr, s0
                             JUMP NC, local_scan_normal_upper        ; JUMP wenn scan_addr > splitpoint
                             JUMP local_upperkey_to_lower_1          ; JUMP wenn scan_addr < splitpoint
                             ;
         local_scan_split_4: 
                             ; 4 = Lower to Upper +2 Oktaven
                             CALL local_scan_normal_pedal
                             FETCH s0, s_splitpoint
                             COMPARE scan_addr, s0
                             JUMP NC, local_scan_normal_upper        ; JUMP wenn scan_addr > splitpoint
                             JUMP local_upperkey_to_lower_2          ; JUMP wenn scan_addr < splitpoint
                             ;
         local_scan_split_5: 
                             ; 5 = Add Pedal to Lower
                             CALL local_scan_normal_upper
                             CALL local_scan_normal_lower
                             FETCH s0, s_splitpoint
                             COMPARE scan_addr, s0
                             RETURN NC
                             CALL local_get_lower
                             JUMP local_write_pedal                  ; Lower key auch auf Pedal schreiben
                             ;
                             ;
                             ; ##############################################################################
                             ; ############# MIDI-Routinen für Scan-Events bei Keyboard-Abfrage #############
                             ; ################## sollte bei allen Scan-Boards gleich sein ##################
                             ; ##############################################################################
                             ;
                             ;
                             ; -------------------------- Mealy-Zustandsautomat -----------------------------
                             ;
                             ; State in s2: c_state_idle, c_state_stopped
                             ;
                             ; ------------------------------------------------------------------------------
                             ;
         local_states_pedal: 
                             ; Pedal hat nur 1 Bit im RAM, deshalb andere State Machine
                             CALL local_rd_state_s2                  ; Timer-State dieser Taste in s2
                             ; auf derzeitigen Zustand verteilen
                             COMPARE s2, c_state_idle
                             JUMP Z, local_state_idle_pedal
                             JUMP local_state_stopped_pedal
                             ;
     local_state_idle_pedal: 
                             COMPARE s3_key_status, c_key_idle       ; Hat Taste mindestens ersten Kontakt erreicht?
                             JUMP NZ, local_state_stopped_pedal      ; wenn ja, in Counting-State gehen
                             RETURN                                  ; ist bereits in Ruhestellung, nichts machen
                             ;
 local_state_idle_pedal_off: ; Erstmals Ruhestellung
                             LOAD s2, c_state_idle_pedal             ; nächster Timer-State: Idle, OFF gesendet
                             CALL local_wr_state_s2
                             LOAD s3_key_status, c_key_idle
                             CALL local_wr_early_s3
                             JUMP local_states_off                   ; Eintragen, MIDI OFF senden und Ende
                             ;
  local_state_stopped_pedal: ; Kontakt erreicht
                             COMPARE s3_key_status, c_key_idle
                             JUMP Z, local_state_idle_pedal_off      ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                             COMPARE s2, c_state_stopped_pedal       ; bereits gestoppt und gesendet?
                             RETURN Z                                ; nichts machen, wenn bereits gestoppt
                             LOAD s2, c_state_stopped_pedal
                             CALL local_wr_state_s2                  ; neuer Timer-State: c_state_stopped
                             LOAD s3_key_status, c_key_on
                             CALL local_wr_early_s3                  ; neuer Timer-State: c_state_stopped
                             JUMP local_states_on_pedal              ; Eintragen, MIDI ON senden und Ende
                             ;
                             ; -------------------------- Mealy-Zustandsautomat -----------------------------
                             ;
                             ; State in s2: c_state_idle, c_state_forward, c_state_stopped, c_state_reverse
                             ;
                             ; ------------------------------------------------------------------------------
                             ;
               local_states: 
                             ; Zustand der State Machine holen, wg. Geschwindigheit hier separat
                             CALL local_rd_state_s2                  ; Timer-State dieser Taste in s2
                             ; auf derzeitigen Zustand verteilen
                             COMPARE s2, c_state_idle
                             JUMP Z, local_state_idle
                             COMPARE s2, c_state_forward
                             JUMP Z, local_state_forward
                             COMPARE s2, c_state_reverse
                             JUMP Z, local_state_reverse
                             JUMP local_state_stopped                ; s2 kann hier nur noch c_state_stopped sein
                             ;
                             ; ------------------------------- State "Idle" ---------------------------------
                             ;
       local_state_idle_off: 
                             ; Erstmals Ruhestellung, Dyntimer löschen
                             LOAD s0, FF
                             CALL local_wr_dyntimer_s0
                             LOAD s2, c_state_idle                   ; nächster Timer-State: Idle, OFF gesendet
                             CALL local_wr_state_s2
                             JUMP local_wr_early_s3                  ; aktuellen Zustand für Early Key in RAM speichern
                             ;
           local_state_idle: 
                             COMPARE s3_key_status, c_key_idle       ; Hat Taste mindestens ersten Kontakt erreicht?
                             JUMP NZ, local_state_forward            ; wenn ja, in Counting-State gehen
                             RETURN                                  ; nichts machen
                             ;
                             ; ------------------------------ State "Forward" --------------------------------
                             ;
        local_state_forward: 
                             ;
                             ; Nur 1. Kontakt erreicht: Solange Taste in Bewegung ist, Timerwert verringern
                             CALL local_rd_dyntimer_s0
                             FETCH s1, s_velocityfac                 ; 0..63, von SPI_CONFIG_1 Bits 7..2
                             SR0 s1
                             SR0 s1
                             CALL mult_soft_s0_s1                    ; s0 x s1 => s8_msb, s7_lsb, s0 bleibt bestehen
                             ; Subtrahend (= Timerwert * s_velocityfac div 256) jetzt in s8_msb
                             ; 1/t-Berechnung über log. fallende Kurve: s0 <= s0 - (s0 * s_velocityfac div 256) - 1
                             ; Subtrahend in s8_msb wird irgendwann 0, es würde in s0 ein Rest bleiben (s_velocityfac - 1)
                             ADD s8_msb, 01                          ; Subtrahend nicht 0 werden lassen
                             SUB s0, s8_msb                          ; Timer um (Timerwert * s_velocityfac div 256) dekrementieren
                             ; C gesetzt wenn <0, sehr langsamer Tastendruck
                             CALL C, load_s0_with_01
                             CALL Z, load_s0_with_01                 ; wenn 0, auf 1 setzen
                             STORE s0, s_last_key_velocity           ; neuer Raw-Wert Dynamik
                             CALL local_wr_dyntimer_s0               ; Timer mit s0 neu setzen
                             CALL local_wr_early_s3                  ; aktuellen Zustand für Early Key in RAM speichern
                             ;
                             COMPARE s3_key_status, c_key_dirty      ; nur 2. Kontakt?
                             JUMP Z, local_state_stopped_0           ; 2. Kontakt erreicht, 1. evt. fehlerhaft
                             COMPARE s3_key_status, c_key_on
                             JUMP Z, local_state_stopped_0           ; 1. und 2. Kontakt erreicht: neuer State, MIDI senden
                             COMPARE s3_key_status, c_key_idle
                             JUMP Z, local_state_reverse_0           ; Taste hat alle Kontakte verlassen, wieder auf Rückweg
      local_state_forward_0: 
                             COMPARE s2, c_state_forward
                             RETURN Z                                ; State nicht neu setzen, wenn bereits Counting
                             LOAD s2, c_state_forward                ; wenn noch nicht gestartet, neuer Timer-State
                             JUMP local_wr_state_s2                  ; neuer Timer-State: c_state_forward
                             ;
                             ; ------------------------------ State "Stopped" -------------------------------
                             ;
        local_state_stopped: ; 2. Kontakt erreicht
                             COMPARE s3_key_status, c_key_idle
                             JUMP Z, local_state_reverse_0           ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                             COMPARE s3_key_status, c_key_moving
                             JUMP Z, local_state_reverse_0           ; Taste hat zweiten Kontakt verlassen, bewegt sich zurück
      local_state_stopped_0: 
                             COMPARE s2, c_state_stopped             ; bereits gestoppt und gesendet?
                             RETURN Z                                ; nichts machen, wenn bereits gestoppt
                             LOAD s2, c_state_stopped
                             CALL local_wr_state_s2                  ; neuer Timer-State: c_state_stopped
                             JUMP local_states_on                    ; Dynamik-Wert eintragen, MIDI ON senden und Ende
                             ;
                             ; ------------------------------ State "Reverse" -------------------------------
                             ;
        local_state_reverse: 
                             COMPARE s3_key_status, c_key_idle
                             JUMP Z, local_state_idle_off            ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                             COMPARE s3_key_status, c_key_on
                             JUMP Z, local_state_retrig              ; Taste hat Endkontakt nochmal erreicht
                             COMPARE s3_key_status, c_key_dirty
                             JUMP Z, local_state_retrig              ; Taste hat Endkontakt nochmal erreicht
      local_state_reverse_0: ; erstmals auf dem Rückweg
                             COMPARE s2, c_state_reverse             ; bereits c_state_reverse?
                             RETURN Z                                ; dann zurück
                             LOAD s2, c_state_reverse
                             CALL local_wr_state_s2                  ; neuer Timer-State: c_state_reverse
                             JUMP local_states_off                   ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                             ;
         local_state_retrig: ; Retrigger mit etwas verringertem Dynamik-Wert wenn erneut ON
                             LOAD s2, c_state_stopped                ; nächster Timer-State: Stopped
                             CALL local_wr_state_s2
                             CALL local_rd_dyntimer_s0
                             LOAD s1, A0                             ; zweiter Anschlag etwas geringer
                             CALL mult_soft_s0_s1                    ; s0 x s1 => s8_msb, s7_lsb, s0 bleibt bestehen
                             ADD s8_msb, 01                          ; Subtrahend nicht 0 werden lassen
                             STORE s8_msb, s_last_key_velocity       ; neuer Raw-Wert Dynamik
                             JUMP local_states_on                    ; Dynamik-Wert holen, MIDI ON senden und Ende
                             ;
                             ; ------------------------------------------------------------------------------
                             ; Lokale Dyntimer und States lesen/schreiben
                             ; ------------------------------------------------------------------------------
                             ;
       local_wr_dyntimer_s0: ;  Taste in RAM_ADDR, zu schreibende Daten in s0
                             LOAD idx_ptr, c_page_dyntimer
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Daten
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             RETURN 
                             ;
       local_rd_dyntimer_s0: ; Taste in scan_addr, gelesene Daten später in s0
                             LOAD idx_ptr, c_page_dyntimer
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_read_mask
                             INPUT s0, (idx_ptr)                     ; Upper, Lower oder Pedal Read
                             RETURN                                  ; Zustand in s0
                             ;
          local_wr_state_s2: ; zu schreibende Daten in s2, Taste in RAM_ADDR
                             LOAD idx_ptr, c_page_keystate
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer
                             OUTPUT s2, RAM_WRDATA                   ; zu schreibende Daten
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s2, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             RETURN 
                             ;
          local_rd_state_s2: ; Taste in scan_addr, gelesene Daten später in s2
                             LOAD idx_ptr, c_page_keystate
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_read_mask
                             INPUT s2, (idx_ptr)                     ; Timer-State dieser Taste in s2
                             RETURN 
                             ;
          local_wr_early_s3: ; s3_key_status auf Adresse s_local_key speichern
                             LOAD idx_ptr, c_page_earlystep
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             FETCH s0, s_local_key                   ; Taste
                             OUTPUT s0, RAM_ADDR                     ; Tastennummer
                             ; gleich hier in local_steps umrechnen
                             LOAD s1, s3_key_status
                             COMPARE s1, 00
                             JUMP Z, local_wr_early_s3_0             ; wenn OFF, weiter mit 0
                             FETCH s0, s_last_key_velocity           ; letzte gemessene Dynamik
                             COMPARE s0, 00
                             CALL NZ, event_dyn2s0                   ; in 2 Stufen umrechnen
                             LOAD s1, s0
        local_wr_early_s3_0: 
                             OUTPUT s1, RAM_WRDATA                   ; zu schreibende Zustand in s3_key_status
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             RETURN 
                             ;
            local_wr_dynkey: 
                             ; Scanned-RAM Dynamik
                             ; Taste in scan_addr, s_local_dyn und manual_select
                             LOAD idx_ptr, c_page_velocity
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             FETCH s0, s_local_key                   ; Taste
                             OUTPUT s0, RAM_ADDR                     ; Tastennummer
                             ; Dynamik schreiben
                             FETCH s0, s_local_dyn                   ; Dynamik dieser Taste
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Dynamik in s0
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             ; Umgerechnet in 2 Stufen für Event-Loop
                             LOAD idx_ptr, c_page_latestep
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             FETCH s0, s_local_dyn                   ; Dynamik dieser Taste
                             COMPARE s0, 00
                             CALL NZ, event_dyn2s0
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Dynamik in s0
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             RETURN 
                             ;
                             ; ------------------------------------------------------------------------------
                             ;
            local_states_on: 
                             ; Dynamik-Kurve durch variables Timer-Dekrement, simuliert 1/t
                             ; Liefert Maximalwerte, die kleiner als 255 sein können
                             ; Hier wird MIDI-Wert deshalb auf etwas über /2 korrigiert
                             ;
                             COMPARE manual_select, 02
                             JUMP Z, local_states_on_pedal
                             FETCH s1, s_velocityfac                 ; 0..31, von SPI_CONFIG_1 Bits 7..2
                             ; Wert bei höheren Velocity-Faktoren leicht erhöhen
                             ADD s1, 84                              ; 80 = halbierter Wert in s8_msb
                             FETCH s0, s_last_key_velocity
                             CALL mult_soft_s0_s1                    ; s0 x s1 => s8_msb, s7_lsb
                             LOAD s0, s8_msb
                             ADD s0, 08
                             COMPARE s0, c_midi_mindyn               ; Carry bei A - B < 0, MIDI-Minimalwert
                             CALL C, load_s0_with_mindyn
                             COMPARE s0, 7F                          ; Carry bei A - B < 0
                             CALL NC, load_s0_with_7F
                             STORE s0, s_last_key_velocity           ; letzte gemessene ON-Dynamik
                             STORE s0, s_local_dyn
                             JUMP local_states_out
                             ;
      local_states_on_pedal: 
                             LOAD s0, 41                             ; Pedal hat keine Dynamik, nur 1 Bit (0) im RAM
                             STORE s0, s_local_dyn
                             JUMP local_states_out
                             ;
                             ; ------------------------------------------------------------------------------
                             ;
           local_states_off: 
                             LOAD s0, 00
                             STORE s0, s_local_dyn
                             ;
           local_states_out: ; s_local_key und s_local_dyn senden
                             ; Dynamik in s_local_dyn, Taste in s_local_key, für aktuelles Manual schreiben
                             CALL local_wr_dynkey
                             ; CANCEL-Pins abfragen, unterdrücken MIDI-Senden
                             INPUT s0, PRESCANPIN                    ; Bit 0 ist Cancel MIDI Kanal OM
                             XOR s0, FF                              ; invertiert!
                             AND s0, 03
                             SUB s0, 01
                             COMPARE s0, manual_select
                             RETURN Z
                             ; Manual in manual_select, On/Off-Dynamik in s_local_dyn
                             ; immer auch an SAM5504 dh. MIDI_TX_2 senden
                             FETCH s0, s_midich                      ; eingestellter Kanal
                             LOAD s1, manual_select                  ; Manual-Nummer addieren
                             ADD s0, s1
                             OR s0, 90
                             CALL midi_tx_both
                             ;
                             FETCH s0, s_local_key
                             ADD s0, c_midi_offset                   ; transp. Key in s0
                             INPUT s1, SPI_KEYTRANSPOSE              ; MIDI-OUT-Transpose
                             ADD s0, s1
                             CALL midi_tx_both
                             ;
                             FETCH s0, s_local_dyn                   ; gemessene Dynamik
                             JUMP midi_tx_both                       ; 0 = OFF senden
                             ;
                             ; ------------------------------------------------------------------------------
                             ; Multiplier 8x8 unsigned, s0 x s1, Ergebnis in msb und lsb, s0 wird nicht verändert
                             ; ------------------------------------------------------------------------------
                             ;
             square_soft_s0: ; s0 squared => s8_msb, s7_lsb
                             LOAD s1, s0
            mult_soft_s0_s1: ; s0 x s1 => s8_msb, s7_lsb
                             LOAD s8_msb, 00
                             LOAD idx_ptr, 08                        ; Schleifenzähler
                  mult_loop: 
                             SR0 s1
                             JUMP NC, mult_shift
                             ADD s8_msb, s0
                 mult_shift: 
                             SRA s8_msb
                             SRA s7_lsb
                             SUB idx_ptr, 01
                             JUMP NZ, mult_loop
                             RETURN 
                             ;
                             ; ------------------------------------------------------------------------------
                             ;
            load_s0_with_FF: 
                             LOAD s0, FF
                             RETURN 
                             ;
            load_s0_with_7F: 
                             LOAD s0, 7F
                             RETURN 
                             ;
            load_s0_with_01: 
                             LOAD s0, 01
                             RETURN 
                             ;
        load_s0_with_mindyn: 
                             LOAD s0, c_midi_mindyn
                             RETURN 
                             ;
                             ;
                             ; ###############################################################################
                             ; ########################## Eigene Schleife EVENT-LOOP #########################
                             ; ###############################################################################
                             ;
                             ; Variablen unabhängig von Scan-Routine benutzt
                             ; scan_addr: Adresse des MPX-RAMs 64 Worte
                             ; ca. 165 µs Gesamtzeit bei 25-Tasten-Pedal
                             ;
             event_handling: 
                             LOAD s0, 00                             ; Start mit Taste 0
                             STORE s0, s_keycount_upper
                             STORE s0, s_keycount_lower
                             STORE s0, s_keycount_pedal
                             STORE s0, s_pedal_on                    ; Speicher für gedrückte Taste
                             LOAD scan_addr, 00                      ; Start mit Taste 12
                             STORE scan_addr, s_scan_key_save
                             INPUT s0, SPI_CONFIG_1                  ; Early-Action-Mode?
                             TEST s0, 01                             ; AND -> Z-Flag
                             JUMP NZ, event_loop_early               ; Wenn Early Action ON
                 event_loop: 
                             FETCH scan_addr, s_scan_key_save
                             CALL event_setcontacts
                             ADD scan_addr, 01                       ; nächste Taste
                             STORE scan_addr, s_scan_key_save
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             JUMP NZ, event_loop
                             JUMP event_loop_exit
                             ;
           event_loop_early: 
                             FETCH scan_addr, s_scan_key_save
                             CALL event_setcontacts_early
                             ADD scan_addr, 01                       ; nächste Taste
                             STORE scan_addr, s_scan_key_save
                             COMPARE scan_addr, c_maxkeys_plus_one   ; alle Tasten abgefragt?
                             JUMP NZ, event_loop_early
                             ;
            event_loop_exit: 
                             LOAD s0, 01
                             OUTPUT s0, PED_ACC_ENA                  ; normal ON
                             FETCH s0, s_pedal_on
                             OUTPUT s0, PEDAL_DOWN                   ; ist '1' wenn irgendeine Pedaltaste gedrückt ist
                             ;
                             ; Pedal-Click, simpel
                             ;
                             COMPARE s0, 00
                             JUMP Z, event_loop_reset_pedalnoise     ; wenn kein Pedal gedrückt
                             ;
                             INPUT s1, SPI_CLICKLEN
                             AND s1, 0F
                             COMPARE s1, 00
                             JUMP Z, event_loop_nopedalclick
                             SL0 s1                                  ; verdoppeln wg. schnellerer Main Loop
                             ADD s1, 04
    event_loop_nopedalclick: 
                             FETCH s0, s_pedal_noisecounter
                             COMPARE s0, s1
                             JUMP Z, event_loop_pedal_noiseoff
                             ADD s0, 01
                             STORE s0, s_pedal_noisecounter
                             INPUT s0, RND_NUMBER
                             AND s0, 01
                             OUTPUT s0, PED_ACC_ENA                  ; Random Noise ausgeben
                             RETURN 
                             ;
event_loop_reset_pedalnoise: 
                             LOAD s0, 00
                             STORE s0, s_pedal_noisecounter
  event_loop_pedal_noiseoff: 
                             LOAD s0, 01
                             OUTPUT s0, PED_ACC_ENA                  ; normal ON
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
               event_dyn2s0: 
                             COMPARE s0, c_dyn_threshold             ; Dynamikschwelle
                             JUMP C, event_dyn2s0_0                  ; JUMP wenn kleiner
                             LOAD s0, 03                             ; ist schnell
                             RETURN 
             event_dyn2s0_0: 
                             LOAD s0, 01
                             RETURN 
                             ;
         event_dyn2s0_pedal: 
                             LOAD s0, 03                             ; ist ON
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
          event_rd_step_all: 
                             ; bereits von Scanned-RAM Dynamik umgerechnete 3 Bytes auf Adresse RAM_ADDR lesen
                             LOAD idx_ptr, c_page_latestep
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             LOAD s0, s0                             ; Delay!
                             INPUT s0, RD_PEDAL
                             STORE s0, s_keystatus_pedal             ; 0 oder 1
                             INPUT s0, RD_LOWER
                             STORE s0, s_keystatus_lower
                             INPUT s3_key_status, RD_UPPER           ; wird ohnehin gleich gebraucht
                             ;INPUT s0, RD_UPPER
                             ;STORE s0, s_keystatus_upper
                             RETURN 
                             ;
         event_rd_early_all: 
                             ; 3 Bytes s_keystatus_xxx auf Adresse RAM_ADDR lesen
                             LOAD idx_ptr, c_page_earlystep
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             LOAD s0, s0                             ; Delay!
                             INPUT s0, RD_PEDAL
                             STORE s0, s_keystatus_pedal
                             INPUT s0, RD_LOWER
                             STORE s0, s_keystatus_lower
                             INPUT s3_key_status, RD_UPPER           ; wird ohnehin gleich gebraucht
                             ;INPUT s0, RD_UPPER
                             ;STORE s0, s_keystatus_upper
                             RETURN 
                             ;
         event_rd_vcont_all: 
                             ; 3 Bytes s_vcont_xxx auf Adresse RAM_ADDR lesen
                             LOAD idx_ptr, c_page_vcontacts
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             LOAD s0, s0                             ; Delay!
                             ;INPUT s0, RD_PEDAL
                             ;STORE s0, s_vcont_pedal                ; nicht benötigt
                             INPUT s0, RD_LOWER
                             STORE s0, s_vcont_lower
                             INPUT s4_contacts, RD_UPPER             ; wird ohnehin gleich gebraucht
                             ;INPUT s0, RD_UPPER
                             ;STORE s0, s_vcont_upper
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; +++++++++++ Wird mit allen scan_addr-Tastennummern aufgerufen ++++++++++++++++
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
          event_setcontacts: 
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer, hier überall gültig
                             CALL event_rd_vcont_all                 ; alte VCONTACT-Zustände in s_vcont_xxx, 3 Bytes
                             CALL event_rd_step_all                  ; ermittelten Step (Dynamik) aus Adresse scan_addr holen
                             ; Umgerechneter Tastenzustand jetzt in s_keystatus_upper, s_keystatus_lower, s_keystatus_pedal
                             JUMP event_setcontacts_0
                             ;
    event_setcontacts_early: 
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer, hier überall gültig
                             CALL event_rd_vcont_all                 ; alte VCONTACT-Zustände in s_vcont_xxx, 3 Bytes
                             CALL event_rd_early_all                 ; Early-Tastenzustand aus Adresse scan_addr holen
        event_setcontacts_0: 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; UPPER
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             ;FETCH s3_key_status, s_keystatus_upper
                             ;FETCH s4_contacts, s_vcont_upper
                             LOAD manual_select, 00                  ; 0 = UPPER
                             LOAD s0, s4_contacts
                             OR s0, s3_key_status
                             CALL NZ, mpx_setkey                     ; nur wenn nicht beide 0 sind
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; LOWER
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             FETCH s3_key_status, s_keystatus_lower
                             FETCH s4_contacts, s_vcont_lower
                             LOAD manual_select, 01                  ; 1 = LOWER
                             LOAD s0, s4_contacts
                             OR s0, s3_key_status
                             CALL NZ, mpx_setkey                     ; nur wenn nicht beide 0 sind
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; PEDAL
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             COMPARE scan_addr, c_maxbasskeys
                             RETURN NC                               ; wenn scan_addr > c_maxbasskeys
                             FETCH s3_key_status, s_keystatus_pedal
                             LOAD manual_select, 02                  ; 2 = PEDAL
                             JUMP mpx_setkey_pedal                   ; und zurück
                             ;
                             ;
                             ; ##############################################################################
                             ; für alle Manuale, muss wg. Noise-Timer-Update ständig aufgerufen werden
                             ; ##############################################################################
                             ;
                 mpx_setkey: 
                             ; Offsets und Split auswerten, virtuelle Tastenkontakte setzen
                             ; scan_addr ist jetzt innerhalb Generator-Bereich 0..60
                             ; Letzten Kontakt-Zustand holen und merken. Wir verwenden diesen Wert
                             ; auch gleich zum Ermitteln der tatsächlich eingeschalteten Tasten.
                             ;
                             COMPARE s4_contacts, 00                 ; alter Zustand vom letzen Durchlauf
                             JUMP Z, mpx_onoff
                             ; s_keycount_* bei tatsächlich klingenden Noten erhöhen
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, s_keycount_upper           ; Basisadresse
                             FETCH s0, (idx_ptr)
                             ADD s0, 01
                             STORE s0, (idx_ptr)
                             ; scan_addr für Split merken, Taste is ON
                             FETCH s0, s_scan_key_save
                             STORE s0, s_lastkey_on
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Zugriff auf die virtuellen Tastenkontakte
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                  mpx_onoff: 
                             ; Sostenuto-Flag setzen, wenn SOSTENUTO aktiv und KEY ON
                             COMPARE s3_key_status, 00
                             JUMP Z, mpx_off                         ; wenn aktueller Zustand OFF
                             COMPARE s4_contacts, 15'd
                             RETURN Z                                ; ist bereits ganz an, nichts machen
                             CALL mpx_changed
                             COMPARE s3_key_status, 01
                             JUMP Z, mpx_slow                        ; nur 1. Kontakt, slow inc
                             JUMP mpx_fast                           ; 1. und/oder 2. Kontakt
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                mpx_changed: 
                             ; Tastenkontaktzustand hat sich geändert.
                             ; Flag setzen, wenn Sostenuto-Pedal NICHT aktiv ist und Taste gedrückt wird.
                             ; Die dann gedrückten Tasten werden beim Ausschalten übersprungen, d.h. bleiben an
                             LOAD idx_ptr, manual_select             ; Sostenuto-Pedal für dieses Manual?
                             ADD idx_ptr, s_sosten_upr
                             FETCH s0, (idx_ptr)
                             XOR s0, FF                              ; invertieren
                             AND s0, s3_key_status
                             ; s0 ist EIN, wenn Taste EIN und Sostenuto AUS
                             CALL ramwrite_sostenutoflag_61
                             RETURN 
                    mpx_off: 
                             ; Taste ist erstmals aus.
                             LOAD idx_ptr, manual_select             ; Sostenuto-Pedal für dieses Manual?
                             ADD idx_ptr, s_sosten_upr
                             FETCH s0, (idx_ptr)
                             COMPARE s0, 00
                             JUMP Z, mpx_off_0                       ; Sostenuto ist aus
                             CALL ramread_sostenutoflag_61
                             COMPARE s0, 00
                             ; die bei Sostenuto NICHT gedrückten Tasten beim Ausschalten überspringen
                             RETURN NZ
                  mpx_off_0: 
                             LOAD idx_ptr, manual_select             ; Sustain-Pedal für dieses Manual?
                             ADD idx_ptr, s_sustain_upr
                             FETCH s0, (idx_ptr)
                             COMPARE s0, 00
                             RETURN NZ                               ; nicht abschalten, Sustain ist aktiv
                             CALL reset_noisetimer
                             LOAD s0, s4_contacts
                             AND s0, 15'd                            ; Noise wegmaskieren
                             LOAD s1, s0                             ; Noise lassen
                             INPUT s2, SPI_CLICKLEN
                             AND s2, 0F
                             COMPARE s2, 05                          ; A < B -> C set, A >= B -> C cleared
                             CALL C, mpx_clear_s1                    ; ist kleiner als 8
                             SL0 s0                                  ; Zustand halbieren, halber Pegel
                             JUMP mpx_set_contacts
               mpx_clear_s1: 
                             LOAD s1, 00                             ; KeyOff-Noise löschen wenn ClickLen < 8
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Differenzierter Key Click
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                   mpx_fast: 
                             ; Taste ist nicht offen
                             ; zweiter Kontakt geschlossen, voll gedrückt, fast inc to max.
                             CALL start_noisetimer_fastkey           ; starten, falls noch in Ruhe
                             FETCH s0, s_noisetimerval
                             COMPARE s0, FF                          ; Timer-Wert noch in s0
                             JUMP Z, mpx_fullon                      ; Klick beendet?
                             COMPARE s0, FD                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_halfon                     ; 2 ms vor Ende halber Steady-Pegel, JUMP wenn Timer-Wert in s0 > $FD
                             COMPARE s0, FB                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_fullnoise                  ; 4 ms vor Ende voller Noise-Pegel, JUMP wenn Timer-Wert in s0 > $FB
                             JUMP mpx_halfnoise
                   mpx_slow: 
                             ; Taste ist nicht offen
                             ; nur erster Kontakt geschlossen
                             CALL start_noisetimer_slowkey           ; ggf starten; aktueller Timer-Wert in s_noisetimerval
                             FETCH s0, s_noisetimerval
                             COMPARE s0, FF                          ; Timer-Wert noch in s0
                             JUMP Z, mpx_fullon                      ; Klick beendet?
                             COMPARE s0, FE                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_halfon                     ; 1 ms vor Ende halber Steady-Pegel, JUMP wenn Timer-Wert in s0 > $FE
                             COMPARE s0, FC                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_fullnoise                  ; 2 ms vor Ende voller Noise-Pegel, JUMP wenn Timer-Wert in s0 > $FC
                             ; JUMP mpx_halfnoise
              mpx_halfnoise: 
                             LOAD s0, 00                             ; half level
                             LOAD s1, 07
                             JUMP mpx_set_contacts
              mpx_fullnoise: 
                             LOAD s0, 08                             ; full level
                             LOAD s1, 07                             ; all noise
                             JUMP mpx_set_contacts
                 mpx_halfon: 
                             LOAD s0, 07
                             LOAD s1, 00
                             JUMP mpx_set_contacts
                 mpx_fullon: 
                             LOAD s0, 0F                             ; full
                             LOAD s1, 00                             ; no noise
                             ; jump mpx_set_contacts
           mpx_set_contacts: 
                             ; Steady- (s0) und Noise-Anteil (s1) in mpx-RAM schreiben
                             ; Tastennnummer in scan_addr
                             ; Im Steady-Nibble s0: 0..7 Half Level, 8..15 Full Level (Bit 3)
                             ; in ein Byte packen und zum MPX-RAM schicken
                             ; in manual_select ist aktuell abgefragtes Manual
                             SL0 s1
                             SL0 s1
                             SL0 s1
                             SL0 s1
                             AND s0, 15'd
                             OR s0, s1
                             JUMP ramwrite_vcont_61
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
           mpx_setkey_pedal: 
                             ; kleine Sonderbehandlung für Pedal, hat keine Dynamik und keine Noise-Bits:
                             ; s3_key_status enthält 0 (Taste aus) oder anderen Wert (Taste an),
                             ; Falls sich neue Taste geändert hat, alte Taste löschen
                             ; Vorher gespielte Pedaltaste löschen, Nummer der neue Pedaltaste merken
                             ; manual_select enthält 2
                             ;
                             COMPARE s3_key_status, 00
                             JUMP Z, mpx_setkey_pedal_0              ; Taste ist aus wenn 0
                             LOAD s3_key_status, 01                  ; nur zwei Zustände zulassen, hier ON
                             FETCH s0, s_pedal_on                    ; Speicher für gedrückte Taste
                             OR s0, s3_key_status
                             STORE s0, s_pedal_on                    ; kann innerhalb Pedalschleife '1' werden
         mpx_setkey_pedal_0: 
                             ; get_state/set_state hier nicht benötigt, weil kein Noise berücksichtigt wird
                             LOAD s0, s3_key_status
                             JUMP ramwrite_vcont_61                  ; Taste in scan_addr, Zustand in s0
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Werte in MPX/Scratch-RAM setzen mit aktuellem manual_select und scan_addr
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
   ramread_sostenutoflag_61: 
                             ; Sostenuto-Flag
                             ; Taste in scan_addr, gelesene Daten später in s0
                             LOAD idx_ptr, c_page_sostenuto
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer in s0
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_read_mask
                             INPUT s0, (idx_ptr)                     ; Upper, Lower oder Pedal Read
                             RETURN                                  ; Zustand in s0
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
  ramwrite_sostenutoflag_61: 
                             ; zu schreibende Daten in s0
                             LOAD idx_ptr, c_page_sostenuto
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             JUMP ramwrite_61
          ramwrite_vcont_61: 
                             ; zu schreibende Daten in s0
                             LOAD idx_ptr, c_page_vcontacts
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                ramwrite_61: 
                             ; zu schreibende Daten in s0, MPX-RAM Page muss gesetzt sein, 0..61
                             OUTPUT s0, RAM_WRDATA
                             OUTPUT scan_addr, RAM_ADDR
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             RETURN 
                             ;
                             ; ##############################################################################
                             ; Hilfsroutinen: Werte in Timer/Scratch-RAM lesen oder schreiben
                             ; manual_select = 0 für Upper, manual_select = 1 für Lower Manual
                             ; ##############################################################################
                             ;
   start_noisetimer_fastkey: 
                             ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                             CALL get_noisetimer
                             STORE s0, s_noisetimerval
                             COMPARE s0, 00
                             RETURN NZ                               ; wenn bereits gestartet
                             ;
                             INPUT s1, RND_NUMBER                    ; zufällige Länge
                             AND s1, 03                              ; 0 bis 3
                             FETCH s0, s_clicklen                    ; Timer-Startwert,  237..252
                             SUB s0, s1                              ; um Zufallswert verlängern
                             JUMP set_noisetimer
                             ;
   start_noisetimer_slowkey: 
                             ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                             CALL get_noisetimer
                             STORE s0, s_noisetimerval
                             COMPARE s0, 00
                             RETURN NZ                               ; wenn bereits gestartet
                             ;
                             INPUT s1, RND_NUMBER                    ; zufällige Länge
                             AND s1, 01                              ; 0 oder 1
                             FETCH s0, s_clicklen                    ; Timer-Startwert,  237..255
                             SR1 s0                                  ; Timer-Startwert verdoppelt,  246..255
                             SUB s0, s1                              ; um kleinen Zufallswert verlängern
                             SUB s0, 01                              ; um kleinen Festwert verlängern
             set_noisetimer: 
                             LOAD idx_ptr, c_page_noisetimer
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             JUMP ramwrite_61
           reset_noisetimer: 
                             LOAD s0, 00
                             JUMP set_noisetimer
                             ;
             get_noisetimer: 
                             ; Taste in scan_addr, gelesene Daten später in s0
                             LOAD idx_ptr, c_page_noisetimer
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             OUTPUT scan_addr, RAM_ADDR              ; Tastennummer in s0
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_read_mask
                             INPUT s0, (idx_ptr)                     ; Upper, Lower oder Pedal Read
                             RETURN                                  ; Zustand in s0
                             ;
                             ; ##############################################################################
                             ; Dynamik- und Noise-Timer für beide Manuale aktualisieren
                             ; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014
                             ; wird einmal pro Scan-Durchlauf aufgerufen, dauert ca. 27 µs
                             ; ##############################################################################
                             ;
         update_noisetimers: 
                             LOAD idx_ptr, c_page_noisetimer
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page Noise-Timer
                             LOAD scan_addr, 00
                             ;
          update_timer_loop: 
                             OUTPUT scan_addr, RAM_ADDR
                             ADD scan_addr, 01
                             INPUT s0, RD_UPPER
                             COMPARE s0, 00
                             JUMP Z, update_timer_done1              ; noch nicht gestartet
                             COMPARE s0, FF
                             JUMP Z, update_timer_done1              ; bereits abgelaufen
                             ADD s0, 01
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Daten in s0
                             LOAD s0, 00                             ; NOP
                             OUTPUT s0, UPPER_STROBE
                             LOAD s0, 00                             ; NOP
         update_timer_done1: 
                             INPUT s0, RD_LOWER
                             COMPARE s0, 00
                             JUMP Z, update_timer_done2              ; noch nicht gestartet
                             COMPARE s0, FF
                             JUMP Z, update_timer_done2              ; bereits abgelaufen
                             ADD s0, 01
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Daten in s0
                             LOAD s0, 00                             ; NOP
                             OUTPUT s0, LOWER_STROBE
         update_timer_done2: 
                             COMPARE scan_addr, c_maxkeys_plus_one
                             JUMP NZ, update_timer_loop
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                allnotesoff: 
                             ; alle Töne, Flags und Timer löschen
                             LOAD s0, 00
                             STORE s0, s_sustain_upr
                             STORE s0, s_sustain_lwr
                             STORE s0, s_sosten_upr
                             STORE s0, s_sosten_lwr
                             OUTPUT s0, RAM_WRDATA                   ; Enables und Werte auf 0
                             OUTPUT s0, PEDAL_DOWN
                             LOAD scan_addr, 00
                             LOAD idx_ptr, 00
         allnotesoff_loop_0: 
                             OUTPUT scan_addr, RAM_ADDR
                             OUTPUT idx_ptr, RAM_PAGE
                             ADD scan_addr, 01
                             OUTPUT s0, UPPER_STROBE
                             OUTPUT s0, LOWER_STROBE
                             OUTPUT s0, PEDAL_STROBE
                             COMPARE scan_addr, 64'd                 ; 64 Durchläufe?
                             JUMP NZ, allnotesoff_loop_0
                             LOAD scan_addr, 00
                             ADD idx_ptr, 01
                             COMPARE idx_ptr, 16'd                   ; 16 Durchläufe?
                             JUMP NZ, allnotesoff_loop_0
                             ;
            reset_dyntimers: 
                             LOAD scan_addr, 00
                             LOAD idx_ptr, c_page_dyntimer
          reset_dyntimers_1: 
                             OUTPUT idx_ptr, RAM_PAGE
                             OUTPUT scan_addr, RAM_ADDR
                             LOAD s0, FF                             ; alle Dyntimer auf 255 setzen
                             OUTPUT s0, RAM_WRDATA                   ; Enables und Werte auf 0
                             ADD scan_addr, 01
                             OUTPUT s0, UPPER_STROBE
                             OUTPUT s0, LOWER_STROBE
                             COMPARE scan_addr, 64'd                 ; 64 Durchläufe?
                             JUMP NZ, reset_dyntimers_1
                             RETURN                                  ; fertig
                             ;
                             ;
                             ; ##############################################################################
                             ; ################## M I D I   R E C E I V E   DISPATCHER ######################
                             ; ##############################################################################
                             ;
                             ;
                             ; MIDI-Subroutinen für MIDI-Empfang
                             ; Dispatcher stellt fest, ob und was es zu tun gibt
                             ; wird regelmäßig aus Hauptschleife aufgerufen
                             ;
              midi_dispatch: 
       midi_dispatch_loop_1: 
                             INPUT s0, MIDI_IN1_STATUS
                             COMPARE s0, 00                          ; Daten empfangen?
                             JUMP Z, midi_dispatch_loop_2            ; wenn nein, weiter mit MIDI In 2 (SAM/USB)
                             CALL midi_1_receive                     ; Buffer lesen/leeren, Realtime filtern, Flags setzen
                             COMPARE midi_1_rxflag, 00
                             CALL NZ, midi_dispatch_1                ; interpretieren, falls komplett
                             JUMP midi_dispatch_loop_1
                             ;
       midi_dispatch_loop_2: 
                             INPUT s0, MIDI_IN2_STATUS
                             COMPARE s0, 00                          ; Daten empfangen?
                             JUMP Z, midi_dispatch_loop_3            ; wenn nein, weiter mit MIDI In 3 (AVR)
                             CALL midi_2_receive                     ; Buffer leeren
                             COMPARE midi_2_rxflag, 00
                             CALL NZ, midi_dispatch_2                ; interpretieren, falls komplett
                             JUMP midi_dispatch_loop_2
                             ;
       midi_dispatch_loop_3: 
                             INPUT s0, MIDI_AVR_STATUS
                             AND s0, 0E                              ; Daten empfangen?
                             RETURN Z                                ; wenn nein, zurück zur Main Loop
                             CALL midi_3_receive                     ; Buffer lesen/leeren, Flags setzen
                             COMPARE midi_3_rxflag, 00
                             CALL NZ, midi_dispatch_3                ; interpretieren, falls komplett
                             JUMP midi_dispatch_loop_3
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Daten auswerten, hier kein SysEx mehr
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
            midi_dispatch_1: 
                             ; Daten vom erstem MIDI-Eingang interpretieren, falls vollständig
                             LOAD midi_1_rxflag, 00                  ; Rx-Flag löschen
                             FETCH s0, s_midi_1_cmd                  ; von IRQ gesetzte Bytes
                             STORE s0, s_midi_cmd
                             FETCH s0, s_midi_1_data1
                             STORE s0, s_midi_data1
                             FETCH s0, s_midi_1_data2
                             STORE s0, s_midi_data2
                             FETCH s0, s_midi_1_len
                             STORE s0, s_midi_len
                             JUMP midi_dispatch_all                  ; Ende und RETURN
                             ;
            midi_dispatch_2: 
                             ; Daten vom zweiten MIDI-Eingang interpretieren, falls vollständig
                             LOAD midi_2_rxflag, 00                  ; Rx-Flag löschen
                             FETCH s0, s_midi_2_cmd                  ; von IRQ gesetzte Bytes
                             STORE s0, s_midi_cmd
                             FETCH s0, s_midi_2_data1
                             STORE s0, s_midi_data1
                             FETCH s0, s_midi_2_data2
                             STORE s0, s_midi_data2
                             FETCH s0, s_midi_2_len
                             STORE s0, s_midi_len
                             JUMP midi_dispatch_all                  ; Ende und RETURN
                             ;
            midi_dispatch_3: 
                             ; bei AVR  Controller Change nur auf ALL NOTES OFF prüfen, sonst senden
                             LOAD midi_3_rxflag, 00                  ; Rx-Flag löschen
                             FETCH s0, s_midi_3_cmd
                             AND s0, F0
                             COMPARE s0, B0                          ; Control Change?
                             JUMP NZ, midi_dispatch_3_send
                             FETCH s0, s_midi_3_cmd
                             AND s0, 0F                              ; Kanal isolieren
                             STORE s0, s_midi_chan_masked            ; für allnotesoff_manual
                             FETCH s0, s_midi_3_data1
                             COMPARE s0, 123'd                       ; All Notes OFF?
                             JUMP Z, allnotesoff_manual
       midi_dispatch_3_send: 
                             ; empfangenen Datensatz 1 bis 3 Bytes vom AVR an SAM und DIN-Buchse senden
                             FETCH s0, s_midi_3_cmd
                             CALL midi_tx_both
                             FETCH s0, s_midi_3_len
                             COMPARE s0, 00
                             RETURN Z
                             ;
                             FETCH s0, s_midi_3_data1
                             CALL midi_tx_both
                             FETCH s0, s_midi_3_len
                             COMPARE s0, 01
                             RETURN Z
                             ;
                             FETCH s0, s_midi_3_data2
                             JUMP midi_tx_both
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
          midi_dispatch_all: 
                             ; MIDI-Datensatz vollständig, dekodieren und ggf. RAM beschreiben
                             CALL midi_out2_waitbuf                  ; SAM5504-Buffer aufnahmebereit?
                             FETCH s1, s_midi_len
                             FETCH s0, s_midi_cmd
                             OUTPUT s0, MIDI_TX_2                    ; immer alles an SAM5504 senden
                             COMPARE s1, 00
                             JUMP Z, midi_dispatch_all_0
                             FETCH s0, s_midi_data1
                             OUTPUT s0, MIDI_TX_2
                             COMPARE s1, 01
                             JUMP Z, midi_dispatch_all_0
                             FETCH s0, s_midi_data2
                             OUTPUT s0, MIDI_TX_2
        midi_dispatch_all_0: 
                             FETCH s0, s_midi_cmd
                             AND s0, 0F                              ; Kanal isolieren
                             STORE s0, s_midi_chan_masked
                             FETCH s0, s_midi_cmd
                             AND s0, F0                              ; Befehl isolieren
                             STORE s0, s_midi_cmd_masked
                             ;
                             LOAD manual_select, 00                  ; Default upper
                             FETCH s1, s_midi_chan_masked
                             FETCH s0, s_midich                      ; eingestellter Kanal, Piano-Maske
                             COMPARE s1, s0                          ; eingestellter gleich empfangener Kanal?
                             JUMP Z, midi_dispatch_all_onoff         ; mit manual_select = 0, upper
                             ;
                             ADD s0, 01
                             LOAD manual_select, 01
                             COMPARE s1, s0                          ; eingestellter Kanal +1?
                             JUMP Z, midi_dispatch_all_onoff
                             ;
                             ADD s0, 01
                             LOAD manual_select, 02                  ; mit manual_select = 2, Pedal
                             COMPARE s1, s0                          ; eingestellter Kanal +2?
                             JUMP Z, midi_dispatch_pedal
                             ;
                             ; Sonderkanal +3 für Touchpad-CC, nur an AVR
                             ADD s0, 01
                             COMPARE s1, s0                          ; eingestellter Kanal +3?
                             JUMP Z, midi_to_avr
                             RETURN 
                             ;
                             ; Pedal-Sonderbehandlung, weil nur ein Bit statt ein Byte abgespeichert wird
                             ;
        midi_dispatch_pedal: 
                             FETCH s0, s_midi_cmd_masked
                             COMPARE s0, 80
                             JUMP Z, midi_dispatch_all_off           ; 0 speichern
                             COMPARE s0, 90
                             JUMP NZ, midi_dispatch_rest             ; wenn kein ON/OFF
                             ;
                             FETCH s0, s_midi_data2
                             COMPARE s0, 00
                             JUMP Z, midi_dispatch_all_off           ; war $90 mit Dynamik 0
                             ;
                             LOAD s0, 01
                             STORE s0, s_midi_data2
                             JUMP midi_dispatch_all_write
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
    midi_dispatch_all_onoff: 
                             ; MIDI-NoteOn/NoteOff-Befehle? Dynamik bereits in s2, Manual in manual_select
                             FETCH s0, s_midi_cmd_masked
                             COMPARE s0, 90
                             JUMP Z, midi_dispatch_all_write
                             COMPARE s0, 80
                             JUMP NZ, midi_dispatch_rest             ; wenn kein ON/OFF
                             ; ist ein ON/OFF-Befehl
      midi_dispatch_all_off: 
                             LOAD s0, 00                             ; MIDI-Befehl Taste OFF, Dynamik 0
                             STORE s0, s_midi_data2                  ; Dynamik dieser Taste 0
    midi_dispatch_all_write: 
                             ; jetzt Notenwert und Dynamik abspeichern
                             ; Dynamik ist 0 bei Key-Off-Befehl
                             FETCH s0, s_midi_data1                  ; MIDI-Transponierung
                             FETCH s1, s_transpose
                             ADD s0, s1
                             STORE s0, s_midi_data1
                             CALL midi_adjust_foldbacks_1            ; Sollte abschaltbar sein!
                             STORE s0, s_midi_data1
                             ;
                             ; Empfangsdaten, MIDI-Taste/Dynamik s_midi_data1, s_midi_data2 und manual_select ins RAM 0..60
                             ;
                             LOAD idx_ptr, c_page_velocity
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             FETCH s0, s_midi_data2                  ; Dynamik dieser Taste
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Dynamik in s0
                             FETCH s0, s_midi_data1                  ; MIDI-Key in s0, geht von 12 bis 121
                             SUB s0, c_gen_firstkey
                             OUTPUT s0, RAM_ADDR
                             ; Dynamik schreiben
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             ; Umgerechnet in 2 Stufen für Event-Loop
                             LOAD idx_ptr, c_page_latestep
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             FETCH s0, s_midi_data2                  ; Dynamik dieser Taste
                             COMPARE s0, 00
                             CALL NZ, event_dyn2s0
                             STORE s0, s_temp_s0
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibender Step in s0
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             ; auch für Early-Modus
                             LOAD idx_ptr, c_page_earlystep
                             OUTPUT idx_ptr, RAM_PAGE                ; MPX-RAM Page
                             FETCH s0, s_temp_s0                     ; Step dieser Taste
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibender Step in s0
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             RETURN 
                             ;
                             ; MIDI-Tasten außerhalb des 5-Oktaven-Umfangs oktavweise verschieben
                             ;
      midi_adjust_foldbacks: 
                             FETCH s0, s_midi_data1
    midi_adjust_foldbacks_1: 
                             COMPARE s0, c_gen_firstkey              ; Carry bei scan_addr - 36?
                             JUMP NC, midi_adjust_foldbacks_2        ; Carry nicht gesetzt >=36
                             ADD s0, 12'd
                             JUMP midi_adjust_foldbacks_1
                             ;
    midi_adjust_foldbacks_2: 
                             STORE s0, s_midi_data1
                             COMPARE s0, c_gen_lastkey_plus_one      ; Carry bei scan_addr - 97?
                             RETURN C
                             SUB s0, 12'd
                             JUMP midi_adjust_foldbacks_2
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
         midi_dispatch_rest: 
                             ; Program Change und Controller? Dann an AVR
                             COMPARE s0, C0
                             JUMP Z, midi_to_avr
                             COMPARE s0, E0
                             JUMP Z, midi_to_avr
                             COMPARE s0, B0
                             RETURN NZ                               ; alles andere unberücksichtigt
               midi_cchange: 
                             ; bei Controller Change auf ALL NOTES OFF prüfen, dann weiter wie Program Change
                             FETCH s0, s_midi_data1
                             COMPARE s0, 123'd                       ; All Notes OFF?
                             JUMP Z, allnotesoff_manual              ; falls nicht, weiter mit AVR-IRQ
                             ;
                midi_to_avr: 
                             ; AVR-IRQ auslösen; MIDI-Daten an SPI
                             FETCH s0, s_midi_cmd
                             OUTPUT s0, MIDI_CMD
                             FETCH s1, s_midi_data1                  ; s1 wird gleich weiterbenutzt
                             OUTPUT s1, MIDI_DB1
                             FETCH s0, s_midi_data2
                             OUTPUT s0, MIDI_DB2
                             CALL midi_strobe_avr                    ; an AVR senden, benutzt s0
                             ;
                             FETCH s0, s_midi_cmd_masked
                             COMPARE s0, B0                          ; Control Change empfangen?
                             RETURN NZ
                             ; ab hier nur noch Control Change Bx, auf allen benutzten Kanälen
                             ;
                             INPUT s0, SPI_MIDIOPT                   ; Bit 7 (MSB): USE SOST/SUSTAIN freigeschaltet?
                             AND s0, 80
                             RETURN Z                                ; wenn 0, dann nicht behandeln, abgeschaltet
                             ;
               midi_sustain: 
                             ; manual_select enthält empfangenes Ziel (0, 1 oder 2)
                             COMPARE s1, 40
                             JUMP NZ, midi_sustain_sostenuto
                             ;
                             LOAD idx_ptr, s_sustain_upr
                             JUMP midi_sustain_1                     ; evt. von SAM5504-HW-Input, muss auch gesendet werden
                             ;
     midi_sustain_sostenuto: 
                             COMPARE s1, 42
                             RETURN NZ
                             LOAD idx_ptr, s_sosten_upr
             midi_sustain_1: 
                             ADD idx_ptr, manual_select
                             FETCH s2, s_midi_data2
                             STORE s2, (idx_ptr)
                             ; OUTPUT s0, AUXPORT                    ; ### TEST - nur in MIDI-Scantreiber benutzen! ###
                             ;
                             ; Sustain und Sostenuto weitersenden, könnte vom DSP (Eingangs-Pins über Jumper) stammen
                             CALL midi_out_waitbuf                   ; benutzt s1!
                             FETCH s0, s_midi_cmd
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             FETCH s0, s_midi_data1
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             FETCH s0, s_midi_data2
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
         allnotesoff_manual: 
                             LOAD s0, 00                             ; Dynamik dieser Taste
                             ; alle Tasten löschen
                             FETCH idx_ptr, s_midi_chan_masked
                             FETCH s1, s_midich                      ; eingestellter Kanal
                             SUB idx_ptr, s1                         ; Manual in idx_ptr
                             ADD idx_ptr, c_strobe_mask              ; 0 bis 2 plus Offset
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Dynamik INPUT s0
                             LOAD s1, 00                             ; Schleifenzähler
   allnotesoff_manual_loop1: 
                             OUTPUT s1, RAM_ADDR                     ; Tastennummer in s1
                             LOAD s0, c_page_earlystep
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             LOAD s0, c_page_velocity
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             LOAD s0, c_page_keystate
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             LOAD s0, c_page_keystate
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             LOAD s0, c_page_sostenuto
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             ADD s1, 01
                             COMPARE s1, 64'd
                             JUMP NZ, allnotesoff_manual_loop1
                             RETURN 
                             ;
           midi_out_waitbuf: ; MIDI MAIN OUT
                             INPUT s1, TX_STATUS                     ; half full?
                             COMPARE s1, 00                          ; nur 0, wenn beide TX1 und TX2 weniger als halbvoll
                             JUMP NZ, midi_out_waitbuf               ; auf Buffer-Leerung warten
                             RETURN 
                             ;
          midi_out2_waitbuf: ; SAM5504-Buffer aufnahmebereit? zweiter interner MIDI-Ausgang
                             INPUT s1, TX_STATUS                     ; half full?
                             AND s1, 02
                             COMPARE s1, 02
                             JUMP Z, midi_out2_waitbuf               ; auf Buffer-Leerung warten
                             RETURN 
                             ;
                             ; ##############################################################################
                             ; ###################### M I D I   I N P U T  1 (DIN1) #########################
                             ; ##############################################################################
                             ;
                             ; MIDI Daten wurden von Input 1 empfangen
                             ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                             ;
             midi_1_receive: 
                             INPUT s0, MIDI_IN1
                             COMPARE s0, F0                          ; RealTime ab $F0?
                             JUMP C, midi_1_channel_message          ; wenn kleiner als F0, mit Channel Messages weiter
                             COMPARE s0, F8                          ; RealTime ab $F8?
                             RETURN NC                               ; Realtime ab #F8 ohne Daten, verwerfen
                             COMPARE s0, F0                          ; Start of SysEX, Flag setzen
                             JUMP Z, midi_1_start_sysex_to_avr
                             COMPARE s0, F7                          ; End of SysEX, Flag löschen
                             JUMP Z, midi_1_stop_sysex_to_avr
                             ; ab hier nur noch Werte zwischen F1 und F6 übrig:
                             ; F1 Timecode Quarter Frame, F2 Song Position Pointer, F3 Select Song
                             LOAD s1, FF
                             STORE s1, s_midi_1_ignoreflag           ; Flag setzen: folgende Daten ignorieren
                             RETURN 
                             ;
     midi_1_channel_message: 
                             TEST s0, 80
                             JUMP Z, midi_1_is_databyte
                             ; ist ab hier eine Channel Message
                             STORE s0, s_midi_1_cmd
                             LOAD s1, 00                             ; ist ein neuer (Running) Status
                             STORE s1, s_midi_1_counter
                             STORE s1, s_midi_1_ignoreflag           ; Flag löschen: bald folgende Daten wieder relevant
                             COMPARE midi_1_SysExFlag, 00
                             JUMP NZ, midi_1_stop_sysex_to_avr       ; Sysex durch Channel-Command beendet
                             RETURN 
                             ;
         midi_1_is_databyte: 
                             COMPARE midi_1_SysExFlag, 00            ; Läuft SysEx-Übertragung?
                             JUMP NZ, midi_1_sysex_to_avr_s0         ; dann Daten zum AVR senden
                             ;
                             FETCH s1, s_midi_1_ignoreflag           ; Daten von Sytem Common F1, F2, F3?
                             COMPARE s1, 00
                             RETURN NZ                               ; Datenbytes ignorieren wenn ja
                             ;
                             FETCH s1, s_midi_1_counter
                             ADD s1, 01
                             STORE s1, s_midi_1_counter
                             COMPARE s1, 02
                             JUMP Z, midi_1_is_second_databyte
                             ;
                             ; erstes Datenbyte empfangen:
                             ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                             ; Datensatz ist mit einem Datenbyte vollständig!
                             FETCH s1, s_midi_1_cmd
                             AND s1, F0                              ; Kanal ausmaskieren
                             COMPARE s1, C0                          ; program change
                             JUMP Z, midi_1_is_singledatabyte
                             COMPARE s1, D0                          ; channel pressure
                             JUMP Z, midi_1_is_singledatabyte
   midi_1_is_first_databyte: 
                             STORE s0, s_midi_1_data1
                             RETURN 
                             ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
   midi_1_is_singledatabyte: 
                             STORE s0, s_midi_1_data1
  midi_1_is_second_databyte: 
                             STORE s0, s_midi_1_data2
                             FETCH s1, s_midi_1_counter
                             STORE s1, s_midi_1_len                  ; letzte Anzahl empfangener Datenbytes
                             LOAD s1, 00                             ; Datensatz vollständig
                             STORE s1, s_midi_1_counter              ; neue Anzahl empfangener Datenbytes
                             LOAD midi_1_rxflag, FF                  ; jetzt vollständig, Flag setzen
                             RETURN 
                             ;
  midi_1_start_sysex_to_avr: 
                             ; SysEx-Start $F0 wurde empfangen, ist in s0
                             LOAD midi_1_SysExFlag, 01
                             JUMP midi_1_sysex_to_avr_s0
                             ;
   midi_1_stop_sysex_to_avr: 
                             LOAD midi_1_SysExFlag, 00
                             LOAD s0, F7
     midi_1_sysex_to_avr_s0: 
                             ; 3 Bytes werden parallel übertragen, deshalb Umsetzung auf Controller für AVR-SPI
                             LOAD s1, B0
                             OUTPUT s1, MIDI_CMD
                             LOAD s1, 78                             ; eigener Controller $7B = 123, eigentlich AllNotesOff
                             OUTPUT s1, MIDI_DB1
                             OUTPUT s0, MIDI_DB2                     ; SysEx-Daten einschl. F0 und F7, hier 8 Bit zulässig!
                             JUMP midi_strobe_avr                    ; und RETURN
                             ;
                             ; ##############################################################################
                             ; ################# M I D I   I N P U T  2 (DIN2/SAM/USB) ######################
                             ; ##############################################################################
                             ;
                             ; MIDI Daten wurden von Input 2 empfangen
                             ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                             ;
             midi_2_receive: 
                             INPUT s0, MIDI_IN2
                             COMPARE s0, F0                          ; RealTime ab $F0?
                             JUMP C, midi_2_channel_message          ; wenn kleiner als F0, mit Channel Messages weiter
                             COMPARE s0, F8                          ; RealTime ab $F8?
                             RETURN NC                               ; Realtime ab #F8 ohne Daten, verwerfen
                             COMPARE s0, F0                          ; Start of SysEX, Flag setzen
                             JUMP Z, midi_2_start_sysex_to_avr
                             COMPARE s0, F7                          ; End of SysEX, Flag löschen
                             JUMP Z, midi_2_stop_sysex_to_avr
                             ; ab hier nur noch Werte zwischen F1 und F6 übrig:
                             ; F1 Timecode Quarter Frame, F2 Song Position Pointer, F3 Select Song
                             LOAD s1, FF
                             STORE s1, s_midi_2_ignoreflag           ; Flag setzen: folgende Daten ignorieren
                             RETURN 
                             ;
     midi_2_channel_message: 
                             TEST s0, 80
                             JUMP Z, midi_2_is_databyte
                             ; ist ab hier eine Channel Message
                             STORE s0, s_midi_2_cmd
                             LOAD s1, 00                             ; ist ein neuer (Running) Status
                             STORE s1, s_midi_2_counter
                             STORE s1, s_midi_2_ignoreflag           ; Flag löschen: bald folgende Daten wieder relevant
                             COMPARE midi_2_SysExFlag, 00
                             JUMP NZ, midi_2_stop_sysex_to_avr       ; Sysex durch Channel-Command beendet
                             RETURN 
                             ;
         midi_2_is_databyte: 
                             COMPARE midi_2_SysExFlag, 00            ; Läuft SysEx-Übertragung?
                             JUMP NZ, midi_2_sysex_to_avr_s0         ; dann Daten zum AVR senden
                             ;
                             FETCH s1, s_midi_2_ignoreflag           ; Daten von Sytem Common F1, F2, F3?
                             COMPARE s1, 00
                             RETURN NZ                               ; Datenbytes ignorieren wenn ja
                             ;
                             FETCH s1, s_midi_2_counter
                             ADD s1, 01
                             STORE s1, s_midi_2_counter
                             COMPARE s1, 02
                             JUMP Z, midi_2_is_second_databyte
                             ;
                             ; erstes Datenbyte empfangen:
                             ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                             ; Datensatz ist mit einem Datenbyte vollständig!
                             FETCH s1, s_midi_2_cmd
                             AND s1, F0                              ; Kanal ausmaskieren
                             COMPARE s1, C0                          ; program change
                             JUMP Z, midi_2_is_singledatabyte
                             COMPARE s1, D0                          ; channel pressure
                             JUMP Z, midi_2_is_singledatabyte
   midi_2_is_first_databyte: 
                             STORE s0, s_midi_2_data1
                             RETURN 
                             ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
   midi_2_is_singledatabyte: 
                             STORE s0, s_midi_2_data1
  midi_2_is_second_databyte: 
                             STORE s0, s_midi_2_data2
                             FETCH s1, s_midi_2_counter
                             STORE s1, s_midi_2_len                  ; letzte Anzahl empfangener Datenbytes
                             LOAD s1, 00                             ; Datensatz vollständig
                             STORE s1, s_midi_2_counter              ; neue Anzahl empfangener Datenbytes
                             LOAD midi_2_rxflag, FF                  ; jetzt vollständig, Flag setzen
                             RETURN 
                             ;
  midi_2_start_sysex_to_avr: 
                             LOAD midi_2_SysExFlag, FF
                             JUMP midi_2_sysex_to_avr_s0
                             ;
                             ; SysEx-Datenübertragung immer komplett abwarten
   midi_2_stop_sysex_to_avr: 
                             LOAD midi_2_SysExFlag, 00
                             LOAD s0, F7
     midi_2_sysex_to_avr_s0: 
                             ; SysEx-Start $F0 wurde empfangen, ist in s0
                             ; 3 Bytes werden parallel übertragen, deshalb Umsetzung auf Controller für AVR-SPI
                             LOAD s1, B0
                             OUTPUT s1, MIDI_CMD
                             LOAD s1, 78                             ; eigener Controller $7B = 123, eigentlich AllNotesOff
                             OUTPUT s1, MIDI_DB1
                             OUTPUT s0, MIDI_DB2                     ; SysEx-Daten einschl. F0 und F7, hier 8 Bit zulässig!
                             JUMP midi_strobe_avr                    ; und RETURN
                             ;
                             ; ##############################################################################
                             ; ###################### M I D I   I N P U T  3 (AVR) ##########################
                             ; ##############################################################################
                             ;
                             ; SPI-MIDI Daten wurden von AVR empfangen
                             ; vereinfachte SysEx-Behandlung
             midi_3_receive: 
                             ;
                             ; LOAD s1, FA ; ##### TEST #####
                             ; OUTPUT s1, AUXPORT ; Trigger für LA
                             ; OUTPUT s0, AUXPORT ; ##### TEST #####
                             INPUT s0, MIDI_AVR
                             COMPARE s0, F0                          ; SysEx-Start?
                             JUMP Z, midi_3_startSysEx
                             COMPARE s0, F7                          ; SysEx-Ende?
                             JUMP Z, midi_3_stopSysEx
                             FETCH s1, s_midi_3_SysExFlag
                             COMPARE s1, 00
                             JUMP NZ, midi_tx_both                   ; s0 Senden, Übertragung läuft noch
                             ;
                             TEST s0, 80
                             JUMP Z, midi_3_is_databyte
                             LOAD s1, 00                             ; ist ein neuer (Running) Status
                             STORE s1, s_midi_3_counter
                             STORE s1, s_midi_3_SysExFlag
                             STORE s0, s_midi_3_cmd
                             RETURN 
         midi_3_is_databyte: 
                             FETCH s1, s_midi_3_counter
                             ADD s1, 01
                             STORE s1, s_midi_3_counter
                             COMPARE s1, 02
                             JUMP Z, midi_3_is_second_databyte
                             ; erstes Datenbyte empfangen:
                             ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                             ; Datensatz ist mit einem Datenbyte vollständig!
                             FETCH s1, s_midi_3_cmd
                             AND s1, F0                              ; Kanal ausmaskieren
                             COMPARE s1, C0                          ; program change
                             JUMP Z, midi_3_is_singledatabyte
                             COMPARE s1, D0                          ; channel pressure
                             JUMP Z, midi_3_is_singledatabyte
   midi_3_is_first_databyte: 
                             STORE s0, s_midi_3_data1
                             RETURN 
                             ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
   midi_3_is_singledatabyte: 
                             STORE s0, s_midi_3_data1
  midi_3_is_second_databyte: 
                             STORE s0, s_midi_3_data2
                             FETCH s1, s_midi_3_counter
                             STORE s1, s_midi_3_len                  ; Anzahl empfangener Datenbytes
                             LOAD s1, 00                             ; Datensatz vollständig
                             STORE s1, s_midi_3_counter              ; letzte Anzahl empfangener Datenbytes
                             LOAD midi_3_rxflag, FF                  ; jetzt vollständig, Flag setzen
                             RETURN 
                             ; SysEx-Daten vom AVR unbehandelt senden, aber Flag setzen
          midi_3_startSysEx: 
                             CALL midi_tx_both                       ; verwendet s1
                             LOAD s1, FF
                             STORE s1, s_midi_3_SysExFlag
                             RETURN 
           midi_3_stopSysEx: 
                             CALL midi_tx_both                       ; verwendet s1
                             LOAD s1, 00
                             STORE s1, s_midi_3_SysExFlag
                             RETURN 
                             ;
            midi_strobe_avr: 
                             LOAD s0, 01                             ; pos. Flanke an MIDI-FIFO
                             OUTPUT s0, MIDI_STR
                             LOAD s0, 00
                             OUTPUT s0, MIDI_STR
                             RETURN 
                             ;
                             ; ##############################################################################
                             ; ##############################################################################
                             ; ###                           Initialisierungen                            ###
                             ; ##############################################################################
                             ; ##############################################################################
                             ;
                  scan_init: 
                             LOAD s0, 00
                             OUTPUT s0, SCANPORT
                             OUTPUT s0, STATUS
                             OUTPUT s0, MIDI_OUT_SEL
                             LOAD midi_1_rxflag, 00
                             LOAD midi_2_rxflag, 00
                             LOAD midi_1_SysExFlag, 00
                             LOAD midi_2_SysExFlag, 00
                             LOAD midi_3_rxflag, 00
                             LOAD matrix_key, 00
                             LOAD manual_select, 00
                             LOAD s8_msb, 00
                             LOAD s7_lsb, 00
                             LOAD scan_addr, 00
                             LOAD s3_key_status, 00
                             LOAD idx_ptr, 00
                             LOAD s0, 00
          zero_scratch_loop: 
                             STORE s0, (idx_ptr)
                             ADD idx_ptr, 01
                             COMPARE idx_ptr, 40
                             JUMP NZ, zero_scratch_loop
                             ;
                             LOAD s0, 40
                             STORE s0, s_last_key_velocity
                             LOAD idx_ptr, 00
                             CALL scan_wait_init
                             CALL allnotesoff
                             LOAD s0, 00
                             OUTPUT s0, RAM_PAGE
                             CALL split_exit
                             ; INIT Message mit ScanCore Info
                             LOAD s0, c_corevers
                             OUTPUT s0, MIDI_DB2
                             LOAD s0, c_corerevi
                             OUTPUT s0, MIDI_DB1
                             LOAD s0, AA
                             OUTPUT s0, MIDI_CMD
                             CALL midi_strobe_avr
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
               midi_testout: 
                             ; für Debug-Zwecke, sendet MIDI-Programchange mit Wert in s0
                             LOAD s1, C0
                             OUTPUT s1, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             OUTPUT s1, MIDI_TX_2                    ; TX Midi an SAM
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             OUTPUT s0, MIDI_TX_2                    ; TX Midi an SAM
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                scan_config: 
                             LOAD s0, 00
                             FETCH s1, s_keycount_upper              ; Anzahl gedrückter Tasten Upper
                             COMPARE s1, 00
                             CALL NZ, load_s0_with_FF
                             OUTPUT s0, KEYS_ON_UPR
                             ;
                             LOAD s0, 00
                             FETCH s1, s_keycount_lower              ; Anzahl gedrückter Tasten Lower
                             COMPARE s1, 00
                             CALL NZ, load_s0_with_FF
                             OUTPUT s0, KEYS_ON_LWR
                             ;
                             INPUT s0, SPI_CONFIG_1
                             SR0 s0
                             SR0 s0
                             STORE s0, s_velocityfac                 ; waren Bits 7..2, nochmals halbiert
                             INPUT s0, SPI_GENTRANSPOSE
                             FETCH s1, s_transpose
                             COMPARE s0, s1
                             STORE s0, s_transpose
                             CALL NZ, split_exit                     ; Generator-Transpose geändert
                             INPUT s1, SPI_CLICKLEN
                             AND s1, 0F                              ; max. 15 ms
                             LOAD s0, FF
                             SUB s0, s1
                             STORE s0, s_clicklen                    ; Startwert 1ms-Timer, max. 255
                             INPUT s0, SPI_CLICKLEN
                             AND s0, F0
                             SR0 s0
                             SR0 s0                                  ; Wert immer noch vervierfacht
                             ; z.B. $13(5A) = Teilfaktor 4954 für 10 kHz Samples oder 5 kHz Noise-Frequenz
                             OUTPUT s0, NOISE_FREQ
                             ; MIDI-Kanal geändert?
                             FETCH s1, s_midich
                             INPUT s0, SPI_MIDICH
                             COMPARE s0, s1
                             STORE s0, s_midich
                             CALL NZ, allnotesoff                    ; wenn MIDI-Kanal geändert
                             ; OUTPUT s0, AUXPORT ; Trigger für LA
                             INPUT s0, SPI_MIDIOPT
                             OUTPUT s0, MIDI_OUT_SEL
                             ;
                             ; Split überprüfen. In SPI_XXX befindet sich ggf. neue Split-ON/OFF-Einstellung vom Panel
                             FETCH s0, s_splitpoint
                             INPUT s1, SPI_SPLITPOINT
                             STORE s1, s_splitpoint
                             COMPARE s0, s1
                             CALL NZ, split_changed                  ; wenn geändert
                             ;
                             FETCH s0, s_splitmode
                             INPUT s1, SPI_SPLITMODE
                             STORE s1, s_splitmode
                             COMPARE s0, s1
                             CALL NZ, split_changed                  ; wenn geändert
                             ;
                             FETCH s0, s_split_on                    ; alter Split-On-Zustand
                             INPUT s1, SPI_SPLITON                   ; neu von Bedienelement
                             STORE s1, s_split_on
                             COMPARE s0, s1
                             RETURN Z                                ; nicht geändert
                             TEST s1, 02                             ; Split-Request-Bit gesetzt?
                             JUMP NZ, set_splitpoint                 ; anhand eigener Tastendrücke setzen
                             ; sonst nur weiter mit split_changed
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
              split_changed: 
                             CALL allnotesoff                        ; wenn geändert
             split_mode_new: 
                             FETCH s0, s_split_on
                             AND s0, 03
                             ; COMPARE s0, 00
                             JUMP Z, split_exit
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
             scan_wait_init: 
                             LOAD s0, c_scankey_delay                ; Scan-Timer neu laden
                             OUTPUT s0, SCANTIMER_VAL
                             RETURN 
                             ; Active Sensing senden falls Timer abgelaufen
             active_sensing: 
                             FETCH s0, s_midi_activesensing          ; nach 256 ms Active Sensing senden
                             ADD s0, 01
                             STORE s0, s_midi_activesensing
                             COMPARE s0, 00
                             RETURN NZ
                             ; TEST: Active Sensing abgeschaltet
                             ; RETURN
                             CALL midi_out_waitbuf
                             LOAD s0, FE
                             OUTPUT s0, MIDI_TX_1
                             OUTPUT s0, MIDI_TX_2
                             RETURN 
                             ;
                             ; ##############################################################################
                             ; Splitmode setzen:
                             ; 0 = PedalToLower,
                             ; 1 = LowerToUpper
                             ; 2 = PedalToUpper
                             ; 3 = LowerToUpper + 1 Oktave
                             ; 4 = LowerToUpper + 2 Oktaven
                             ; 5 = Add Pedal to Lower
                             ; ##############################################################################
                             ;
             set_splitpoint: 
                             FETCH s0, s_split_on
                             AND s0, 03
                             ; COMPARE s0, 00                            ; nun ausgeschaltet?
                             JUMP Z, split_exit                      ; dann All Notes Off und Ende
                             ; Split-Funktion wurde seit letztem Durchlauf von OFF auf ON geändert.
                             ; Feststellen, ob Keyboard-Tasten gedrückt wurden, dann diese setzen und als
                             ; Splitpoint an AVR senden.
                             FETCH s0, s_keycount_upper
                             FETCH s1, s_keycount_lower
                             ADD s0, s1
                             COMPARE s0, 00
                             JUMP Z, split_exit                      ; keine Tasten gedrückt, alter Splitmode
                             FETCH s7_lsb, s_lastkey_on
                             STORE s7_lsb, s_splitpoint
                             ;
                             COMPARE s1, 00
                             JUMP Z, set_splitpoint_upper            ; keine Tasten auf Lower, also Upper
                             SUB s1, 01
                             COMPARE s1, 00
                             JUMP Z, set_splitpoint_store            ; wenn nur eine Taste gedrückt, SplitMode 0 speichern
                             LOAD s1, 05                             ; sonst 5 = Add Pedal to Lower
                             JUMP set_splitpoint_store
                             ;
       set_splitpoint_upper: 
                             ; Anzahl der Tasten Obermanual ist zufällig auch Splitmode 0..4
                             FETCH s1, s_keycount_upper
       set_splitpoint_store: 
                             STORE s1, s_splitmode
                             ; gewünschten Splitmode an AVR senden, über internal MIDI an Controller $70 und $71
                             LOAD s0, B0
                             OUTPUT s0, MIDI_CMD
                             LOAD s0, 76
                             OUTPUT s0, MIDI_DB1
                             OUTPUT s1, MIDI_DB2
                             CALL midi_strobe_avr
                             ; MIDI_CMD bleibt!
                             LOAD s0, 77
                             OUTPUT s0, MIDI_DB1
                             OUTPUT s7_lsb, MIDI_DB2
                             CALL midi_strobe_avr
                             ;
                 split_exit: 
                             CALL allnotesoff                        ; Lokale Noten löschen
                             FETCH s0, s_midich                      ; AllNotesOff-Controller senden
                             ADD s0, B0
                             CALL split_sendoff_data
                             FETCH s0, s_midich
                             ADD s0, B1
                             CALL split_sendoff_data
                             FETCH s0, s_midich
                             ADD s0, B2
                             CALL split_sendoff_data
                             JUMP local_wait_keys_released           ;´Auf Loslassen aller Tasten warten
                             ;
         split_sendoff_data: 
                             CALL midi_tx_both
                             LOAD s0, 7B                             ; Controller 123
                             CALL midi_tx_both
                             LOAD s0, 7F                             ; 127
                             CALL midi_tx_both
                             RETURN 
