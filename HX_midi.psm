                             ; ##############################################################################
                             ; ############ KCPSM6 PicoBlaze Keyboard Scanner by cm 10/2010 #################
                             ; #################### for 12 BIT ADDRESS ROM (4096 Words) #####################
                             ; ##############################################################################
                             ;
                             ; 13.06.2024 #44 Differenzierter Key Click, etwas schwächer
                             ; 30.07.2021 #37 Sendet AllNotesOff bei Split-Änderungen, SplitMode 5 (AddPedalToLower)
                             ; 18.05.2021 #36 Andere Noise-Berechnung
                             ; 03.09.2020 #28 Keine Übersetzung Sostenuto mehr
                             ; 22.02.2020 #25 Auch Kanal +3 an AVR für Touchpad
                             ; 20.11.2019 #23 MIDI-Dispatcher verbessert, wird öfter ausgeführt
                             ; 10.11.2019 #20 Local Enables auf SPI $2E (hier irrelevant)
                             ; 13.02.2018 #18 Bug in Key Transpose behoben (nicht bei MIDI)
                             ; 22.11.2018 #17 Split-Handling gelöscht, weil keine eigene Tastatur
                             ; 12.09.2018 #15 Bug in Midi-Kanalwahl behoben
                             ; 14.08.2018 #14 Bug in local_midisend_off (Dyn. 1 gesendet) behoben
                             ; 09.08.2018 #12 Sostenuto-Controller 42 geändert auf 45, HOLD2-Pedal wg. NI B4-PERC Konflikt
                             ; 24.04.2018 #11 Bugfixes für Fatar
                             ; 20.02.2017 #10 Zusätzlicher MIDI-Ausgang für SAM5504
                             ; 10.10.2017 Angepasst für KCPSM6, Inputs für Cancel Manual und HW-Sostenuto/Sustain auf PL Auxiliary
                             ; Pins schalten nach Masse!
                             ; Pin 6 = Bit 5 Sustain Upper
                             ; Pin 5 = Bit 4 Sostenuto Upper
                             ; Pin 4 = Bit 3 Sustain Lower
                             ; Pin 3 = Bit 2 Sostenuto Lower
                             ; Pin 2 = Bit 1 Cancel MIDI Kanal invert., 11 = Cancel Off, 10 = Cancel Upper,
                             ; Pin 1 = Bit 0 Cancel MIDI Kanal invert., 01 = Cancel Lower, 00 = Cancel Pedal
                             ;
                             CONSTANT c_midi_minofs, 01              ; Local MIDI Dynamikkurven-Offset, 1-2 für Fatar Mx
                             CONSTANT c_corevers, 53                 ; $50=SR4014, $51=Fatar, $52=Opto, $53=MIDI RcvOnly
                             CONSTANT c_corerevi, 44                 ; Revisionsnummer
                             CONSTANT c_dyn_threshold, 28            ; MIDI-Dynamikschwelle für full click
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             ; Je nach Tastaturumfang sind anzupassen:
                             CONSTANT c_maxkeys, 61'd                ; längste vorhandene Tastatur (44/49/61)
                             CONSTANT c_maxbasskeys, 25'd            ; Anzahl der Pedal-Tasten an AuxPort PL8
                             CONSTANT c_midi_firstkey, 12'd
                             CONSTANT c_midi_lastkey, 122'd
                             CONSTANT c_gen_firstkey, 36'd           ; Tonumfang INPUT MIDI-Notennummern
                             CONSTANT c_gen_lastkey, 97'd            ; 96+1 wg. COMPARE
                             CONSTANT c_midi_offset, 36'd            ; Offset zu unterster MIDI-Note "C" bei 5 Oktaven (default 36)
                             CONSTANT c_scankey_delay, 47'd          ; Delay pro Taste für 1 ms Scandurchlauf INPUT SYNC-Ticks (20,4 µs)
                             ;
                             ; nach Assemblierung DAT-Datei für XMODEM-Upload
                             ; erstellen mit Tool hex2dat_kcpsm6.exe oder Batch convert_xxx.bat
                             ;
                             ; ##############################################################################
                             ; ############################ MPX-RAM-Organisation ###########################
                             ; ##############################################################################
                             ;
                             ; Ein/Ausschalten der HX3-Tastenkontakte erfolgt durch Schreiben der
                             ; Kontaktdaten INPUT ein Dual-Port-RAM, das sogerannte MPX-RAM.
                             ; Jede Taste(nspalte) belegt eine Adresse,
                             ; so dass das tiefste "C" immer Adresse 0 hat, das höchste "C" Adresse 60.
                             ; Für jedes Manual stehen 8 Bits des 18-Bit-Datenbusses zur Verfügung,
                             ; für das Pedal 2 (sonst ungenutzte Paritätsbits). Jeder Teil kann getrennt geschrieben/gelesen werden.
                             ; MPX-RAM besteht aus 16 Pages je 64 Worte, 16 Bit plus zwei "Parity"-Bits,
                             ; die hier für den Pedal-Status benutzt werden.
                             ; Auswahl der Page über PB_PAGE.
                             ; s8_msb_smode, LSB und Parity-Bits können getrennt über STROBEs geschrieben werden.
                             ; Page 0 dient direkt als Freigabe für Tastenkontakte:
                             ; ##### LOWER ##### ##### UPPER ##### - Bytes
                             ; 7 MSN 4 3 LSN 0 7 MSN 4 3 LSN 0 - Nibbles
                             ; #NOISE# #STEADY# #NOISE# #STEADY#
                             ; - C B A L C B A - C B A L C B A - Bits
                             ; mit ABC = Anzahl eingeschalteter Tastenkontakte, L = Level-Bit,
                             ; Dabei wird Wert ABC jeweils anhand des folgenden Schemas dekodiert:
                             ; 76543210 ; Busbar CONTACT-Bit 0 = 16'. Bit 7 schaltet sowohl 1' als auch 1 1/3' ein!
                             ; 00000000 ; Stufe 0, alle aus
                             ; 00100000 ; Stufe 1...
                             ; 00100100
                             ; 01100100
                             ; 01100110
                             ; 11100110
                             ; 11101111
                             ; 11111111 ; bis Stufe 7, alle an bzw. alle noisy
                             ; Level-Bit L gelangt direkt zum CONTACT-Level-Bit 8.
                             ; Ist STEADY komplett an, ist der Wert des Noise-Gates egal, da Werte verODERt werden.
                             ; Pedalkontakt CONT_PEDAL ist an Bit(0) angeschlossen, Bit (1) kann als Scratch dienen.
                             ; Die Nibbles können INPUT pb_scanif.vhd einzeln gelesen werden!
                             ; PAGE 1 als Soft-Timer für Tastenkontakte
                             ; PAGE 2 als Soft-Timer für Noise
                             ; PAGEs 6 bis 15 können nach Belieben verwendet werden.
                             ;
                             ; MPX RAM_PAGE Offsets
                             ; Seitenaufteilung INPUT 64-Byte-Seiten über RAM_PAGE
                             CONSTANT c_page_vcontacts, 00           ; virtuelle Tastenkontakte, 0..61, direktes Lesen und Schreiben
                             ; Alle Timer starten bei Schreiben eines Wertes ungleich 0 und stoppen bei Erreichen von 255.
                             CONSTANT c_page_dyntimer, 01            ; Dynamik-Timer 0..61
                             CONSTANT c_page_noisetimer, 02          ; Noise-Timer 0..61
                             CONSTANT c_page_keystatus1, 04          ; Eigene Tastatur Zustand für Tasten 12..63
                             CONSTANT c_page_keystatus2, 05          ; Eigene Tastatur Zustand für Tasten 64.. 121
                             CONSTANT c_page_midirx1, 06             ; MIDI-Empfangsdaten Dynamik für Tasten 12..63
                             CONSTANT c_page_midirx2, 07             ; MIDI-Empfangsdaten Dynamik für Tasten 64.. 121
                             CONSTANT c_page_sostenutoflags, 08      ; Sostenuto-Flags 0..61
                             CONSTANT c_page_midisentflags, 09       ; MIDI-sent-Flags 0..61
                             CONSTANT c_page_localdyn1, 0A           ; MIDI-Empfangsdaten Dynamik für Tasten 12..63
                             CONSTANT c_page_localdyn2, 0B           ; MIDI-Empfangsdaten Dynamik für Tasten 64.. 121
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Portadressen bidirektional
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             ; $00 bis $07 Einzelbits SCANPORT Eingang, für Opto und Fatar
                             CONSTANT SCANPIO1, 00
                             CONSTANT SCANPIO2, 01
                             CONSTANT SCANPIO3, 02
                             CONSTANT SCANPIO4, 03
                             CONSTANT SCANPIO5, 04
                             CONSTANT SCANPIO6, 05
                             CONSTANT SCANPIO7, 06
                             CONSTANT SCANPIN8, 07
                             ; $00 bis $07 Einzelbits AUXPORT Eingang, für OrganScan/HOAX5 mit 4014 und Bass13/25
                             CONSTANT AUXPIO1, 08
                             CONSTANT AUXPIO2, 09
                             CONSTANT AUXPIO3, 0A
                             CONSTANT AUXPIO4, 0B
                             CONSTANT AUXPIO5, 0C
                             CONSTANT AUXPIO6, 0D
                             CONSTANT AUXPIO7, 0E
                             CONSTANT AUXPIN8, 0F
                             CONSTANT SCANPIN, 10                    ; Scan Port gesamt Leser
                             CONSTANT SCANPORT, 10                   ; Scan Port gesamt Schreiben
                             CONSTANT SCANPORT_DDR, 11               ; Data Direction für Scan IF
                             CONSTANT AUXPIN, 18                     ; Auxiliary Port gesamt
                             CONSTANT AUXPORT, 18
                             CONSTANT AUXPORT_DDR, 19                ; Data Direction für Scan IF
                             CONSTANT PRESCANPIN, 32                 ; (50), PresetScan
                             CONSTANT PRESCANPORT, 28                ; (40) Preset-Scan-Port
                             CONSTANT PRESCANPORT_DDR, 29            ; (41) Preset - Scan - PortDirection
                             ; Output ports
                             CONSTANT c_strobe_mask, 20              ; für indirektes Schreiben
                             CONSTANT UPPER_STROBE, 20               ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Upper (1 Byte)
                             CONSTANT LOWER_STROBE, 21               ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Lower (1 Byte)
                             CONSTANT PEDAL_STROBE, 22               ; Schreibzugriff erzeugt Write für Pedal-Bits (2 Bits)
                             CONSTANT MIDI_CMD, 30                   ; MIDI-Befehl
                             CONSTANT MIDI_DB1, 31
                             CONSTANT MIDI_DB2, 32
                             CONSTANT MIDI_STR, 33                   ; MIDI Strobe für AVR, neg. Flanke
                             CONSTANT STATUS, 34                     ; STATUS an AVR SPI, Bit 0 bis 3 durch PB schreibbar, Bit 4 und 5 direkt SPI MIDI FIFO STAT
                             CONSTANT KEYS_ON_UPR, 35                ; Bit 0: auf Upper sind Tasten gedrückt
                             CONSTANT KEYS_ON_LWR, 36                ; Bit 0: auf Lower sind Tasten gedrückt
                             ; CONSTANT BASS_ENV, 37                 ; UNUSED
                             CONSTANT PEDAL_DOWN, 38                 ; Bit 0
                             CONSTANT TEST_PORT, 39                  ; LED/LA-TEST
                             CONSTANT MIDI_OUT_SEL, 3A               ; auf 4-fach Multiplexer,
                             ; MIDI_OUT_SEL: 0 = MIDI_TX_1, 1 = MIDI_IN_1, 2 = MIDI_IN_2, 3 = MIDI_FROM_SAM (USB)
                             CONSTANT TWG_CONF_0, 3B
                             CONSTANT TWG_CONF_1, 3C
                             ; Universal-Timer, hier für Scan-Durchlauf, 255 = 5,22 ms
                             ; wird mit jedem SYNC alle 20,48 µs dekrementiert bis 0 erreicht
                             CONSTANT SCANTIMER_VAL, 3D              ; Schreiben des neuen Wertes startet Timer
                             CONSTANT SCANTIMER_ZERO, 3E             ; Flag wenn 0 erreicht
                             CONSTANT NOISE_FREQ, 3F                 ; bestimmt Noise-Frequenz
                             CONSTANT RAM_PAGE, 40                   ; Seitenadresse zum einfacheren Zugriff, Page 0 = MPX Dual Port
                             CONSTANT RAM_ADDR, 41                   ; für alle Zugriffe gültig
                             CONSTANT RAM_WRDATA, 42                 ; zu schreibende Daten
                             CONSTANT MIDI_TX_1, 80                  ; MIDI UART-Tx-FIFO MAIN
                             CONSTANT MIDI_TX_2, 81                  ; MIDI UART-Tx-FIFO VENT (intern an Ventilator oder Mini-GM-Modul)
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Input Ports
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Flags für SPI-Empfang:
                             ; Bit 0 = Daten wurden geschrieben (wird durch Lesen der SPI-Register gelöscht)
                             ; Bit 1 = AVR-MIDI FIFO Daten im Buffer,
                             ; Bit 2 = AVR-MIDI FIFO Buffer halb voll
                             ; Bit 3 = AVR-MIDI FIFO Buffer voll
                             CONSTANT SPI_FLAG, 30                   ; "0000000" & spiflag
                             CONSTANT TX_STATUS, 31                  ; Bit 0 = Buffer halbvoll, Bit 1 = Buffer voll
                             CONSTANT c_read_mask, 34                ; für indirektes Lesen
                             CONSTANT RD_UPPER, 34                   ; Upper-Byte vom MPX-RAM
                             CONSTANT RD_LOWER, 35                   ; Lower-Byte vom MPX-RAM
                             CONSTANT RD_PEDAL, 36                   ; Pedal-Bits vom MPX-RAM (1:0)
                             CONSTANT MIDI_IN1, 38
                             CONSTANT MIDI_IN1_STATUS, 39            ; "0000" & midi_1_full & midi_1_half & midi_1_datapresent & '0';
                             CONSTANT MIDI_IN2, 3A
                             CONSTANT MIDI_IN2_STATUS, 3B            ; "0000" & midi_2_full & midi_2_half & midi_2_datapresent & '0';
                             CONSTANT MIDI_AVR, 3C                   ; MIDI vom AVR über SPI
                             CONSTANT MIDI_AVR_STATUS, 3D            ; "0000" & avrfifo_full & avrfifo_half & avrfifo_datapresent & avrmidiflag
                             CONSTANT RND_NUMBER, 3F                 ; Zufallswert 8 Bit
                             ; Werte vom AVR-SPI
                             CONSTANT SPI_MIDICH, 24                 ; Adresse 4 von außen (AVR)
                             CONSTANT SPI_MIDIOPT, 25
                             CONSTANT SPI_SPLITMODE, 26
                             CONSTANT SPI_SPLITON, 27                ; Adresse 7 von außen (AVR)
                             CONSTANT SPI_SPLITPOINT, 28             ; Adresse 8 von außen (AVR)
                             CONSTANT SPI_CLICKLEN, 29
                             CONSTANT SPI_GENTRANSPOSE, 2A           ; Generator Transpose (10)
                             CONSTANT SPI_CONFIG_1, 2B               ; EARLY_KEY
                             ; SPI_AVR_MIDI, 2C ; AVR-MIDI-Daten, FIFO-Eingang
                             CONSTANT SPI_KEYTRANSPOSE, 2D
                             CONSTANT SPI_LOCALDISABLES, 2E
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Picoblaze Scratchpad Memory
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             CONSTANT s_scannedkey, 00               ; für Tastenabfrage
                             ; CONSTANT s_dummy_01, 01
                             ; CONSTANT s_dummy_02, 02
                             CONSTANT s_gentranspose, 03             ; Tongenerator-Transpose
                             CONSTANT s_keytranspose, 04             ; Tastatur-Transpose
                             CONSTANT s_split_on, 05                 ; Letzter Split-Zustand
                             CONSTANT s_xb2_key, 06                  ; Timer-Daten von XB2-Tastatur
                             CONSTANT s_xb2_velo, 07
                             CONSTANT s_splitpoint, 08               ; Tastennummer von SPI-AVR
                             CONSTANT s_splitmode, 09
                             ; 10..29 MIDI-Daten für Interpreter/Dispatcher
                             CONSTANT s_midi_cmd, 10'd
                             CONSTANT s_midi_data1, 11'd
                             CONSTANT s_midi_data2, 12'd
                             CONSTANT s_midi_len, 13'd
                             CONSTANT s_midi_cmd_masked, 14'd        ; upper Nibble
                             CONSTANT s_midi_chan_masked, 15'd       ; lower Nibble
                             ; MIDI-Daten per Polling vom FIFO, Port 1
                             CONSTANT s_midi_1_cmd, 16'd
                             CONSTANT s_midi_1_data1, 17'd
                             CONSTANT s_midi_1_data2, 18'd
                             CONSTANT s_midi_1_len, 19'd
                             CONSTANT s_midi_1_counter, 20'd
                             ; MIDI-Daten per Polling vom FIFO, Port 2
                             CONSTANT s_midi_2_cmd, 21'd
                             CONSTANT s_midi_2_data1, 22'd
                             CONSTANT s_midi_2_data2, 23'd
                             CONSTANT s_midi_2_len, 24'd
                             CONSTANT s_midi_2_counter, 25'd
                             ; MIDI-Daten per Polling vom AVR-FIFO
                             CONSTANT s_midi_3_cmd, 26'd
                             CONSTANT s_midi_3_data1, 27'd
                             CONSTANT s_midi_3_data2, 28'd
                             CONSTANT s_midi_3_len, 29'd
                             CONSTANT s_midi_3_counter, 30'd
                             CONSTANT s_midi_3_SysExFlag, 31'd
                             ;
                             CONSTANT s_keycount_upper, 32'd
                             CONSTANT s_keycount_lower, 33'd
                             CONSTANT s_keycount_pedal, 33'd
                             CONSTANT s_midi_activesensing, 35'd     ; Zähler/Timer für MIDI Active Sensing
                             CONSTANT s_key_matrix, 36'd             ; für FATAR
                             CONSTANT s_group_matrix, 37'd           ; für FATAR
                             CONSTANT s_noisetimerval, 38'd
                             CONSTANT s_pedal_on, 39'd               ; Bass-Flag Trigger für Hüllkurve
                             CONSTANT s_midich, 40'd                 ; eingestellter MIDI-Kanal
                             CONSTANT s_midi_1_ignoreflag, 41'd      ; MIDI-Datenempfang: System Commons und deren Daten ignorieren
                             CONSTANT s_midi_2_ignoreflag, 42'd
                             CONSTANT s_switches_old, 43'd           ; kommt als Bit 1 von Split_ON (0000 00X0)
                             CONSTANT s_sustain_upr, 44'd
                             CONSTANT s_sustain_lwr, 45'd
                             ; 46 Dummy für Pedal, immer 0, nicht belegen!
                             CONSTANT s_sosten_upr, 47'd             ; Empfangenes CC 64, Sostenuto aktiv
                             CONSTANT s_sosten_lwr, 48'd
                             ; 49 Dummy für Pedal, immer 0, nicht belegen!
                             CONSTANT s_midi_localkey, 50'd          ; für local out, enthält aktuelle Taste einschließlich Offset
                             CONSTANT s_midi_localdyn, 51'd
                             CONSTANT s_pedal_noisecounter, 52'd
                             CONSTANT s_old_contacts, 53'd           ; aktueller Tastenzustand
                             CONSTANT s_lastkey_on, 54'd             ; letzte gedrückte Taste für Split
                             CONSTANT s_clicklen, 55'd               ; Timer-Startwert
                             ;
                             ;
                             CONSTANT s_upper_localdyn, 58'd         ; gleichzeitig von ramread_X_scan gelesene Werte
                             CONSTANT s_lower_localdyn, 59'd
                             CONSTANT s_pedal_localdyn, 60'd
                             CONSTANT s_upper_mididyn, 61'd          ; gleichzeitig von ramread_X_scan gelesene Werte
                             CONSTANT s_lower_mididyn, 62'd
                             CONSTANT s_pedal_mididyn, 63'd
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Register Renames
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             NAMEREG sF, midi_1_rxflag
                             NAMEREG sE, midi_2_rxflag
                             NAMEREG sD, midi_1_SysExFlag
                             NAMEREG sC, midi_2_SysExFlag
                             NAMEREG sB, midi_3_rxflag
                             ; häufig benutzte Variablen
                             NAMEREG sA, page_select                 ; Timer-Page c_page_xxx, 0..3=AutoInc-Timer, 4..15 = Scratch RAM
                             NAMEREG s9, manual_select               ; aktuelles Manual, 0 = upper, 1 = lower, 2 = bass
                             NAMEREG s8, s8_msb_smode                ; Zustand gedrückte Taste MIDI-Empfang, msb für Multiply
                             NAMEREG s7, s7_lsb_spoint               ; Zustand gedrückte Taste eigene Manuale, lsb für Multiply
                             NAMEREG s6, idx_ptr                     ; universeller Index-Zeiger
                             NAMEREG s5, event_key
                             NAMEREG s4, scan_number                 ; aktuelle Taste, Zähler ab 0 bis Tastenanzahl
                             NAMEREG s3, s3_key_status               ; Zustand gedrückte Taste Manual und allgemein
                             ; s0, s1, s2 als Universal-Akkus
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                 cold_start: 
                             ; Einsprungpunkt nach Laden des Scan Cores
                             DISABLE INTERRUPT
                             CALL port_init
                             CALL scan_init
                             INPUT s0, SPI_MIDIOPT                   ; Bit 7 (MSB): USE SOST/SUSTAIN
                             AND s0, 80
                             JUMP NZ, main_loop
                             LOAD s0, 00
                             STORE s0, s_sustain_upr
                             STORE s0, s_sustain_lwr
                             STORE s0, s_sosten_upr
                             STORE s0, s_sosten_lwr
                  main_loop: 
                             CALL midi_dispatch                      ; MIDI-Daten empfangen? - ca. 1,7 µs
                             ; auf Scan-Freigabe durch Timer warten und neu setzen
                             INPUT s0, SCANTIMER_ZERO                ; auf Scan-Freigabe warten
                             COMPARE s0, 00                          ; warte auf 1-ms-Tick
                             JUMP Z, main_loop
                             CALL scan_wait_init                     ; Scan-Timer neu starten
                             CALL scan_config                        ; Parameter-Änderungen? - ca. 3,4 µs
                             ; CALL handle_sustain_switches            ; Sustain/Sostenuto-Eingangspins
                             CALL update_timers                      ; alle Timer updaten - ca. 53 µs
                             ; CALL active_sensing                     ; ca. 1,3 µs
                             CALL midi_dispatch                      ; MIDI-Daten empfangen? - ca. 1,7 µs
                             CALL event_handling                     ; ca. 450 µs, Änderungen behandeln
                             JUMP main_loop
                             ;
                             ; ###############################################################################
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; +++++++++++++++++++++ Scanboard-spezifischer Teil, +++++++++++++++++++++++++++
                             ; +++++++++++++++++++++++++++++ Hauptschleife ++++++++++++++++++++++++++++++++++
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; ###############################################################################
                             ;
                             ; Hilfsroutinen: Zubehör für Scan-Routinen, Initialisierungen
                             ;
                  port_init: 
                             ; Scan-Ports initialisieren
                             LOAD s0, 33                             ; für Fatar-/Opto-Interface
                             OUTPUT s0, SCANPORT_DDR
                             LOAD s0, FF                             ; für Testport
                             OUTPUT s0, AUXPORT_DDR
                             LOAD s0, 00                             ; Sustainpedal, alles Eingänge
                             OUTPUT s0, PRESCANPORT_DDR
                             LOAD s0, FF                             ; Sustainpedal, alles Eingänge
                             OUTPUT s0, TEST_PORT
                             RETURN 
                             ;
                             ; ###############################################################################
                             ;
           clock_delay_long: 
                             LOAD s0, 0F
                             JUMP clock_delay_loop
                clock_delay: LOAD s0, 07
           clock_delay_loop: 
                             SUB s0, 01
                             JUMP NZ, clock_delay_loop
                             RETURN 
          clock_delay_short: 
                             LOAD s0, 02
     clock_delay_short_loop: 
                             SUB s0, 01
                             JUMP NZ, clock_delay_short_loop
      clock_delay_veryshort: 
                             LOAD s0, s0
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
               midi_tx_both: 
                             CALL midi_out_waitbuf                   ; benutzt s1!
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf beiden Ports
                             OUTPUT s0, MIDI_TX_2
                             LOAD s0, 00
                             STORE s0, s_midi_activesensing          ; Active Sensing Reset
                             RETURN 
                             ;
                             ;
                             ;
                             ; ##############################################################################
                             ; ############# MIDI-Routinen für Scan-Events bei Keyboard-Abfrage #############
                             ; ################## sollte bei allen Scan-Boards gleich sein ##################
                             ; ##############################################################################
                             ;
                             ;
                             ; ###############################################################################
                             ; ########################## Eigene Schleife EVENT-LOOP #########################
                             ; ###############################################################################
                             ;
                             ; Variablen unabhängig von Scan-Routine benutzt
                             ; scan_number: hier Adresse des MPX-RAMs,
                             ; event_key: Adresse der 121-Tasten-RAMs
                             ;
             event_handling: 
                             LOAD s0, 00                             ; Start mit Taste 0
                             STORE s0, s_keycount_upper
                             STORE s0, s_keycount_lower
                             STORE s0, s_keycount_pedal
                             STORE s0, s_pedal_on                    ; Speicher für gedrückte Taste
                             LOAD event_key, c_midi_firstkey         ; Start mit Taste 12
                 event_loop: ; ca. 450 µs Gesamtzeit
                             CALL event_setcontacts
                             ADD event_key, 01                       ; nächste Taste
                             COMPARE event_key, c_midi_lastkey       ; alle Tasten abgefragt?
                             JUMP NZ, event_loop
                             ;
                             LOAD s0, 01
                             OUTPUT s0, TEST_PORT                    ; normal ON
                             FETCH s0, s_pedal_on
                             OUTPUT s0, PEDAL_DOWN                   ; ist '1' wenn irgendeine Pedaltaste gedrückt ist
                             ;
                             ; Pedal-Click, simpel
                             ;
                             COMPARE s0, 00
                             JUMP Z, event_loop_reset_pedalnoise     ; wenn kein Pedal gedrückt
                             ;
                             INPUT s1, SPI_CLICKLEN
                             AND s1, 0F
                             COMPARE s1, 00
                             JUMP Z, event_loop_nopedalclick
                             ADD s1, 04
    event_loop_nopedalclick: 
                             FETCH s0, s_pedal_noisecounter
                             COMPARE s0, s1
                             JUMP Z, event_loop_pedal_noiseoff
                             ADD s0, 01
                             STORE s0, s_pedal_noisecounter
                             INPUT s0, RND_NUMBER
                             AND s0, 01
                             OUTPUT s0, TEST_PORT                    ; normal ON
                             RETURN 
                             ;
event_loop_reset_pedalnoise: 
                             LOAD s0, 00
                             STORE s0, s_pedal_noisecounter
  event_loop_pedal_noiseoff: 
                             LOAD s0, 01
                             OUTPUT s0, TEST_PORT                    ; normal ON
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; +++++++++++ Wird mit allen event_key-Tastennummern aufgerufen ++++++++++++++++
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
          event_setcontacts: 
                             CALL event_rd_mididyn_121               ; 3 Bytes MIDI-Dynamik von event_key lesen
                             CALL event_rd_localdyn_121              ; 3 Bytes Local-Dynamik von event_key lesen
                             ;
                             ; UPPER
                             ;
                             LOAD manual_select, 00                  ; 0 = UPPER
                             LOAD s3_key_status, 00
                             FETCH s0, s_upper_mididyn
                             CALL event_dyn2keystatus                ; Tastenzustand s0 danach mit s3_key_status verodert
                             ; Local Enable-Bit UPPER gesetzt?
                             INPUT s0, SPI_LOCALDISABLES
                             TEST s0, 01
                             JUMP NZ, event_ena_upper                ; Local überspringen, wenn ON
                             ;
                             FETCH s0, s_upper_localdyn
                             CALL event_dyn2keystatus                ; Tastenzustand s0 danach mit s3_key_status verodert
                             ;
            event_ena_upper: 
                             CALL mpx_set_key
                             ;
                             ; LOWER
                             ;
                             LOAD manual_select, 01                  ; 1 = LOWER
                             LOAD s3_key_status, 00
                             FETCH s0, s_lower_mididyn
                             CALL event_dyn2keystatus                ; Tastenzustand s0 danach mit s3_key_status verodert
                             ; Local Enable-Bit LOWER gesetzt?
                             INPUT s0, SPI_LOCALDISABLES
                             TEST s0, 02
                             JUMP NZ, event_ena_lower                ; Local überspringen, wenn ON
                             ;
                             FETCH s0, s_lower_localdyn
                             CALL event_dyn2keystatus                ; Tastenzustand s0 danach mit s3_key_status verodert
                             ;
            event_ena_lower: 
                             CALL mpx_set_key
                             ;
                             ; PEDAL
                             ;
                             LOAD manual_select, 02                  ; 2 = PEDAL
                             LOAD s3_key_status, 00
                             FETCH s0, s_pedal_mididyn
                             CALL event_dyn2keystatus                ; Tastenzustand s0 danach mit s3_key_status verodert
                             ; Local Enable-Bit PEDAL gesetzt?
                             INPUT s0, SPI_LOCALDISABLES
                             TEST s0, 04
                             JUMP NZ, event_ena_pedal                ; Local überspringen, wenn ON
                             ;
                             FETCH s0, s_pedal_localdyn
                             CALL event_dyn2keystatus                ; Tastenzustand s0 danach mit s3_key_status verodert
            event_ena_pedal: 
                             JUMP mpx_set_key
                             ;
                             ;
                             ; Dynamik (in s0) in Tastenzustand übersetzen
                             ; s3_key_status je nach Dynamik verodern mit 1 oder 3
        event_dyn2keystatus: 
                             COMPARE s0, 00
                             RETURN Z                                ; wenn Null, s3_key_status nicht ändern
                             OR s3_key_status, 01                    ; ist mindestens langsam
                             COMPARE s0, c_dyn_threshold             ; Dynamikschwelle
                             RETURN C                                ; war kleiner
                             OR s3_key_status, 03                    ; ist schnell
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
      event_rd_localdyn_121: 
                             ; Local-Tastendynamik
                             ; Taste in event_key, gelesene Dynamik danach in s_xxx_localdyn
                             LOAD s0, event_key
                             LOAD page_select, c_page_localdyn1
                             CALL adjust_page_select
                             OUTPUT s0, RAM_ADDR                     ; Tastennummer in s0
                             OUTPUT page_select, RAM_PAGE            ; MPX-RAM Page
                             LOAD s0, s0                             ; Delay!
                             INPUT s0, RD_PEDAL
                             STORE s0, s_pedal_localdyn
                             INPUT s0, RD_LOWER
                             STORE s0, s_lower_localdyn
                             INPUT s0, RD_UPPER
                             STORE s0, s_upper_localdyn
                             RETURN                                  ; Zustand in s0
                             ;
       event_rd_mididyn_121: 
                             ; MIDI-Tastenzustand
                             ; Taste in event_key, gelesene Daten später in s_xxx_mididyn
                             LOAD s0, event_key
                             LOAD page_select, c_page_midirx1
                             CALL adjust_page_select
                             OUTPUT s0, RAM_ADDR                     ; Tastennummer in s0
                             OUTPUT page_select, RAM_PAGE            ; MPX-RAM Page
                             LOAD s0, s0                             ; Delay!
                             INPUT s0, RD_PEDAL
                             STORE s0, s_pedal_mididyn
                             INPUT s0, RD_LOWER
                             STORE s0, s_lower_mididyn
                             INPUT s0, RD_UPPER
                             STORE s0, s_upper_mididyn
                             RETURN                                  ; Zustand in s0
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; für alle Manuale
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                mpx_set_key: 
                             ; Offsets und Split auswerten, virtuelle Tastenkontakte setzen
                             FETCH scan_number, s_gentranspose
                             ADD scan_number, event_key
                             COMPARE scan_number, c_gen_firstkey     ; Carry bei scan_number - 36?
                             RETURN C                                ; Carry nicht gesetzt >=36
                             COMPARE scan_number, c_gen_lastkey      ; Carry bei scan_number - 97?
                             RETURN NC                               ; Carry nicht gesetzt >=36
                             ; scan_number ist jetzt innerhalb 36..96
                             SUB scan_number, c_midi_offset          ; -36
                             ; scan_number ist jetzt innerhalb Generator-Bereich 0..60
                             COMPARE manual_select, 02               ; Pedal?
                             JUMP Z, mpx_pedal
                             ; Letzten Kontakt-Zustand holen und merken. Wir verwenden diesen Wert
                             ; auch gleich zum Ermitteln der tatsächlich eingeschalteten Tasten.
                             CALL ramread_vcont_61
                             STORE s0, s_old_contacts
                             OR s0, s3_key_status
                             RETURN Z                                ; nur wenn beide schon 0 sind
                             ;
                             COMPARE s0, 00                          ; alter Zustand vom letzen Durchlauf
                             JUMP Z, mpx_onoff
                             ; s_keycount_* bei tatsächlich klingenden Noten erhöhen
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, s_keycount_upper           ; Basisadresse
                             FETCH s0, (idx_ptr)
                             ADD s0, 01
                             STORE s0, (idx_ptr)
                             ; scan_number für Split merken, Taste is ON
                             STORE scan_number, s_lastkey_on
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Zugriff auf die virtuellen Tastenkontakte
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                  mpx_onoff: 
                             ; Sostenuto-Flag setzen, wenn SOSTENUTO aktiv und KEY ON
                             COMPARE s3_key_status, 00
                             JUMP Z, mpx_off                         ; wenn aktueller Zustand OFF
                             FETCH s0, s_old_contacts                ; letzter Zustand
                             COMPARE s0, 15'd
                             RETURN Z                                ; ist bereits ganz an, nichts machen
                             CALL mpx_changed
                             COMPARE s3_key_status, 01
                             JUMP Z, mpx_slow                        ; nur 1. Kontakt, slow inc
                             JUMP mpx_fast                           ; 1. und/oder 2. Kontakt
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                mpx_changed: 
                             ; Tastenkontaktzustand hat sich geändert.
                             ; Flag setzen, wenn Sostenuto-Pedal NICHT aktiv ist und Taste gedrückt wird.
                             ; Die dann gedrückten Tasten werden beim Ausschalten übersprungen, d.h. bleiben an
                             LOAD idx_ptr, manual_select             ; Sostenuto-Pedal für dieses Manual?
                             ADD idx_ptr, s_sosten_upr
                             FETCH s0, (idx_ptr)
                             XOR s0, FF                              ; invertieren
                             AND s0, s3_key_status
                             ; s0 ist EIN, wenn Taste EIN und Sostenuto AUS
                             CALL ramwrite_sostenutoflag_61
                             RETURN 
                    mpx_off: 
                             ; Taste ist erstmals aus.
                             LOAD idx_ptr, manual_select             ; Sostenuto-Pedal für dieses Manual?
                             ADD idx_ptr, s_sosten_upr
                             FETCH s0, (idx_ptr)
                             COMPARE s0, 00
                             JUMP Z, mpx_off_0                       ; Sostenuto ist aus
                             CALL ramread_sostenutoflag_61
                             COMPARE s0, 00
                             ; die bei Sostenuto NICHT gedrückten Tasten beim Ausschalten überspringen
                             RETURN NZ
                  mpx_off_0: 
                             LOAD idx_ptr, manual_select             ; Sustain-Pedal für dieses Manual?
                             ADD idx_ptr, s_sustain_upr
                             FETCH s0, (idx_ptr)
                             COMPARE s0, 00
                             RETURN NZ                               ; nicht abschalten, Sustain ist aktiv
                             CALL reset_noisetimer
                             FETCH s0, s_old_contacts
                             AND s0, 15'd                            ; Noise wegmaskieren
                             LOAD s1, s0                             ; Noise lassen
                             INPUT s2, SPI_CLICKLEN
                             AND s2, 0F
                             COMPARE s2, 05                          ; A < B -> C set, A >= B -> C cleared
                             CALL C, mpx_clear_s1                    ; ist kleiner als 8
                             SL0 s0                                  ; Zustand halbieren, halber Pegel
                             JUMP mpx_set_contacts
               mpx_clear_s1: 
                             LOAD s1, 00                             ; KeyOff-Noise löschen wenn ClickLen < 8
                             RETURN 
                             ;
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Differenzierter Key Click
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                   mpx_fast: 
                             ; Taste ist nicht offen
                             ; zweiter Kontakt geschlossen, voll gedrückt, fast inc to max.
                             CALL start_noisetimer_fastkey           ; starten, falls noch in Ruhe
                             FETCH s0, s_noisetimerval
                             COMPARE s0, FF                          ; Timer-Wert noch in s0
                             JUMP Z, mpx_fullon                      ; Klick beendet?
                             COMPARE s0, FD                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_halfon                     ; 2 ms vor Ende halber Steady-Pegel, JUMP wenn Timer-Wert in s0 > $FD
                             COMPARE s0, FB                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_fullnoise                  ; 4 ms vor Ende voller Noise-Pegel, JUMP wenn Timer-Wert in s0 > $FB
                             JUMP mpx_halfnoise
                   mpx_slow: 
                             ; Taste ist nicht offen
                             ; nur erster Kontakt geschlossen
                             CALL start_noisetimer_slowkey           ; ggf starten; aktueller Timer-Wert in s_noisetimerval
                             FETCH s0, s_noisetimerval
                             COMPARE s0, FF                          ; Timer-Wert noch in s0
                             JUMP Z, mpx_fullon                      ; Klick beendet?
                             COMPARE s0, FE                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_halfon                     ; 1 ms vor Ende halber Steady-Pegel, JUMP wenn Timer-Wert in s0 > $FE
                             COMPARE s0, FC                          ; Timer-Wert noch in s0
                             JUMP NC, mpx_fullnoise                  ; 2 ms vor Ende voller Noise-Pegel, JUMP wenn Timer-Wert in s0 > $FC
              mpx_halfnoise: 
                             LOAD s0, 00                             ; half level
                             LOAD s1, 07
                             JUMP mpx_set_contacts
              mpx_fullnoise: 
                             LOAD s0, 08                             ; full level
                             LOAD s1, 07                             ; all noise
                             JUMP mpx_set_contacts
                 mpx_halfon: 
                             LOAD s0, 07
                             LOAD s1, 00
                             JUMP mpx_set_contacts
                 mpx_fullon: 
                             LOAD s0, 0F                             ; full
                             LOAD s1, 00                             ; no noise
                             ; jump mpx_set_contacts
           mpx_set_contacts: 
                             ; Steady- (s0) und Noise-Anteil (s1) INPUT mpx-RAM schreiben
                             ; Tastennnummer in scan_number
                             ; Im Steady-Nibble s0: 0..7 Half Level, 8..15 Full Level (Bit 3)
                             ; INPUT ein Byte packen und zum MPX-RAM schicken
                             ; INPUT manual_select ist aktuell abgefragtes Manual
                             SL0 s1
                             SL0 s1
                             SL0 s1
                             SL0 s1
                             AND s0, 15'd
                             OR s0, s1
                             JUMP ramwrite_vcont_61
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                  mpx_pedal: 
                             ; kleine Sonderbehandlung für Pedal, hat keine Dynamik und keine Noise-Bits:
                             ; s3_key_status enthält 0 (Taste aus) oder anderen Wert (Taste an),
                             ; Falls sich neue Taste geändert hat, alte Taste löschen
                             ; Vorher gespielte Pedaltaste löschen, Nummer der neue Pedaltaste merken
                             ; manual_select enthält 2
                             COMPARE s3_key_status, 00
                             JUMP Z, mpx_pedal_0                     ; Taste ist aus wenn 0
                             LOAD s3_key_status, 01                  ; nur zwei Zustände zulassen, hier ON
                             FETCH s0, s_pedal_on                    ; Speicher für gedrückte Taste
                             OR s0, s3_key_status
                             STORE s0, s_pedal_on                    ; kann innerhalb Pedalschleife '1' werden
                mpx_pedal_0: 
                             ; get_state/set_state hier nicht benötigt, weil kein Noise berücksichtigt wird
                             LOAD s0, s3_key_status
                             JUMP ramwrite_vcont_61                  ; Taste in scan_number, Zustand in s0
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Werte INPUT MPX/Scratch-RAM setzen mit aktuellem manual_select und scan_number
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
         adjust_page_select: 
                             COMPARE s0, 40                          ; ist auf zwei Seiten aufgeteilt
                             RETURN C                                ; wenn kleiner 63, nicht addieren
                             SUB s0, 40
                             ADD page_select, 01
                             RETURN 
                             ;
   ramread_sostenutoflag_61: 
                             ; Sostenuto-Flag
                             ; Taste in scan_number, gelesene Daten später in s0
                             LOAD page_select, c_page_sostenutoflags
                             JUMP ramread_61
        ramread_midisent_61: 
                             ; MIDI-gesendet-Flag
                             ; Taste in scan_number, gelesene Daten später in s0
                             LOAD page_select, c_page_midisentflags
                             JUMP ramread_61
           ramread_vcont_61: ; Virtuelle Tastenkontakte
                             ; Taste in scan_number, gelesene Daten später in s0
                             LOAD page_select, c_page_vcontacts
                 ramread_61: 
                             ; Taste in scan_number, gelesene Daten später in s0
                             LOAD s0, scan_number
                 ramread_s0: 
                             ; Tasten-Adresse INPUT s0
                             OUTPUT s0, RAM_ADDR                     ; Tastennummer in s0
                             OUTPUT page_select, RAM_PAGE            ; MPX-RAM Page
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_read_mask
                             INPUT s0, (idx_ptr)                     ; Upper, Lower oder Pedal Read
                             RETURN                                  ; Zustand in s0
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                ramwrite_s0: 
                             ; Tasten-Adresse INPUT s0
                             OUTPUT s0, RAM_ADDR
                             OUTPUT page_select, RAM_PAGE            ; MPX-RAM Page
                             LOAD idx_ptr, manual_select             ; 0 oder 1
                             ADD idx_ptr, c_strobe_mask
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             RETURN 
                             ;
                             ;
      ramwrite_localdyn_121: 
                             ; Scanned-RAM Dynamik
                             ; Taste in s_midi_localkey, s_midi_localdyn und manual_select
                             LOAD page_select, c_page_localdyn1
                             FETCH s0, s_midi_localdyn               ; Dynamik dieser Taste
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Dynamik in s0
                             FETCH s0, s_midi_localkey               ; Local-Key in s0, geht von 12 bis 121
                             CALL adjust_page_select
                             JUMP ramwrite_s0
                             ;
          ramwrite_midi_121: 
                             ; Empfangsdaten, MIDI-Taste/Dynamik s_midi_data1, s_midi_data2 und manual_select ins RAM, 12..121
                             LOAD page_select, c_page_midirx1
                             FETCH s0, s_midi_data2                  ; Dynamik dieser Taste
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Dynamik in s0
                             FETCH s0, s_midi_data1                  ; MIDI-Key in s0, geht von 12 bis 121
                             CALL adjust_page_select
                             JUMP ramwrite_s0
                             ;
      ramwrite_midi_sent_61: 
                             ; zu schreibende Daten in s0, Taste in scan_number
                             LOAD page_select, c_page_midisentflags
                             JUMP ramwrite_61
  ramwrite_sostenutoflag_61: 
                             ; zu schreibende Daten in s0
                             LOAD page_select, c_page_sostenutoflags
                             JUMP ramwrite_61
          ramwrite_vcont_61: 
                             ; zu schreibende Daten in s0
                             LOAD page_select, c_page_vcontacts
                ramwrite_61: 
                             ; zu schreibende Daten in s0, page_select muss gesetzt sein, 0..61
                             OUTPUT s0, RAM_WRDATA
                             LOAD s0, scan_number
                             JUMP ramwrite_s0
                             ;
                             ; ##############################################################################
                             ; Hilfsroutinen: Werte in Timer/Scratch-RAM lesen oder schreiben
                             ; manual_select = 0 für Upper, manual_select = 1 für Lower Manual
                             ; ##############################################################################
                             ;
   start_noisetimer_fastkey: 
                             ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                             CALL get_noisetimer
                             STORE s0, s_noisetimerval
                             COMPARE s0, 00
                             RETURN NZ                               ; wenn bereits gestartet
                             ;
                             INPUT s1, RND_NUMBER                    ; zufällige Länge
                             AND s1, 03                              ; 0 bis 3
                             FETCH s0, s_clicklen                    ; Timer-Startwert,  237..252
                             SUB s0, s1                              ; um Zufallswert verlängern
                             JUMP set_noisetimer
                             ;
   start_noisetimer_slowkey: 
                             ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                             CALL get_noisetimer
                             STORE s0, s_noisetimerval
                             COMPARE s0, 00
                             RETURN NZ                               ; wenn bereits gestartet
                             ;
                             INPUT s1, RND_NUMBER                    ; zufällige Länge
                             AND s1, 01                              ; 0 oder 1
                             FETCH s0, s_clicklen                    ; Timer-Startwert,  237..255
                             SR1 s0                                  ; Timer-Startwert verdoppelt,  246..255
                             SUB s0, s1                              ; um kleinen Zufallswert verlängern
             set_noisetimer: 
                             LOAD page_select, c_page_noisetimer
                             JUMP ramwrite_61
           reset_noisetimer: 
                             LOAD s0, 00
                             JUMP set_noisetimer
             get_noisetimer: 
                             LOAD page_select, c_page_noisetimer
                             JUMP ramread_61
                             ; ##############################################################################
                             ; Dynamik- und Noise-Timer für beide Manuale aktualisieren
                             ; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014
                             ; wird einmal pro Scan-Durchlauf aufgerufen, dauert ca. 52 µs
                             ; ##############################################################################
              update_timers: 
                             ;LOAD page_select, c_page_dyntimer
                             ;OUTPUT page_select, RAM_PAGE            ; MPX-RAM Page Dynamik-Timer
                             ;LOAD scan_number, 00
                             ;CALL update_timer_loop
                             LOAD page_select, c_page_noisetimer
                             OUTPUT page_select, RAM_PAGE            ; MPX-RAM Page Noise-Timer
                             LOAD scan_number, 00
          update_timer_loop: 
                             OUTPUT scan_number, RAM_ADDR
                             ADD scan_number, 01
                             INPUT s0, RD_UPPER
                             COMPARE s0, 00
                             JUMP Z, update_timer_done1              ; noch nicht gestartet
                             COMPARE s0, FF
                             JUMP Z, update_timer_done1              ; bereits abgelaufen
                             ADD s0, 01
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Daten in s0
                             LOAD s0, 00                             ; NOP
                             OUTPUT s0, UPPER_STROBE
                             LOAD s0, 00                             ; NOP
         update_timer_done1: 
                             INPUT s0, RD_LOWER
                             COMPARE s0, 00
                             JUMP Z, update_timer_done2              ; noch nicht gestartet
                             COMPARE s0, FF
                             JUMP Z, update_timer_done2              ; bereits abgelaufen
                             ADD s0, 01
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Daten in s0
                             LOAD s0, 00                             ; NOP
                             OUTPUT s0, LOWER_STROBE
         update_timer_done2: 
                             COMPARE scan_number, 64'd
                             JUMP NZ, update_timer_loop
                             RETURN 
                allnotesoff: 
                             ; alle Töne, Flags und Timer löschen
                             LOAD s0, 00
                             OUTPUT s0, RAM_WRDATA                   ; Enables und Werte auf 0
                             OUTPUT s0, PEDAL_DOWN
                             LOAD scan_number, 00
                             LOAD page_select, 00
           allnotesoff_loop: 
                             OUTPUT scan_number, RAM_ADDR
                             OUTPUT page_select, RAM_PAGE
                             OUTPUT s0, UPPER_STROBE
                             OUTPUT s0, LOWER_STROBE
                             OUTPUT s0, PEDAL_STROBE
                             ADD scan_number, 01
                             COMPARE scan_number, 64'd               ; 64 Durchläufe?
                             JUMP NZ, allnotesoff_loop
                             LOAD scan_number, 00
                             ADD page_select, 01
                             COMPARE page_select, 16'd               ; 16 Durchläufe?
                             JUMP NZ, allnotesoff_loop
                             RETURN                                  ; fertig
                             ;
             start_dyntimer: 
                             ; Dynamik-Timer der aktuellen Taste starten, wenn nicht bereits geschehen
                             LOAD page_select, c_page_dyntimer
                             CALL ramread_61
                             COMPARE s0, 00
                             RETURN NZ                               ; wenn bereits gestartet
                             LOAD s0, 01                             ; Timer starten, zählt aufwärts
                             JUMP ramwrite_61
             reset_dyntimer: 
                             LOAD s0, 00                             ; Timer stoppen
                             LOAD page_select, c_page_dyntimer
                             JUMP ramwrite_61
               get_dyntimer: 
                             LOAD page_select, c_page_dyntimer
                             JUMP ramread_61
                             ;
                             ;
                             ; ##############################################################################
                             ; ################## M I D I   R E C E I V E   DISPATCHER ######################
                             ; ##############################################################################
                             ;
                             ;
                             ; MIDI-Subroutinen für MIDI-Empfang
                             ; Dispatcher stellt fest, ob und was es zu tun gibt
                             ; wird regelmäßig aus Hauptschleife aufgerufen
                             ;
              midi_dispatch: 
       midi_dispatch_loop_1: 
                             INPUT s0, MIDI_IN1_STATUS
                             COMPARE s0, 00                          ; Daten empfangen?
                             JUMP Z, midi_dispatch_loop_2            ; wenn nein, weiter mit MIDI In 2 (SAM/USB)
                             CALL midi_1_receive                     ; Buffer lesen/leeren, Realtime filtern, Flags setzen
                             COMPARE midi_1_rxflag, 00
                             CALL NZ, midi_dispatch_1                ; interpretieren, falls komplett
                             JUMP midi_dispatch_loop_1
                             ;
       midi_dispatch_loop_2: 
                             INPUT s0, MIDI_IN2_STATUS
                             COMPARE s0, 00                          ; Daten empfangen?
                             JUMP Z, midi_dispatch_loop_3            ; wenn nein, weiter mit MIDI In 3 (AVR)
                             CALL midi_2_receive                     ; Buffer leeren
                             COMPARE midi_2_rxflag, 00
                             CALL NZ, midi_dispatch_2                ; interpretieren, falls komplett
                             JUMP midi_dispatch_loop_2
                             ;
       midi_dispatch_loop_3: 
                             INPUT s0, MIDI_AVR_STATUS
                             AND s0, 0E                              ; Daten empfangen?
                             RETURN Z                                ; wenn nein, zurück zur Main Loop
                             CALL midi_3_receive                     ; Buffer lesen/leeren, Flags setzen
                             COMPARE midi_3_rxflag, 00
                             CALL NZ, midi_dispatch_3                ; interpretieren, falls komplett
                             JUMP midi_dispatch_loop_3
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Daten auswerten, hier kein SysEx mehr
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
            midi_dispatch_1: 
                             ; Daten vom erstem MIDI-Eingang interpretieren, falls vollständig
                             LOAD midi_1_rxflag, 00                  ; Rx-Flag löschen
                             FETCH s0, s_midi_1_cmd                  ; von IRQ gesetzte Bytes
                             STORE s0, s_midi_cmd
                             FETCH s0, s_midi_1_data1
                             STORE s0, s_midi_data1
                             FETCH s0, s_midi_1_data2
                             STORE s0, s_midi_data2
                             FETCH s0, s_midi_1_len
                             STORE s0, s_midi_len
                             JUMP midi_dispatch_all                  ; Ende und RETURN
                             ;
            midi_dispatch_2: 
                             ; Daten vom zweiten MIDI-Eingang interpretieren, falls vollständig
                             LOAD midi_2_rxflag, 00                  ; Rx-Flag löschen
                             FETCH s0, s_midi_2_cmd                  ; von IRQ gesetzte Bytes
                             STORE s0, s_midi_cmd
                             FETCH s0, s_midi_2_data1
                             STORE s0, s_midi_data1
                             FETCH s0, s_midi_2_data2
                             STORE s0, s_midi_data2
                             FETCH s0, s_midi_2_len
                             STORE s0, s_midi_len
                             JUMP midi_dispatch_all                  ; Ende und RETURN
                             ;
            midi_dispatch_3: 
                             ; bei AVR  Controller Change nur auf ALL NOTES OFF prüfen, sonst senden
                             LOAD midi_3_rxflag, 00                  ; Rx-Flag löschen
                             FETCH s0, s_midi_3_cmd
                             AND s0, F0
                             COMPARE s0, B0                          ; Control Change?
                             JUMP NZ, midi_dispatch_3_send
                             FETCH s0, s_midi_3_cmd
                             AND s0, 0F                              ; Kanal isolieren
                             STORE s0, s_midi_chan_masked            ; für allnotesoff_manual
                             FETCH s0, s_midi_3_data1
                             COMPARE s0, 123'd                       ; All Notes OFF?
                             JUMP Z, allnotesoff_manual
       midi_dispatch_3_send: 
                             ; empfangenen Datensatz 1 bis 3 Bytes vom AVR an SAM und DIN-Buchse senden
                             FETCH s0, s_midi_3_cmd
                             CALL midi_tx_both
                             FETCH s0, s_midi_3_len
                             COMPARE s0, 00
                             RETURN Z
                             ;
                             FETCH s0, s_midi_3_data1
                             CALL midi_tx_both
                             FETCH s0, s_midi_3_len
                             COMPARE s0, 01
                             RETURN Z
                             ;
                             FETCH s0, s_midi_3_data2
                             JUMP midi_tx_both
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
          midi_dispatch_all: 
                             ; MIDI-Datensatz vollständig, dekodieren und ggf. RAM beschreiben
                             CALL midi_out2_waitbuf                  ; SAM5504-Buffer aufnahmebereit?
                             FETCH s1, s_midi_len
                             FETCH s0, s_midi_cmd
                             OUTPUT s0, MIDI_TX_2                    ; immer alles an SAM5504 senden
                             COMPARE s1, 00
                             JUMP Z, midi_dispatch_all_0
                             FETCH s0, s_midi_data1
                             OUTPUT s0, MIDI_TX_2
                             COMPARE s1, 01
                             JUMP Z, midi_dispatch_all_0
                             FETCH s0, s_midi_data2
                             OUTPUT s0, MIDI_TX_2
        midi_dispatch_all_0: 
                             FETCH s0, s_midi_cmd
                             AND s0, 0F                              ; Kanal isolieren
                             STORE s0, s_midi_chan_masked
                             FETCH s0, s_midi_cmd
                             AND s0, F0                              ; Befehl isolieren
                             STORE s0, s_midi_cmd_masked
                             ;
                             LOAD manual_select, 00                  ; Default upper
                             FETCH s1, s_midi_chan_masked
                             FETCH s0, s_midich                      ; eingestellter Kanal, Piano-Maske
                             COMPARE s1, s0                          ; eingestellter gleich empfangener Kanal?
                             JUMP Z, midi_disp_note                  ; mit manual_select = 0, upper
                             ;
                             ADD s0, 01
                             LOAD manual_select, 01
                             COMPARE s1, s0                          ; eingestellter Kanal +1?
                             JUMP Z, midi_disp_note
                             ;
                             ADD s0, 01
                             LOAD manual_select, 02                  ; mit manual_select = 2, Pedal
                             COMPARE s1, s0                          ; eingestellter Kanal +2?
                             JUMP Z, midi_disp_note_pedal
                             ;
                             ; Sonderkanal +3 für Touchpad-CC, nur an AVR
                             ADD s0, 01
                             COMPARE s1, s0                          ; eingestellter Kanal +3?
                             JUMP Z, midi_to_avr
                             RETURN 
                             ;
                             ; Pedal-Sonderbehandlung, weil nur ein Bit statt ein Byte abgespeichert wird
                             ;
       midi_disp_note_pedal: 
                             FETCH s0, s_midi_cmd_masked
                             COMPARE s0, 80
                             JUMP Z, midi_disp_note_off              ; 0 speichern
                             COMPARE s0, 90
                             JUMP NZ, midi_dispatch_rest             ; wenn kein ON/OFF
                             ;
                             FETCH s0, s_midi_data2
                             COMPARE s0, 00
                             JUMP Z, midi_disp_note_off              ; war $90 mit Dynamik 0
                             ;
                             LOAD s0, 01
                             STORE s0, s_midi_data2
                             JUMP midi_disp_checksplit_exit
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Dieses Split-Handling nur bei MIDI-Scan-Driver!
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             ; Hier kommen alle Manuale und Pedal an
                             ;
             midi_disp_note: 
                             ; MIDI-NoteOn/NoteOff-Befehle? Dynamik bereits in s2, Manual in manual_select
                             FETCH s0, s_midi_cmd_masked
                             COMPARE s0, 90
                             JUMP Z, midi_disp_checksplit
                             COMPARE s0, 80
                             JUMP NZ, midi_dispatch_rest             ; wenn kein ON/OFF
                             ; ist ein ON/OFF-Befehl
         midi_disp_note_off: 
                             LOAD s0, 00                             ; MIDI-Befehl Taste OFF, Dynamik 0
                             STORE s0, s_midi_data2                  ; Dynamik dieser Taste 0
       midi_disp_checksplit: 
                             ; Note-On-Dynamik in s_midi_data2
                             FETCH s0, s_split_on
                             COMPARE s0, 00
                             JUMP Z, midi_disp_checksplit_exit
                             ;
                             ; MIDI-Note in scan_number wg. schnellerem Zugriff, temporär benutzt
                             FETCH scan_number, s_midi_data1
                             FETCH s8_msb_smode, s_splitmode
                             FETCH s7_lsb_spoint, s_splitpoint       ; Splitmode in Register wg. schnellerem Zugriff
                             ADD s7_lsb_spoint, c_gen_firstkey       ; um Tastatur-Anfang verschobener Splitpunkt in s2
                             ;
                             COMPARE manual_select, 01               ; betriff Lower?
                             JUMP Z, midi_disp_check_lower           ; wenn MIDI auf 1 = Lower
                             COMPARE manual_select, 02               ; betriff Pedal?
                             JUMP Z, midi_disp_checksplit_exit       ; wenn MIDI auf 2 = Pedal, nie gesplittet
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
      midi_disp_check_upper: 
                             COMPARE s8_msb_smode, 01                ; Splitmode 1 = Lower to Upper?
                             JUMP Z, midi_disp_check_upper_1
                             COMPARE s8_msb_smode, 02                ; Splitmode 2 = Pedal to Upper?
                             JUMP Z, midi_disp_check_upper_2
                             COMPARE s8_msb_smode, 03                ; Splitmode 3 = Lower to Upper +1 Oktave?
                             JUMP Z, midi_disp_check_upper_3
                             COMPARE s8_msb_smode, 04                ; Splitmode 4 = Lower to Upper +2 Oktaven
                             JUMP Z, midi_disp_check_upper_4
                             JUMP midi_disp_checksplit_exit          ; wenn 0, kein Split für Upper
                             ;
    midi_disp_check_upper_1: 
                             ; wenn unterhalb Splitpunkt, auf LOWER schreiben
                             COMPARE scan_number, s7_lsb_spoint
                             JUMP NC, midi_disp_checksplit_exit      ; JUMP wenn scan_number > splitpoint
                             ; unterhalb Splitpunkt ausgeführt:
                             JUMP midi_disp_remap_to_lower
                             ;
    midi_disp_check_upper_2: 
                             ; wenn unterhalb Splitpunkt, auf PEDAL schreiben
                             COMPARE scan_number, s7_lsb_spoint
                             JUMP NC, midi_disp_checksplit_exit      ; JUMP wenn scan_number > splitpoint
                             ; unterhalb Splitpunkt ausgeführt:
                             JUMP midi_disp_remap_to_pedal           ; und RETURN
                             ;
    midi_disp_check_upper_3: 
                             ; wenn unterhalb Splitpunkt, auf LOWER schreiben, 1 Oktave darüber
                             COMPARE scan_number, s7_lsb_spoint
                             JUMP NC, midi_disp_checksplit_exit      ; JUMP wenn scan_number > splitpoint
                             ; unterhalb Splitpunkt ausgeführt:
                             ADD scan_number, 12'd                   ; 1 Oktave addieren
                             JUMP midi_disp_remap_to_lower           ; PEDAL abfragen und RETURN
                             ;
    midi_disp_check_upper_4: 
                             ; hier nur noch 4 = Lower to Upper +2 Oktaven
                             ; wenn unterhalb Splitpunkt, auf LOWER schreiben, 2 Oktaven darüber
                             COMPARE scan_number, s7_lsb_spoint
                             JUMP NC, midi_disp_checksplit_exit      ; JUMP wenn scan_number > splitpoint
                             ; unterhalb Splitpunkt ausgeführt:
                             ADD scan_number, 24'd                   ; 1 Oktave addieren
                             JUMP midi_disp_remap_to_lower           ; PEDAL abfragen und RETURN
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
      midi_disp_check_lower: 
                             COMPARE s8_msb_smode, 00                ; Splitmode 0 = Pedal to Lower?
                             JUMP Z, midi_disp_check_lower_0
                             COMPARE s8_msb_smode, 05                ; Splitmode 0 = Pedal to Lower?
                             JUMP Z, midi_disp_check_lower_5
                             JUMP midi_disp_checksplit_exit          ; JUMP wenn nicht
    midi_disp_check_lower_0: 
                             ; nur 0 = Pedal to Lower behandeln
                             COMPARE scan_number, s7_lsb_spoint
                             JUMP NC, midi_disp_checksplit_exit      ; JUMP wenn scan_number > splitpoint
                             ; unterhalb Splitpunkt ausgeführt:
                             JUMP midi_disp_remap_to_pedal           ; und RETURN
    midi_disp_check_lower_5: 
                             ; nur 5 = Add Pedal to Lower behandeln
                             COMPARE scan_number, s7_lsb_spoint
                             JUMP NC, midi_disp_checksplit_exit      ; JUMP wenn scan_number > splitpoint
                             ; unterhalb Splitpunkt ausgeführt:
                             CALL midi_disp_remap_to_lower
                             JUMP midi_disp_remap_to_pedal           ; und RETURN
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
   midi_disp_remap_to_pedal: 
                             LOAD manual_select, 02
                             FETCH s0, s_midi_data2
                             COMPARE s0, 00
                             JUMP Z, midi_disp_checksplit_exit       ; war $90 mit Dynamik 0
                             ;
                             LOAD s0, 01
                             STORE s0, s_midi_data2
                             JUMP midi_disp_checksplit_exit
                             ;
   midi_disp_remap_to_lower: 
                             STORE scan_number, s_midi_data1
                             LOAD manual_select, 01
                             ;
  midi_disp_checksplit_exit: 
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ; Ende Split-Handling bei MIDI-Scan-Driver!
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
                             ; jetzt Notenwert und Dynamik abspeichern
                             ; Dynamik ist 0 bei Key-Off-Befehl
                             CALL midi_adjust_foldbacks              ; Sollte abschaltbar sein!
                             JUMP ramwrite_midi_121
                             ;
                             ; MIDI-Tasten außerhalb des 5-Oktaven-Umfangs oktavweise verschieben
                             ;
      midi_adjust_foldbacks: 
                             FETCH s0, s_midi_data1
    midi_adjust_foldbacks_1: 
                             COMPARE s0, c_gen_firstkey              ; Carry bei scan_number - 36?
                             JUMP NC, midi_adjust_foldbacks_2        ; Carry nicht gesetzt >=36
                             ADD s0, 12'd
                             JUMP midi_adjust_foldbacks_1
                             ;
    midi_adjust_foldbacks_2: 
                             STORE s0, s_midi_data1
                             COMPARE s0, c_gen_lastkey               ; Carry bei scan_number - 97?
                             RETURN C
                             SUB s0, 12'd
                             JUMP midi_adjust_foldbacks_2
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
         midi_dispatch_rest: 
                             ; Program Change und Controller? Dann an AVR
                             COMPARE s0, C0
                             JUMP Z, midi_to_avr
                             COMPARE s0, E0
                             JUMP Z, midi_to_avr
                             COMPARE s0, B0
                             RETURN NZ                               ; alles andere unberücksichtigt
               midi_cchange: 
                             ; bei Controller Change auf ALL NOTES OFF prüfen, dann weiter wie Program Change
                             FETCH s0, s_midi_data1
                             COMPARE s0, 123'd                       ; All Notes OFF?
                             JUMP Z, allnotesoff_manual              ; falls nicht, weiter mit AVR-IRQ
                             ;
                midi_to_avr: 
                             ; AVR-IRQ auslösen; MIDI-Daten an SPI
                             FETCH s0, s_midi_cmd
                             OUTPUT s0, MIDI_CMD
                             FETCH s1, s_midi_data1                  ; s1 wird gleich weiterbenutzt
                             OUTPUT s1, MIDI_DB1
                             FETCH s0, s_midi_data2
                             OUTPUT s0, MIDI_DB2
                             CALL midi_strobe_avr                    ; an AVR senden, benutzt s0
                             ;
                             FETCH s0, s_midi_cmd_masked
                             COMPARE s0, B0                          ; Control Change empfangen?
                             RETURN NZ
                             ; ab hier nur noch Control Change Bx, auf allen benutzten Kanälen
                             ;
                             INPUT s0, SPI_MIDIOPT                   ; Bit 7 (MSB): USE SOST/SUSTAIN freigeschaltet?
                             AND s0, 80
                             RETURN Z                                ; wenn 0, dann nicht behandeln, abgeschaltet
                             ;
               midi_sustain: 
                             ; manual_select enthält empfangenes Ziel (0, 1 oder 2)
                             COMPARE s1, 40
                             JUMP NZ, midi_sustain_sostenuto
                             ;
                             LOAD idx_ptr, s_sustain_upr
                             JUMP midi_sustain_1                     ; evt. von SAM5504-HW-Input, muss auch gesendet werden
                             ;
     midi_sustain_sostenuto: 
                             COMPARE s1, 42
                             RETURN NZ
                             LOAD idx_ptr, s_sosten_upr
             midi_sustain_1: 
                             ADD idx_ptr, manual_select
                             FETCH s2, s_midi_data2
                             STORE s2, (idx_ptr)
                             ; OUTPUT s0, AUXPORT                    ; ### TEST - nur in MIDI-Scantreiber benutzen! ###
                             ;
                             ; Sustain und Sostenuto weitersenden, könnte vom DSP (Eingangs-Pins über Jumper) stammen
                             CALL midi_out_waitbuf                   ; benutzt s1!
                             FETCH s0, s_midi_cmd
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             FETCH s0, s_midi_data1
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             FETCH s0, s_midi_data2
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
         allnotesoff_manual: 
                             LOAD s0, 00
                             STORE s0, s_sustain_upr
                             STORE s0, s_sustain_lwr
                             STORE s0, s_sosten_upr
                             STORE s0, s_sosten_lwr
                             ; alle Tasten löschen
                             FETCH idx_ptr, s_midi_chan_masked
                             FETCH s1, s_midich                      ; eingestellter Kanal
                             SUB idx_ptr, s1                         ; Manual in idx_ptr
                             ADD idx_ptr, c_strobe_mask              ; 0 bis 2 plus Offset
                             OUTPUT s0, RAM_WRDATA                   ; zu schreibende Dynamik INPUT s0
                             LOAD s0, c_page_midirx1
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             LOAD s1, 00                             ; Schleifenzähler
                             ; keine set_ram-Routine, da page_select, scan_number etc. nicht gültig!
   allnotesoff_manual_loop1: 
                             OUTPUT s1, RAM_ADDR                     ; Tastennummer INPUT s1
                             LOAD s0, c_page_midirx1
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             LOAD s0, c_page_midirx2
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             LOAD s0, c_page_keystatus1
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             LOAD s0, c_page_keystatus2
                             OUTPUT s0, RAM_PAGE                     ; MPX-RAM Page
                             OUTPUT s0, (idx_ptr)                    ; Upper, Lower oder Pedal Strobe
                             ADD s1, 01
                             COMPARE s1, 64'd
                             JUMP NZ, allnotesoff_manual_loop1
                             RETURN 
                             ;
           midi_out_waitbuf: ; MIDI MAIN OUT
                             INPUT s1, TX_STATUS                     ; half full?
                             COMPARE s1, 00                          ; nur 0, wenn beide TX1 und TX2 weniger als halbvoll
                             JUMP NZ, midi_out_waitbuf               ; auf Buffer-Leerung warten
                             RETURN 
                             ;
          midi_out2_waitbuf: ; SAM5504-Buffer aufnahmebereit? zweiter interner MIDI-Ausgang
                             INPUT s1, TX_STATUS                     ; half full?
                             AND s1, 02
                             COMPARE s1, 02
                             JUMP Z, midi_out2_waitbuf               ; auf Buffer-Leerung warten
                             RETURN 
                             ;
                             ; ##############################################################################
                             ; ###################### M I D I   I N P U T  1 (DIN1) #########################
                             ; ##############################################################################
                             ;
                             ; MIDI Daten wurden von Input 1 empfangen
                             ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                             ;
             midi_1_receive: 
                             INPUT s0, MIDI_IN1
                             COMPARE s0, F0                          ; RealTime ab $F0?
                             JUMP C, midi_1_channel_message          ; wenn kleiner als F0, mit Channel Messages weiter
                             COMPARE s0, F8                          ; RealTime ab $F8?
                             RETURN NC                               ; Realtime ab #F8 ohne Daten, verwerfen
                             COMPARE s0, F0                          ; Start of SysEX, Flag setzen
                             JUMP Z, midi_1_start_sysex_to_avr
                             COMPARE s0, F7                          ; End of SysEX, Flag löschen
                             JUMP Z, midi_1_stop_sysex_to_avr
                             ; ab hier nur noch Werte zwischen F1 und F6 übrig:
                             ; F1 Timecode Quarter Frame, F2 Song Position Pointer, F3 Select Song
                             LOAD s1, FF
                             STORE s1, s_midi_1_ignoreflag           ; Flag setzen: folgende Daten ignorieren
                             RETURN 
                             ;
     midi_1_channel_message: 
                             TEST s0, 80
                             JUMP Z, midi_1_is_databyte
                             ; ist ab hier eine Channel Message
                             STORE s0, s_midi_1_cmd
                             LOAD s1, 00                             ; ist ein neuer (Running) Status
                             STORE s1, s_midi_1_counter
                             STORE s1, s_midi_1_ignoreflag           ; Flag löschen: bald folgende Daten wieder relevant
                             COMPARE midi_1_SysExFlag, 00
                             JUMP NZ, midi_1_stop_sysex_to_avr       ; Sysex durch Channel-Command beendet
                             RETURN 
                             ;
         midi_1_is_databyte: 
                             COMPARE midi_1_SysExFlag, 00            ; Läuft SysEx-Übertragung?
                             JUMP NZ, midi_1_sysex_to_avr_s0         ; dann Daten zum AVR senden
                             ;
                             FETCH s1, s_midi_1_ignoreflag           ; Daten von Sytem Common F1, F2, F3?
                             COMPARE s1, 00
                             RETURN NZ                               ; Datenbytes ignorieren wenn ja
                             ;
                             FETCH s1, s_midi_1_counter
                             ADD s1, 01
                             STORE s1, s_midi_1_counter
                             COMPARE s1, 02
                             JUMP Z, midi_1_is_second_databyte
                             ;
                             ; erstes Datenbyte empfangen:
                             ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                             ; Datensatz ist mit einem Datenbyte vollständig!
                             FETCH s1, s_midi_1_cmd
                             AND s1, F0                              ; Kanal ausmaskieren
                             COMPARE s1, C0                          ; program change
                             JUMP Z, midi_1_is_singledatabyte
                             COMPARE s1, D0                          ; channel pressure
                             JUMP Z, midi_1_is_singledatabyte
   midi_1_is_first_databyte: 
                             STORE s0, s_midi_1_data1
                             RETURN 
                             ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
   midi_1_is_singledatabyte: 
                             STORE s0, s_midi_1_data1
  midi_1_is_second_databyte: 
                             STORE s0, s_midi_1_data2
                             FETCH s1, s_midi_1_counter
                             STORE s1, s_midi_1_len                  ; letzte Anzahl empfangener Datenbytes
                             LOAD s1, 00                             ; Datensatz vollständig
                             STORE s1, s_midi_1_counter              ; neue Anzahl empfangener Datenbytes
                             LOAD midi_1_rxflag, FF                  ; jetzt vollständig, Flag setzen
                             RETURN 
                             ;
  midi_1_start_sysex_to_avr: 
                             ; SysEx-Start $F0 wurde empfangen, ist in s0
                             LOAD midi_1_SysExFlag, 01
                             JUMP midi_1_sysex_to_avr_s0
                             ;
   midi_1_stop_sysex_to_avr: 
                             LOAD midi_1_SysExFlag, 00
                             LOAD s0, F7
     midi_1_sysex_to_avr_s0: 
                             ; 3 Bytes werden parallel übertragen, deshalb Umsetzung auf Controller für AVR-SPI
                             LOAD s1, B0
                             OUTPUT s1, MIDI_CMD
                             LOAD s1, 78                             ; eigener Controller $7B = 123, eigentlich AllNotesOff
                             OUTPUT s1, MIDI_DB1
                             OUTPUT s0, MIDI_DB2                     ; SysEx-Daten einschl. F0 und F7, hier 8 Bit zulässig!
                             JUMP midi_strobe_avr                    ; und RETURN
                             ;
                             ; ##############################################################################
                             ; ################# M I D I   I N P U T  2 (DIN2/SAM/USB) ######################
                             ; ##############################################################################
                             ;
                             ; MIDI Daten wurden von Input 2 empfangen
                             ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                             ;
             midi_2_receive: 
                             INPUT s0, MIDI_IN2
                             COMPARE s0, F0                          ; RealTime ab $F0?
                             JUMP C, midi_2_channel_message          ; wenn kleiner als F0, mit Channel Messages weiter
                             COMPARE s0, F8                          ; RealTime ab $F8?
                             RETURN NC                               ; Realtime ab #F8 ohne Daten, verwerfen
                             COMPARE s0, F0                          ; Start of SysEX, Flag setzen
                             JUMP Z, midi_2_start_sysex_to_avr
                             COMPARE s0, F7                          ; End of SysEX, Flag löschen
                             JUMP Z, midi_2_stop_sysex_to_avr
                             ; ab hier nur noch Werte zwischen F1 und F6 übrig:
                             ; F1 Timecode Quarter Frame, F2 Song Position Pointer, F3 Select Song
                             LOAD s1, FF
                             STORE s1, s_midi_2_ignoreflag           ; Flag setzen: folgende Daten ignorieren
                             RETURN 
                             ;
     midi_2_channel_message: 
                             TEST s0, 80
                             JUMP Z, midi_2_is_databyte
                             ; ist ab hier eine Channel Message
                             STORE s0, s_midi_2_cmd
                             LOAD s1, 00                             ; ist ein neuer (Running) Status
                             STORE s1, s_midi_2_counter
                             STORE s1, s_midi_2_ignoreflag           ; Flag löschen: bald folgende Daten wieder relevant
                             COMPARE midi_2_SysExFlag, 00
                             JUMP NZ, midi_2_stop_sysex_to_avr       ; Sysex durch Channel-Command beendet
                             RETURN 
                             ;
         midi_2_is_databyte: 
                             COMPARE midi_2_SysExFlag, 00            ; Läuft SysEx-Übertragung?
                             JUMP NZ, midi_2_sysex_to_avr_s0         ; dann Daten zum AVR senden
                             ;
                             FETCH s1, s_midi_2_ignoreflag           ; Daten von Sytem Common F1, F2, F3?
                             COMPARE s1, 00
                             RETURN NZ                               ; Datenbytes ignorieren wenn ja
                             ;
                             FETCH s1, s_midi_2_counter
                             ADD s1, 01
                             STORE s1, s_midi_2_counter
                             COMPARE s1, 02
                             JUMP Z, midi_2_is_second_databyte
                             ;
                             ; erstes Datenbyte empfangen:
                             ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                             ; Datensatz ist mit einem Datenbyte vollständig!
                             FETCH s1, s_midi_2_cmd
                             AND s1, F0                              ; Kanal ausmaskieren
                             COMPARE s1, C0                          ; program change
                             JUMP Z, midi_2_is_singledatabyte
                             COMPARE s1, D0                          ; channel pressure
                             JUMP Z, midi_2_is_singledatabyte
   midi_2_is_first_databyte: 
                             STORE s0, s_midi_2_data1
                             RETURN 
                             ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
   midi_2_is_singledatabyte: 
                             STORE s0, s_midi_2_data1
  midi_2_is_second_databyte: 
                             STORE s0, s_midi_2_data2
                             FETCH s1, s_midi_2_counter
                             STORE s1, s_midi_2_len                  ; letzte Anzahl empfangener Datenbytes
                             LOAD s1, 00                             ; Datensatz vollständig
                             STORE s1, s_midi_2_counter              ; neue Anzahl empfangener Datenbytes
                             LOAD midi_2_rxflag, FF                  ; jetzt vollständig, Flag setzen
                             RETURN 
                             ;
  midi_2_start_sysex_to_avr: 
                             LOAD midi_2_SysExFlag, FF
                             JUMP midi_2_sysex_to_avr_s0
                             ;
                             ; SysEx-Datenübertragung immer komplett abwarten
   midi_2_stop_sysex_to_avr: 
                             LOAD midi_2_SysExFlag, 00
                             LOAD s0, F7
     midi_2_sysex_to_avr_s0: 
                             ; SysEx-Start $F0 wurde empfangen, ist in s0
                             ; 3 Bytes werden parallel übertragen, deshalb Umsetzung auf Controller für AVR-SPI
                             LOAD s1, B0
                             OUTPUT s1, MIDI_CMD
                             LOAD s1, 78                             ; eigener Controller $7B = 123, eigentlich AllNotesOff
                             OUTPUT s1, MIDI_DB1
                             OUTPUT s0, MIDI_DB2                     ; SysEx-Daten einschl. F0 und F7, hier 8 Bit zulässig!
                             JUMP midi_strobe_avr                    ; und RETURN
                             ;
                             ; ##############################################################################
                             ; ###################### M I D I   I N P U T  3 (AVR) ##########################
                             ; ##############################################################################
                             ;
                             ; SPI-MIDI Daten wurden von AVR empfangen
                             ; vereinfachte SysEx-Behandlung
             midi_3_receive: 
                             ;
                             ; LOAD s1, FA ; ##### TEST #####
                             ; OUTPUT s1, AUXPORT ; Trigger für LA
                             ; OUTPUT s0, AUXPORT ; ##### TEST #####
                             INPUT s0, MIDI_AVR
                             COMPARE s0, F0                          ; SysEx-Start?
                             JUMP Z, midi_3_startSysEx
                             COMPARE s0, F7                          ; SysEx-Ende?
                             JUMP Z, midi_3_stopSysEx
                             FETCH s1, s_midi_3_SysExFlag
                             COMPARE s1, 00
                             JUMP NZ, midi_tx_both                   ; s0 Senden, Übertragung läuft noch
                             ;
                             TEST s0, 80
                             JUMP Z, midi_3_is_databyte
                             LOAD s1, 00                             ; ist ein neuer (Running) Status
                             STORE s1, s_midi_3_counter
                             STORE s1, s_midi_3_SysExFlag
                             STORE s0, s_midi_3_cmd
                             RETURN 
         midi_3_is_databyte: 
                             FETCH s1, s_midi_3_counter
                             ADD s1, 01
                             STORE s1, s_midi_3_counter
                             COMPARE s1, 02
                             JUMP Z, midi_3_is_second_databyte
                             ; erstes Datenbyte empfangen:
                             ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                             ; Datensatz ist mit einem Datenbyte vollständig!
                             FETCH s1, s_midi_3_cmd
                             AND s1, F0                              ; Kanal ausmaskieren
                             COMPARE s1, C0                          ; program change
                             JUMP Z, midi_3_is_singledatabyte
                             COMPARE s1, D0                          ; channel pressure
                             JUMP Z, midi_3_is_singledatabyte
   midi_3_is_first_databyte: 
                             STORE s0, s_midi_3_data1
                             RETURN 
                             ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
   midi_3_is_singledatabyte: 
                             STORE s0, s_midi_3_data1
  midi_3_is_second_databyte: 
                             STORE s0, s_midi_3_data2
                             FETCH s1, s_midi_3_counter
                             STORE s1, s_midi_3_len                  ; Anzahl empfangener Datenbytes
                             LOAD s1, 00                             ; Datensatz vollständig
                             STORE s1, s_midi_3_counter              ; letzte Anzahl empfangener Datenbytes
                             LOAD midi_3_rxflag, FF                  ; jetzt vollständig, Flag setzen
                             RETURN 
                             ; SysEx-Daten vom AVR unbehandelt senden, aber Flag setzen
          midi_3_startSysEx: 
                             CALL midi_tx_both                       ; verwendet s1
                             LOAD s1, FF
                             STORE s1, s_midi_3_SysExFlag
                             RETURN 
           midi_3_stopSysEx: 
                             CALL midi_tx_both                       ; verwendet s1
                             LOAD s1, 00
                             STORE s1, s_midi_3_SysExFlag
                             RETURN 
                             ;
            midi_strobe_avr: 
                             LOAD s0, 01                             ; pos. Flanke an MIDI-FIFO
                             OUTPUT s0, MIDI_STR
                             LOAD s0, 00
                             OUTPUT s0, MIDI_STR
                             RETURN 
                             ;
                             ; ##############################################################################
                             ; ##############################################################################
                             ; ###                           Initialisierungen                            ###
                             ; ##############################################################################
                             ; ##############################################################################
                             ;
                  scan_init: 
                             LOAD s0, 00
                             OUTPUT s0, SCANPORT
                             OUTPUT s0, STATUS
                             OUTPUT s0, MIDI_OUT_SEL
                             LOAD midi_1_rxflag, 00
                             LOAD midi_2_rxflag, 00
                             LOAD midi_1_SysExFlag, 00
                             LOAD midi_2_SysExFlag, 00
                             LOAD midi_3_rxflag, 00
                             LOAD page_select, 00
                             LOAD manual_select, 00
                             LOAD s8_msb_smode, 00
                             LOAD s7_lsb_spoint, 00
                             LOAD event_key, 00
                             LOAD scan_number, 00
                             LOAD s3_key_status, 00
                             LOAD idx_ptr, 00
                             ; LOAD s0, F8                             ; NEU ab #31
                             ; STORE s0, s_average_dyn                 ; Mittelwert eigener Anschlag
                             LOAD s0, 00
          zero_scratch_loop: 
                             STORE s0, (idx_ptr)
                             ADD idx_ptr, 01
                             COMPARE idx_ptr, 40
                             JUMP NZ, zero_scratch_loop
                             ;
                             LOAD s0, 00
                             STORE s0, s_pedal_noisecounter
                             LOAD idx_ptr, 00
                             CALL scan_wait_init
                             CALL allnotesoff
                             LOAD s0, 00
                             OUTPUT s0, RAM_PAGE
                             CALL split_off
                             ; INIT Message mit ScanCore Info
                             LOAD s0, c_corevers
                             OUTPUT s0, MIDI_DB2
                             LOAD s0, c_corerevi
                             OUTPUT s0, MIDI_DB1
                             LOAD s0, AA
                             OUTPUT s0, MIDI_CMD
                             CALL midi_strobe_avr
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
               midi_testout: 
                             ; für Debug-Zwecke, sendet MIDI-Programchange mit Wert in s0
                             LOAD s1, C0
                             OUTPUT s1, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             OUTPUT s1, MIDI_TX_2                    ; TX Midi an SAM
                             OUTPUT s0, MIDI_TX_1                    ; TX Midi auf DIN-Buchse
                             OUTPUT s0, MIDI_TX_2                    ; TX Midi an SAM
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
           load_s0_with_max: LOAD s0, FF
                             RETURN 
                scan_config: 
                             LOAD s0, 00
                             FETCH s1, s_keycount_upper              ; Anzahl gedrückter Tasten Upper
                             COMPARE s1, 00
                             CALL NZ, load_s0_with_max
                             OUTPUT s0, KEYS_ON_UPR
                             ;
                             LOAD s0, 00
                             FETCH s1, s_keycount_lower              ; Anzahl gedrückter Tasten Lower
                             COMPARE s1, 00
                             CALL NZ, load_s0_with_max
                             OUTPUT s0, KEYS_ON_LWR
                             ;
                             INPUT s0, SPI_KEYTRANSPOSE
                             FETCH s1, s_keytranspose
                             COMPARE s0, s1
                             STORE s0, s_keytranspose
                             ; CALL NZ, midi_testout
                             CALL NZ, allnotesoff                    ; Key-Transpose geändert
                             INPUT s0, SPI_GENTRANSPOSE
                             FETCH s1, s_gentranspose
                             COMPARE s0, s1
                             STORE s0, s_gentranspose
                             CALL NZ, allnotesoff                    ; Generator-Transpose geändert
                             INPUT s1, SPI_CLICKLEN
                             AND s1, 0F                              ; max. 15 ms
                             LOAD s0, FF
                             SUB s0, s1
                             STORE s0, s_clicklen                    ; Startwert 1ms-Timer, max. 255
                             INPUT s0, SPI_CLICKLEN
                             AND s0, F0
                             SR0 s0
                             SR0 s0                                  ; Wert immer noch vervierfacht
                             ; z.B. $13(5A) = Teilfaktor 4954 für 10 kHz Samples oder 5 kHz Noise-Frequenz
                             OUTPUT s0, NOISE_FREQ
                             ; MIDI-Kanal geändert?
                             FETCH s1, s_midich
                             INPUT s0, SPI_MIDICH
                             COMPARE s0, s1
                             STORE s0, s_midich
                             CALL NZ, allnotesoff                    ; wenn MIDI-Kanal geändert
                             ; OUTPUT s0, AUXPORT ; Trigger für LA
                             INPUT s0, SPI_MIDIOPT                   ; Bit 7 (MSB): USE SOST/SUSTAIN
                             OUTPUT s0, MIDI_OUT_SEL
                             ;
                             ; Split überprüfen. In SPI_XXX befindet sich ggf. neue Split-ON/OFF-Einstellung vom Panel
                             FETCH s0, s_splitpoint
                             INPUT s1, SPI_SPLITPOINT
                             STORE s1, s_splitpoint
                             COMPARE s0, s1
                             CALL NZ, split_changed                  ; wenn geändert
                             ;
                             FETCH s0, s_splitmode
                             INPUT s1, SPI_SPLITMODE
                             STORE s1, s_splitmode
                             COMPARE s0, s1
                             CALL NZ, split_changed                  ; wenn geändert
                             ;
                             FETCH s0, s_split_on                    ; alter Split-On-Zustand
                             INPUT s1, SPI_SPLITON                   ; neu von Bedienelement
                             AND s1, 03
                             STORE s1, s_split_on
                             COMPARE s0, s1
                             RETURN Z                                ; nicht geändert
                             TEST s1, 02                             ; Split-Request-Bit gesetzt?
                             JUMP NZ, set_splitpoint                 ; anhand eigener Tastendrücke setzen
                             ; sonst nur weiter mit split_changed
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
              split_changed: 
                             CALL allnotesoff                        ; wenn geändert
             split_mode_new: 
                             FETCH s0, s_split_on
                             COMPARE s0, 00
                             JUMP Z, split_off
                             RETURN 
                             ;
                             ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                             ;
             scan_wait_init: 
                             LOAD s0, c_scankey_delay                ; Scan-Timer neu laden
                             OUTPUT s0, SCANTIMER_VAL
                             RETURN 
                             ; Active Sensing senden falls Timer abgelaufen
             active_sensing: 
                             FETCH s0, s_midi_activesensing          ; nach 256 ms Active Sensing senden
                             ADD s0, 01
                             STORE s0, s_midi_activesensing
                             COMPARE s0, 00
                             RETURN NZ
                             ; TEST: Active Sensing abgeschaltet
                             ; RETURN
                             CALL midi_out_waitbuf
                             LOAD s0, FE
                             OUTPUT s0, MIDI_TX_1
                             OUTPUT s0, MIDI_TX_2
                             RETURN 
                             ;
                             ; ##############################################################################
                             ; Splitmode setzen:
                             ; 0 = PedalToLower,
                             ; 1 = LowerToUpper
                             ; 2 = PedalToUpper
                             ; 3 = LowerToUpper + 1 Oktave
                             ; 4 = LowerToUpper + 2 Oktaven
                             ; 5 = Add Pedal to Lower
                             ; ##############################################################################
                             ;
             set_splitpoint: 
                             FETCH s0, s_split_on
                             COMPARE s0, 00                          ; nun ausgeschaltet?
                             JUMP Z, split_exit                      ; dann All Notes Off und Ende
                             ; Split-Funktion wurde seit letztem Durchlauf von OFF auf ON geändert.
                             ; Feststellen, ob Keyboard-Tasten gedrückt wurden, dann diese setzen und als
                             ; Splitpoint an AVR senden.
                             FETCH s0, s_keycount_upper
                             FETCH s1, s_keycount_lower
                             ADD s0, s1
                             COMPARE s0, 00
                             JUMP Z, split_exit                      ; keine Tasten gedrückt, alter Splitmode
                             FETCH s7_lsb_spoint, s_lastkey_on
                             STORE s7_lsb_spoint, s_splitpoint
                             ;
                             COMPARE s1, 00
                             JUMP Z, set_splitpoint_upper            ; keine Tasten auf Lower, also Upper
                             SUB s1, 01
                             COMPARE s1, 00
                             JUMP Z, set_splitpoint_store            ; wenn nur eine Taste gedrückt, SplitMode 0 speichern
                             LOAD s1, 05                             ; sonst 5 = Add Pedal to Lower
                             JUMP set_splitpoint_store
                             ;
       set_splitpoint_upper: 
                             ; Anzahl der Tasten Obermanual ist zufällig auch Splitmode 0..4
                             FETCH s1, s_keycount_upper
       set_splitpoint_store: 
                             STORE s1, s_splitmode
                             ; gewünschten Splitmode an AVR senden, über internal MIDI an Controller $70 und $71
                             LOAD s0, B0
                             OUTPUT s0, MIDI_CMD
                             LOAD s0, 76
                             OUTPUT s0, MIDI_DB1
                             OUTPUT s1, MIDI_DB2
                             CALL midi_strobe_avr
                             ; MIDI_CMD bleibt!
                             LOAD s0, 77
                             OUTPUT s0, MIDI_DB1
                             OUTPUT s7_lsb_spoint, MIDI_DB2
                             CALL midi_strobe_avr
                             ;
                  split_off: 
                 split_exit: 
                             CALL allnotesoff
                             FETCH s0, s_midich
                             ADD s0, B0
                             CALL midi_tx_both
                             CALL split_sendoff_data
                             FETCH s0, s_midich
                             ADD s0, B1
                             CALL midi_tx_both
                             CALL split_sendoff_data
                             FETCH s0, s_midich
                             ADD s0, B2
                             CALL midi_tx_both
         split_sendoff_data: 
                             LOAD s0, 7B                             ; Controller 123
                             OUTPUT s0, MIDI_TX_1
                             OUTPUT s0, MIDI_TX_2
                             LOAD s0, 7F                             ; 127
                             OUTPUT s0, MIDI_TX_1
                             OUTPUT s0, MIDI_TX_2
                             RETURN 
