                              ;
                              ; ##############################################################################
                              ; ############ KCPSM6 PicoBlaze Keyboard Scanner by cm 10/2010 #################
                              ; #################### for 12 BIT ADDRESS ROM (4096 Words) #####################
                              ; ##############################################################################
                              ;
                              ; 31.12.2021 #40 Key Reverse State beim Verlassen der Endstellung, sendet früher, Noise etwas verringert
                              ; 18.10.2021 #39 Octave Shift für Upper und Lower in Manual Scan
                              ; 30.07.2021 #37 Sendet AllNotesOff bei Split-Änderungen, SplitMode 5 (AddPedalToLower)
                              ; 18.05.2021 #36 Andere Noise-Berechnung
                              ; 12.01.2021 #33 Bug in ResetDynTimers behoben
                              ; 12.01.2021 #31 Dynamik-Ermittlung über variables Timer-Dekrement (1/t)
                              ; 09.01.2021 #30 Scan-Dynamik jetzt per Statemachine
                              ; 03.09.2020 #28 Keine Übersetzung Sostenuto mehr
                              ; 22.02.2020 #25 Auch Kanal +3 an AVR für Touchpad
                              ; 20.11.2019 #23 MIDI-Dispatcher verbessert, wird öfter ausgeführt
                              ; 10.11.2019 #20 Local Enables auf SPI $2E
                              ; 21.02.2018 #19 Kleine Verzögerung vor Auslesen der Tastenkontakte wg. Emils Geisternoten
                              ; 13.02.2018 #18 Bug in Key Transpose behoben
                              ; 22.11.2018 #17 Split-Handling jetzt nur noch in Tastatur-Scan
                              ; 12.09.2018 #15 Bug in Midi-Kanalwahl behoben
                              ; 14.08.2018 #14 Bug in local_states_off (Dyn. 1 gesendet) behoben
                              ; 09.08.2018 #12 Sostenuto-Controller 42 geändert auf 45, HOLD2-Pedal wg. NI B4-PERC Konflikt
                              ; 24.04.2018 #11 Bugfixes für Fatar
                              ; 20.10.2017 #10 Zusätzlicher MIDI-Ausgang für SAM5504
                              ; 10.10.2017 Angepasst für KCPSM6, Inputs für Cancel Manual und HW-Sostenuto/Sustain auf PL Auxiliary
                              ; Pins schalten nach Masse!
                              ; Pin 6 = Bit 5 Sustain Upper
                              ; Pin 5 = Bit 4 Sostenuto Upper
                              ; Pin 4 = Bit 3 Sustain Lower
                              ; Pin 3 = Bit 2 Sostenuto Lower
                              ; Pin 2 = Bit 1 Cancel MIDI Kanal invert., 11 = Cancel Off, 10 = Cancel Upper,
                              ; Pin 1 = Bit 0 Cancel MIDI Kanal invert., 01 = Cancel Lower, 00 = Cancel Pedal
                              ;
                              CONSTANT c_corevers, 51                     ; $50=SR4014, $51=Fatar, $52=Opto, $53=MIDI RcvOnly
                              CONSTANT c_corerevi, 40                     ; Revisionsnummer
                              CONSTANT c_dyn_threshold, 28                ; MIDI-Dynamikschwelle für full click
                              CONSTANT c_midi_mindyn, 18                  ; MIDI-Minimaldynamik langsame Taste
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              ; Je nach Tastaturumfang sind anzupassen:
                              CONSTANT c_maxkeys, 61'd                    ; längste vorhandene Tastatur (44/49/61)
                              CONSTANT c_maxkeys_plus_one, 62'd           ; längste vorhandene Tastatur (44/49/61) +1
                              CONSTANT c_maxbasskeys, 25'd                ; Anzahl der Pedal-Tasten an AuxPort PL8
                              CONSTANT c_midi_firstkey, 24'd
                              CONSTANT c_midi_lastkey_plus_one, 109'd
                              CONSTANT c_gen_firstkey, 36'd               ; Tonumfang INPUT MIDI-Notennummern
                              CONSTANT c_gen_lastkey_plus_one, 97'd       ; 96+1 wg. COMPARE
                              CONSTANT c_midi_offset, 36'd                ; Offset zu unterster MIDI-Note "C" bei 5 Oktaven (default 36)
                              CONSTANT c_scankey_delay, 47'd              ; Delay pro Taste für 1 ms Scandurchlauf INPUT SYNC-Ticks (20,4 µs)
                              ;
                              ; nach Assemblierung DAT-Datei für XMODEM-Upload
                              ; erstellen mit Tool hex2dat_kcpsm6.exe oder Batch convert_xxx.bat
                              ;
                              ; ##############################################################################
                              ; ############################ MPX-RAM-Organisation ###########################
                              ; ##############################################################################
                              ;
                              ; Ein/Ausschalten der HX3-Tastenkontakte erfolgt durch Schreiben der
                              ; Kontaktdaten INPUT ein Dual-Port-RAM, das sogerannte MPX-RAM.
                              ; Jede Taste(nspalte) belegt eine Adresse,
                              ; so dass das tiefste "C" immer Adresse 0 hat, das höchste "C" Adresse 60.
                              ; Für jedes Manual stehen 8 Bits des 18-Bit-Datenbusses zur Verfügung,
                              ; für das Pedal 2 (sonst ungenutzte Paritätsbits). Jeder Teil kann getrennt geschrieben/gelesen werden.
                              ; MPX-RAM besteht aus 16 Pages je 64 Worte, 16 Bit plus zwei "Parity"-Bits,
                              ; die hier für den Pedal-Status benutzt werden.
                              ; Auswahl der Page über PB_PAGE.
                              ; s8_msb_smode, LSB und Parity-Bits können getrennt über STROBEs geschrieben werden.
                              ; Page 0 dient direkt als Freigabe für Tastenkontakte:
                              ; ##### LOWER ##### ##### UPPER ##### - Bytes
                              ; 7 MSN 4 3 LSN 0 7 MSN 4 3 LSN 0 - Nibbles
                              ; #NOISE# #STEADY# #NOISE# #STEADY#
                              ; - C B A L C B A - C B A L C B A - Bits
                              ; mit ABC = Anzahl eingeschalteter Tastenkontakte, L = Level-Bit,
                              ; Dabei wird Wert ABC jeweils anhand des folgenden Schemas dekodiert:
                              ; 76543210 ; Busbar CONTACT-Bit 0 = 16'. Bit 7 schaltet sowohl 1' als auch 1 1/3' ein!
                              ; 00000000 ; Stufe 0, alle aus
                              ; 00100000 ; Stufe 1...
                              ; 00100100
                              ; 01100100
                              ; 01100110
                              ; 11100110
                              ; 11101111
                              ; 11111111 ; bis Stufe 7, alle an bzw. alle noisy
                              ; Level-Bit L gelangt direkt zum CONTACT-Level-Bit 8.
                              ; Ist STEADY komplett an, ist der Wert des Noise-Gates egal, da Werte verODERt werden.
                              ; Pedalkontakt CONT_PEDAL ist an Bit(0) angeschlossen, Bit (1) kann als Scratch dienen.
                              ; Die Nibbles können in pb_scanif.vhd einzeln gelesen werden!
                              ; PAGE 1 als Soft-Timer für Tastenkontakte
                              ; PAGE 2 als Soft-Timer für Noise
                              ; PAGEs 6 bis 15 können nach Belieben verwendet werden.
                              ;
                              ; MPX RAM_PAGE Offsets
                              ; Seitenaufteilung INPUT 64-Byte-Seiten über RAM_PAGE
                              CONSTANT c_page_vcontacts, 00               ; virtuelle Tastenkontakte, 0..61, direktes Lesen und Schreiben
                              ; Alle Timer starten bei Schreiben eines Wertes ungleich 0 und stoppen bei Erreichen von 255.
                              CONSTANT c_page_dyntimer, 01                ; Dynamik-Timer 0..61
                              CONSTANT c_page_noisetimer, 02              ; Noise-Timer 0..61
                              CONSTANT c_page_keystatus1, 04              ; Eigene Tastatur Zustand für Tasten 12..63
                              CONSTANT c_page_keystatus2, 05              ; Eigene Tastatur Zustand für Tasten 64.. 121
                              CONSTANT c_page_midirx1, 06                 ; MIDI-Empfangsdaten Dynamik für Tasten 12..63
                              CONSTANT c_page_midirx2, 07                 ; MIDI-Empfangsdaten Dynamik für Tasten 64.. 121
                              CONSTANT c_page_sostenutoflags, 08          ; Sostenuto-Flags 0..61
                              CONSTANT c_page_timerstates, 09             ; MIDI-sent-Flags 0..61
                              CONSTANT c_page_localdyn1, 0A               ; MIDI-Empfangsdaten Dynamik für Tasten 12..63
                              CONSTANT c_page_localdyn2, 0B               ; MIDI-Empfangsdaten Dynamik für Tasten 64.. 121
                              CONSTANT c_page_oldkeystatus1, 0C           ; Vorheriger Zustand für Tasten 12..63
                              CONSTANT c_page_oldkeystatus2, 0D           ; Vorheriger Zustand für Tasten  64.. 121
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Portadressen bidirektional
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              ; $00 bis $07 Einzelbits SCANPORT Eingang, für Opto und Fatar
                              CONSTANT SCANPIO1, 00
                              CONSTANT SCANPIO2, 01
                              CONSTANT SCANPIO3, 02
                              CONSTANT SCANPIO4, 03
                              CONSTANT SCANPIO5, 04
                              CONSTANT SCANPIO6, 05
                              CONSTANT SCANPIO7, 06
                              CONSTANT SCANPIN8, 07
                              ; $00 bis $07 Einzelbits AUXPORT Eingang, für OrganScan/HOAX5 mit 4014 und Bass13/25
                              CONSTANT AUXPIO1, 08
                              CONSTANT AUXPIO2, 09
                              CONSTANT AUXPIO3, 0A
                              CONSTANT AUXPIO4, 0B
                              CONSTANT AUXPIO5, 0C
                              CONSTANT AUXPIO6, 0D
                              CONSTANT AUXPIO7, 0E
                              CONSTANT AUXPIN8, 0F
                              CONSTANT SCANPIN, 10                        ; Scan Port gesamt Leser
                              CONSTANT SCANPORT, 10                       ; Scan Port gesamt Schreiben
                              CONSTANT SCANPORT_DDR, 11                   ; Data Direction für Scan IF
                              CONSTANT AUXPIN, 18                         ; Auxiliary Port gesamt
                              CONSTANT AUXPORT, 18
                              CONSTANT AUXPORT_DDR, 19                    ; Data Direction für Scan IF
                              CONSTANT PRESCANPIN, 32                     ; (50), PresetScan
                              CONSTANT PRESCANPORT, 28                    ; (40) Preset-Scan-Port
                              CONSTANT PRESCANPORT_DDR, 29                ; (41) Preset - Scan - PortDirection
                              ; Output ports
                              CONSTANT c_strobe_mask, 20                  ; für indirektes Schreiben
                              CONSTANT UPPER_STROBE, 20                   ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Upper (1 Byte)
                              CONSTANT LOWER_STROBE, 21                   ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Lower (1 Byte)
                              CONSTANT PEDAL_STROBE, 22                   ; Schreibzugriff erzeugt Write für Pedal-Bits (2 Bits)
                              CONSTANT MIDI_CMD, 30                       ; MIDI-Befehl
                              CONSTANT MIDI_DB1, 31
                              CONSTANT MIDI_DB2, 32
                              CONSTANT MIDI_STR, 33                       ; MIDI Strobe für AVR, neg. Flanke
                              CONSTANT STATUS, 34                         ; STATUS an AVR SPI, Bit 0 bis 3 durch PB schreibbar, Bit 4 und 5 direkt SPI MIDI FIFO STAT
                              CONSTANT KEYS_ON_UPR, 35                    ; Bit 0: auf Upper sind Tasten gedrückt
                              CONSTANT KEYS_ON_LWR, 36                    ; Bit 0: auf Lower sind Tasten gedrückt
                              ; CONSTANT BASS_ENV, 37                 ; UNUSED
                              CONSTANT PEDAL_DOWN, 38                     ; Bit 0
                              CONSTANT PED_ACC_ENA, 39                    ; für pedal click noise
                              CONSTANT MIDI_OUT_SEL, 3A                   ; auf 4-fach Multiplexer,
                              ; MIDI_OUT_SEL: 0 = MIDI_TX_1, 1 = MIDI_IN_1, 2 = MIDI_IN_2, 3 = MIDI_FROM_SAM (USB)
                              ; Universal-Timer, hier für Scan-Durchlauf, 255 = 5,22 ms
                              ; wird mit jedem SYNC alle 20,48 µs dekrementiert bis 0 erreicht
                              CONSTANT SCANTIMER_VAL, 3D                  ; Schreiben des neuen Wertes startet Timer
                              CONSTANT SCANTIMER_ZERO, 3E                 ; Flag wenn 0 erreicht
                              CONSTANT NOISE_FREQ, 3F                     ; bestimmt Noise-Frequenz
                              CONSTANT RAM_PAGE, 40                       ; Seitenadresse zum einfacheren Zugriff, Page 0 = MPX Dual Port
                              CONSTANT RAM_ADDR, 41                       ; für alle Zugriffe gültig
                              CONSTANT RAM_WRDATA, 42                     ; zu schreibende Daten
                              CONSTANT MIDI_TX_1, 80                      ; MIDI UART-Tx-FIFO MAIN
                              CONSTANT MIDI_TX_2, 81                      ; MIDI UART-Tx-FIFO VENT (intern an Ventilator oder Mini-GM-Modul)
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Input Ports
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Flags für SPI-Empfang:
                              ; Bit 0 = Daten wurden geschrieben (wird durch Lesen der SPI-Register gelöscht)
                              ; Bit 1 = AVR-MIDI FIFO Daten im Buffer,
                              ; Bit 2 = AVR-MIDI FIFO Buffer halb voll
                              ; Bit 3 = AVR-MIDI FIFO Buffer voll
                              CONSTANT SPI_FLAG, 30                       ; "0000000" & spiflag
                              CONSTANT TX_STATUS, 31                      ; Bit 0 = Buffer halbvoll, Bit 1 = Buffer voll
                              CONSTANT c_read_mask, 34                    ; für indirektes Lesen
                              CONSTANT RD_UPPER, 34                       ; Upper-Byte vom MPX-RAM
                              CONSTANT RD_LOWER, 35                       ; Lower-Byte vom MPX-RAM
                              CONSTANT RD_PEDAL, 36                       ; Pedal-Bits vom MPX-RAM (1:0)
                              CONSTANT MIDI_IN1, 38
                              CONSTANT MIDI_IN1_STATUS, 39                ; "0000" & midi_1_full & midi_1_half & midi_1_datapresent & '0';
                              CONSTANT MIDI_IN2, 3A
                              CONSTANT MIDI_IN2_STATUS, 3B                ; "0000" & midi_2_full & midi_2_half & midi_2_datapresent & '0';
                              CONSTANT MIDI_AVR, 3C                       ; MIDI vom AVR über SPI
                              CONSTANT MIDI_AVR_STATUS, 3D                ; "0000" & avrfifo_full & avrfifo_half & avrfifo_datapresent & avrmidiflag
                              CONSTANT RND_NUMBER, 3F                     ; Zufallswert 8 Bit
                              ; Werte vom AVR-SPI
                              CONSTANT SPI_MIDICH, 24                     ; Adresse $04 von außen (AVR)
                              CONSTANT SPI_MIDIOPT, 25
                              CONSTANT SPI_SPLITMODE, 26
                              CONSTANT SPI_SPLITON, 27                    ; 7 von außen (AVR)
                              CONSTANT SPI_SPLITPOINT, 28                 ; 8 von außen (AVR)
                              CONSTANT SPI_CLICKLEN, 29
                              CONSTANT SPI_GENTRANSPOSE, 2A               ; 10 = Generator Transpose
                              CONSTANT SPI_CONFIG_1, 2B                   ; 11 = EARLY_KEY (Bit 0), VelocityFactor (Bit 7..2)
                              ; SPI_AVR_MIDI, 2C ; AVR-MIDI-Daten, FIFO-Eingang
                              CONSTANT SPI_KEYTRANSPOSE, 2D               ; Key Transpose (local keyboard)
                              CONSTANT SPI_LOCALDISABLES, 2E
                              ;
                              CONSTANT c_state_idle, 00                   ; für Tastenabfrage-Timer, Ruhezustand
                              CONSTANT c_state_forward, 01                ; für Tastenabfrage-Timer, zählend
                              CONSTANT c_state_stopped, 02                ; für Tastenabfrage-Timer, angehalten
                              CONSTANT c_state_reverse, 03                ; für Tastenabfrage-Timer, bewegt sich zurück
                              ;
                              CONSTANT c_key_idle, 00                     ; für Tastenabfrage, Ruhezustand
                              CONSTANT c_key_moving, 01                   ; für Tastenabfrage, in Bewegung
                              CONSTANT c_key_dirty, 02                    ; für Tastenabfrage, Ende erreicht (dirty)
                              CONSTANT c_key_on, 03                       ; für Tastenabfrage, Ende erreicht
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Picoblaze Scratchpad Memory
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              CONSTANT s_keystatus_upper, 00              ; für Tastenabfrage, vorheriger Tastenzustand - NOCH NICHT BENUTZT!
                              CONSTANT s_keystatus_lower, 01
                              CONSTANT s_keystatus_pedal, 02
                              CONSTANT s_gentranspose, 03                 ; Tongenerator-Transpose
                              CONSTANT s_keytranspose, 04                 ; Tastatur-Transpose
                              CONSTANT s_split_on, 05                     ; Letzter Split-Zustand
                              CONSTANT s_velocityfac, 06                  ; Faktor für Timer-Dekrement
                              CONSTANT s_timerval, 07                     ; für Timer-Dekrement
                              CONSTANT s_splitpoint, 08                   ; Tastennummer von SPI-AVR
                              CONSTANT s_splitmode, 09
                              ; 10..29 MIDI-Daten für Interpreter/Dispatcher
                              CONSTANT s_midi_cmd, 10'd
                              CONSTANT s_midi_data1, 11'd
                              CONSTANT s_midi_data2, 12'd
                              CONSTANT s_midi_len, 13'd
                              CONSTANT s_midi_cmd_masked, 14'd            ; upper Nibble
                              CONSTANT s_midi_chan_masked, 15'd           ; lower Nibble
                              ; MIDI-Daten per Polling vom FIFO, Port 1
                              CONSTANT s_midi_1_cmd, 16'd
                              CONSTANT s_midi_1_data1, 17'd
                              CONSTANT s_midi_1_data2, 18'd
                              CONSTANT s_midi_1_len, 19'd
                              CONSTANT s_midi_1_counter, 20'd
                              ; MIDI-Daten per Polling vom FIFO, Port 2
                              CONSTANT s_midi_2_cmd, 21'd
                              CONSTANT s_midi_2_data1, 22'd
                              CONSTANT s_midi_2_data2, 23'd
                              CONSTANT s_midi_2_len, 24'd
                              CONSTANT s_midi_2_counter, 25'd
                              ; MIDI-Daten per Polling vom AVR-FIFO
                              CONSTANT s_midi_3_cmd, 26'd
                              CONSTANT s_midi_3_data1, 27'd
                              CONSTANT s_midi_3_data2, 28'd
                              CONSTANT s_midi_3_len, 29'd
                              CONSTANT s_midi_3_counter, 30'd
                              CONSTANT s_midi_3_SysExFlag, 31'd
                              ;
                              CONSTANT s_keycount_upper, 32'd
                              CONSTANT s_keycount_lower, 33'd
                              CONSTANT s_keycount_pedal, 33'd
                              CONSTANT s_midi_activesensing, 35'd         ; Zähler/Timer für MIDI Active Sensing
                              CONSTANT s_key_matrix, 36'd                 ; für FATAR
                              CONSTANT s_group_matrix, 37'd               ; für FATAR
                              CONSTANT s_noisetimerval, 38'd
                              CONSTANT s_pedal_on, 39'd                   ; Bass-Flag Trigger für Hüllkurve
                              CONSTANT s_midich, 40'd                     ; eingestellter MIDI-Kanal
                              CONSTANT s_midi_1_ignoreflag, 41'd          ; MIDI-Datenempfang: System Commons und deren Daten ignorieren
                              CONSTANT s_midi_2_ignoreflag, 42'd
                              CONSTANT s_switches_old, 43'd               ; kommt als Bit 1 von Split_ON (0000 00X0)
                              CONSTANT s_sustain_upr, 44'd
                              CONSTANT s_sustain_lwr, 45'd
                              ; 46 Dummy für Pedal, immer 0, nicht belegen!
                              CONSTANT s_sosten_upr, 47'd                 ; Empfangenes CC 64, Sostenuto aktiv
                              CONSTANT s_sosten_lwr, 48'd
                              ; 49 Dummy für Pedal, immer 0, nicht belegen!
                              CONSTANT s_midi_localkey, 50'd              ; für local out, enthält aktuelle Taste einschließlich Offset
                              CONSTANT s_midi_localdyn, 51'd
                              CONSTANT s_pedal_noisecounter, 52'd
                              CONSTANT s_old_contacts, 53'd               ; aktueller Tastenzustand
                              CONSTANT s_lastkey_on, 54'd                 ; letzte gedrückte Taste für Split
                              CONSTANT s_clicklen, 55'd                   ; Timer-Startwert
                              CONSTANT s_last_key_velocity, 56'd
                              ;
                              CONSTANT s_upper_localdyn, 58'd             ; gleichzeitig von ramread_X_scan gelesene Werte
                              CONSTANT s_lower_localdyn, 59'd
                              CONSTANT s_pedal_localdyn, 60'd
                              CONSTANT s_upper_mididyn, 61'd              ; gleichzeitig von ramread_X_scan gelesene Werte
                              CONSTANT s_lower_mididyn, 62'd
                              CONSTANT s_pedal_mididyn, 63'd
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Register Renames
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              NAMEREG sF, midi_1_rxflag
                              NAMEREG sE, midi_2_rxflag
                              NAMEREG sD, midi_1_SysExFlag
                              NAMEREG sC, midi_2_SysExFlag
                              NAMEREG sB, midi_3_rxflag
                              ; häufig benutzte Variablen
                              NAMEREG sA, page_select                     ; Timer-Page c_page_xxx, 0..3=AutoInc-Timer, 4..15 = Scratch RAM
                              NAMEREG s9, manual_select                   ; aktuelles Manual, 0 = upper, 1 = lower, 2 = bass
                              NAMEREG s8, s8_msb_smode                    ; Zustand gedrückte Taste MIDI-Empfang, msb für Multiply
                              NAMEREG s7, s7_lsb_spoint                   ; Zustand gedrückte Taste eigene Manuale, lsb für Multiply
                              NAMEREG s6, idx_ptr                         ; universeller Index-Zeiger
                              NAMEREG s5, event_key
                              NAMEREG s4, scan_number                     ; aktuelle Taste, Zähler ab 0 bis Tastenanzahl
                              NAMEREG s3, s3_key_status                   ; Zustand gedrückte Taste Manual und allgemein
                              ; s0, s1, s2 als Universal-Akkus
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                  cold_start: 
                              ; Einsprungpunkt nach Laden des Scan Cores
                              DISABLE INTERRUPT
                              CALL port_init
                              CALL scan_init
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              INPUT s0, SPI_MIDIOPT                       ; Bit 7 (MSB): USE SOST/SUSTAIN
                              AND s0, 80
                              JUMP NZ, main_loop
                              LOAD s0, 00
                              STORE s0, s_sustain_upr
                              STORE s0, s_sustain_lwr
                              STORE s0, s_sosten_upr
                              STORE s0, s_sosten_lwr
                              STORE s0, s_pedal_noisecounter
                              ; LOAD s0, E3                                 ; ##### TEST #####
                              ; OUTPUT s0, AUXPORT_DDR
                   main_loop: 
                              CALL midi_dispatch                          ; MIDI-Daten empfangen? - ca. 1,7µs
                              ; auf Scan-Freigabe durch Timer warten und neu setzen
                              INPUT s0, SCANTIMER_ZERO                    ; auf Scan-Freigabe warten
                              COMPARE s0, 00                              ; warte auf 1-ms-Tick
                              JUMP Z, main_loop
                              CALL scan_wait_init                         ; Scan-Timer neu starten
                              CALL scan_config                            ; Parameter-Änderungen? - ca. 3,4µs
                              CALL handle_sustain_switches                ; Sustain/Sostenuto-Eingangspins
                              CALL update_noisetimers                     ; alle Timer updaten - ca. 27 µs
                              ; CALL active_sensing                       ; ca. 1,3 µs
                              ;
                              ; LOAD s1, 01                                 ; ##### TEST #####
                              ; OUTPUT s1, AUXPIO6                          ; Trigger für LA
                              ;
                              CALL local_scan_manuals                     ; alle Manualtasten in RAM eintragen - ca. 340µs
                              ;
                              ; LOAD s1, 00                                 ; ##### TEST #####
                              ; OUTPUT s1, AUXPIO6                          ; Trigger für LA
                              ;
                              ; MIDI hat Timing-mäßig Vorrang vor eigener Tastatur,
                              ; um Buffer-Überläufe zu verhindern
                              CALL midi_dispatch                          ; MIDI-Daten empfangen? - ca. 1,7 µs
                              CALL event_handling                         ; ca. 580µs für 108 Tasten, 490µs für 96 Tasten
                              JUMP main_loop
                              ;
                              ; ###############################################################################
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; +++++++++++++++++++++ Scanboard-spezifischer Teil, +++++++++++++++++++++++++++
                              ; +++++++++++++++++++++++++++++ Hauptschleife ++++++++++++++++++++++++++++++++++
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; ###############################################################################
                              ;
                              ; Hilfsroutinen: Zubehör für Scan-Routinen, Initialisierungen
                              ;
                   port_init: 
                              ; Scan-Ports initialisieren
                              LOAD s0, 33                                 ; für Fatar-/Opto-Interface
                              OUTPUT s0, SCANPORT_DDR
                              LOAD s0, 03                                 ; für Bass/Aux-Interface
                              OUTPUT s0, AUXPORT_DDR
                              LOAD s0, 00                                 ; Sustainpedal, alles Eingänge
                              OUTPUT s0, PRESCANPORT_DDR
                              RETURN 
                              ;
                              ; ###############################################################################
                              ;
           clock_delay_short: 
                              LOAD s0, 02
                              JUMP clock_delay_loop
                 clock_delay: LOAD s0, 04
            clock_delay_loop: 
                              SUB s0, 01
                              JUMP NZ, clock_delay_loop
                              RETURN 
                              ;
               auxport_clock: 
                              ; pos. Impuls auf Auxport Pin 1
                              LOAD s0, 01
                              OUTPUT s0, AUXPIO1                          ; SR Clk
                              CALL clock_delay                            ; s0 ist jetzt 0
                              OUTPUT s0, AUXPIO1
                              RETURN 
             auxport_sr_load: 
                              ; Parallele Daten der 4014-SR übernehmen
                              LOAD s0, 01
                              OUTPUT s0, AUXPIO2                          ; SR Data einlesen lassen
                              CALL clock_delay_short
                              CALL auxport_clock
                              CALL clock_delay_short                      ; s0 ist jetzt 0
                              OUTPUT s0, AUXPIO2
                              RETURN 
                              ; nur für Fatar-Tastatur benötigt
            fatar_groupclock: 
                              ; pos. Impuls auf Scanport Pin 1
                              LOAD s0, 01
                              OUTPUT s0, SCANPIO1
                              CALL clock_delay                            ; s0 ist jetzt 0
                              OUTPUT s0, SCANPIO1
                              RETURN 
              fatar_keyclock: 
                              ; pos. Impuls auf Scanport Pin 5
                              LOAD s0, 01
                              OUTPUT s0, SCANPIO5
                              CALL clock_delay                            ; s0 ist jetzt 0
                              OUTPUT s0, SCANPIO5
                              RETURN 
              fatar_allreset: 
                              ; pos. Impuls auf Scanport Pin 2
                              LOAD s0, 01
                              OUTPUT s0, SCANPIO2
                              OUTPUT s0, SCANPIO6
                              CALL clock_delay                            ; s0 ist jetzt 0
                              OUTPUT s0, SCANPIO2
                              OUTPUT s0, SCANPIO6
                              RETURN 
              fatar_keyreset: 
                              ; pos. Impuls auf Scanport Pin 6
                              LOAD s0, 01
                              OUTPUT s0, SCANPIO6
                              CALL clock_delay                            ; s0 ist jetzt 0
                              OUTPUT s0, SCANPIO6
                              RETURN 
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
     handle_sustain_switches: 
                              ; abhängig vom PL16-Bits Flag in s_sustain_xxx oder s_sosten_xxx setzen/löschen
                              INPUT s3_key_status, PRESCANPIN             ; Bit 5 ist Sustain upper, Bit 3 lower
                              XOR s3_key_status, FF                       ; invertiert!
                              AND s3_key_status, 3C
                              FETCH s0, s_switches_old                    ; alter Schalterzustand
                              XOR s0, s3_key_status                       ; geänderte Bits jetzt auf 1 in s0
                              RETURN Z                                    ; nichts geändert
                              ; Es hat sich etwas geändert, jetzt einzeln verzweigen
                              FETCH s0, s_switches_old
                              AND s0, 20                                  ; Pin 6 = Bit 5 Sustain Upper
                              LOAD s1, s3_key_status
                              AND s1, 20                                  ; Pin 6 = Bit 5 Sustain Upper
                              XOR s0, s1                                  ; geändertes Bit jetzt auf 1
                              CALL NZ, handle_sustain_upper_changed
                              ;
                              FETCH s0, s_switches_old
                              AND s0, 10                                  ; Pin 5 = Bit 4 Sostenuto Upper
                              LOAD s1, s3_key_status
                              AND s1, 10                                  ; Pin 5 = Bit 4 Sostenuto Upper
                              XOR s0, s1                                  ; geändertes Bit jetzt auf 1
                              CALL NZ, handle_sosten_upper_changed
                              ;
                              FETCH s0, s_switches_old
                              AND s0, 08                                  ; Pin 4 = Bit 3 Sustain Lower
                              LOAD s1, s3_key_status
                              AND s1, 08                                  ; Pin 4 = Bit 3 Sustain Lower
                              XOR s0, s1                                  ; geändertes Bit jetzt auf 1
                              CALL NZ, handle_sustain_lower_changed
                              ;
                              FETCH s0, s_switches_old
                              AND s0, 04                                  ; Pin 3 = Bit 2 Sostenuto Lower
                              LOAD s1, s3_key_status
                              AND s1, 04                                  ; Pin 3 = Bit 2 Sostenuto Lower
                              XOR s0, s1                                  ; geändertes Bit jetzt auf 1
                              CALL NZ, handle_sosten_lower_changed
                              ;
                              STORE s3_key_status, s_switches_old
                              RETURN 
                              ;
                              ; aktuelles Switch-Bit in s1
handle_sustain_upper_changed: 
                              LOAD manual_select, 00
                              JUMP handle_sustain_changed_0
handle_sustain_lower_changed: 
                              LOAD manual_select, 01
    handle_sustain_changed_0: 
                              CALL NZ, test_s1_set_s2                     ; s2 auf $7F wenn ein Switch-Bit gesetzt ist
                              LOAD idx_ptr, s_sustain_upr
                              ADD idx_ptr, manual_select
                              STORE s2, (idx_ptr)
                              LOAD s1, 40                                 ; Sustain-Controller
                              JUMP local_send_fs
                              ;
                              ;
 handle_sosten_upper_changed: 
                              LOAD manual_select, 00
                              JUMP handle_sosten_changed_0
 handle_sosten_lower_changed: 
                              LOAD manual_select, 01
     handle_sosten_changed_0: 
                              ;
                              CALL NZ, test_s1_set_s2                     ; s2 auf $7F wenn ein Switch-Bit gesetzt ist
                              LOAD idx_ptr, s_sosten_upr
                              ADD idx_ptr, manual_select
                              STORE s2, (idx_ptr)
                              LOAD s1, 45                                 ; HOLD2-Sostenuto-Controller
                              JUMP local_send_fs
                              ;
              test_s1_set_s2: 
                              LOAD s2, 00
                              TEST s1, 3C
                              RETURN Z
                              LOAD s2, 7F
                              RETURN 
                              ;
                              ; Fußschalter-MIDI senden. Hier kommen wir nur hin, wenn sich etwas geändert hat.
                              ; aktueller Schalterzustand in s2, Controller in s1, Kanal in manual_select
               local_send_fs: 
                              INPUT s0, SPI_MIDIOPT                       ; Bit 7 (MSB): USE SOST/SUSTAIN
                              AND s0, 80
                              RETURN Z
                              FETCH s0, s_midich                          ; eingestellter Kanal
                              ADD s0, manual_select                       ; Manual-Nummer addieren
                              OR s0, B0
                              CALL midi_tx_both
                              LOAD s0, s1                                 ; Controllernummer
                              CALL midi_tx_both
                              LOAD s0, s2
                midi_tx_both: 
                              CALL midi_out_waitbuf                       ; benutzt s1!
                              OUTPUT s0, MIDI_TX_1                        ; TX Midi auf beiden Ports
                              OUTPUT s0, MIDI_TX_2
                              LOAD s0, 00
                              STORE s0, s_midi_activesensing              ; Active Sensing Reset
                              RETURN 
                              ;
                              ;
                              ; ###############################################################################
                              ; ################################ SCAN LOOP ####################################
                              ; ###############################################################################
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; FATAR SCAN und PEDAL
                              ; Inc 4024, Pin 1 (D0) - Key-Select innerhalb Gruppe, 0..7
                              ; Reset 4024, Pin 2 (D1)
                              ; Inc 4017, Pin 5 (D4) - Gruppen-Select 0..7
                              ; Reset 4017, Pin 6 (D5)
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
          local_scan_manuals: 
                              ; Tastenzustand aktuelle Taste ermitteln und behandeln
                              CALL auxport_sr_load                        ; SR-Daten Pedal übernehmen
                              CALL fatar_allreset                         ; Reset 4024, Pin 2 (D1), Reset 4017, Pin 6 (D5)
                              LOAD s0, 00                                 ; Start mit Taste 0
                              STORE s0, s_key_matrix
                              STORE s0, s_group_matrix
                              LOAD scan_number, FF
             local_scan_loop: ; ca. 640 µs Gesamtzeit
                              ;
                              ADD scan_number, 01                         ; nächste Taste
                              COMPARE scan_number, c_maxkeys_plus_one     ; alle Tasten abgefragt?
                              RETURN Z
                              CALL local_scan_key                         ; derzeitigen Tastenzustand holen und eintragen
                              ;
                              CALL auxport_clock                          ; Pedal Puls für nächste Taste
                              ;
                              CALL fatar_keyclock                         ; Inc 4017, Pin 5 (D4)
                              FETCH s0, s_key_matrix
                              ADD s0, 01
                              STORE s0, s_key_matrix
                              COMPARE s0, 08
                              JUMP NZ, local_scan_loop
                              ;
                              LOAD s0, 00
                              STORE s0, s_key_matrix
                              CALL fatar_keyreset                         ; Reset 4017, Pin 6 (D5)
                              CALL fatar_groupclock                       ; Inc 4024, Pin 1 (D0)
                              FETCH s0, s_group_matrix
                              ADD s0, 01
                              STORE s0, s_group_matrix
                              JUMP local_scan_loop
                              ;
                              ; ###############################################################################
                              ; ############################### TASTENABFRAGE #################################
                              ; ###############################################################################
                              ;
                              ; Manual-Tastenzustände in die RAM-Seiten c_page_keystatusX eintragen
                              ; 0 = Taste AUS
                              ; 1 = Kontakt 1. Schließer
                              ; 2 = Kontakt 2. Schließer
                              ; 3 = beide Kontakte, Taste voll gedrückt
                              ;
                              ; Tastenzustand in s3_key_status holen - abhängig vom Scan-Board
             local_get_upper: 
                              INPUT s3_key_status, SCANPIO3               ; 1. Schließer
                              INPUT s1, SCANPIO4                          ; 2. Schließer
                              SL0 s1
                              OR s3_key_status, s1
                              RETURN 
             local_get_lower: 
                              INPUT s3_key_status, SCANPIO7               ; 1. Schließer
                              INPUT s1, SCANPIN8                          ; 2. Schließer
                              SL0 s1
                              OR s3_key_status, s1
                              RETURN 
             local_get_pedal: 
                              INPUT s3_key_status, AUXPIO5                ; Pedalkontakt
                              XOR s3_key_status, 01                       ; ist jetzt 0 oder 1, keine Dynamik!
                              LOAD s1, s3_key_status
                              SL0 s1                                      ; 2. Kontakt simulieren
                              OR s3_key_status, s1
                              RETURN 
                              ;
                              ; ###############################################################################
                              ; ######################### LOCAL KEYBOARD HANDLING #############################
                              ; ################## sollte bei allen Scan-Boards gleich sein ##################
                              ; ###############################################################################
                              ;
                              ; Split Mode:
                              ; 0 = Pedal to Lower
                              ; 1 = Lower to Upper
                              ; 2 = Pedal to Upper
                              ; 3 = Lower to Upper +1 Oktave
                              ; 4 = Lower to Upper +2 Oktaven
                              ; 5 = Add Pedal to Lower
                              ;
                              ;
                              ;
              local_scan_key: ; gemeinsame Abfrage Upper/Lower/Pedal
                              CALL clock_delay
                              FETCH s8_msb_smode, s_splitmode
                              FETCH s7_lsb_spoint, s_splitpoint
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; UPPER SPLIT
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
            local_scan_upper: 
                              CALL local_get_upper
                              ; Tastenzustand jetzt in s3_key_status. Split-Modus ermitteln
                              FETCH s0, s_split_on
                              AND s0, 03
                              ; COMPARE s0, 00
                              JUMP Z, local_scan_upper_unsplitted
                              ;
                              COMPARE s8_msb_smode, 00
                              JUMP Z, local_scan_upper_unsplitted         ; betrifft uns nicht, nur Lower
    local_scan_upper_split_1: 
                              COMPARE s8_msb_smode, 01                    ; 1 = Lower to Upper
                              JUMP NZ, local_scan_upper_split_2
                              ; wenn unterhalb Splitpunkt, auf LOWER schreiben
                              COMPARE scan_number, s7_lsb_spoint
                              JUMP NC, local_scan_upper_unsplitted        ; JUMP wenn scan_number > splitpoint
                              ; unterhalb Splitpunkt ausgeführt:
                              CALL local_write_lower
                              ; kein LOWER abfragen, würde RAM wieder löschen
                              JUMP local_scan_pedal                       ; PEDAL abfragen und RETURN
                              ;
    local_scan_upper_split_2: 
                              COMPARE s8_msb_smode, 02                    ; 2 = Pedal to Upper
                              JUMP NZ, local_scan_upper_split_3
                              ; wenn unterhalb Splitpunkt, auf PEDAL schreiben
                              COMPARE scan_number, s7_lsb_spoint
                              JUMP NC, local_scan_upper_unsplitted        ; JUMP wenn scan_number > splitpoint
                              ; unterhalb Splitpunkt ausgeführt:
                              ; kein LOWER und PEDAL abfragen, würde RAM wieder löschen
                              JUMP local_write_pedal                      ; und RETURN
                              ;
    local_scan_upper_split_3: 
                              COMPARE s8_msb_smode, 03                    ; 3 = Lower to Upper +1 Oktave
                              JUMP NZ, local_scan_upper_split_4
                              ; wenn unterhalb Splitpunkt, auf LOWER schreiben, 1 Oktave darüber
                              COMPARE scan_number, s7_lsb_spoint
                              JUMP NC, local_scan_upper_unsplitted        ; JUMP wenn scan_number > splitpoint
                              ; unterhalb Splitpunkt ausgeführt:
                              ADD scan_number, 12'd                       ; 1 Oktave addieren
                              CALL local_write_lower
                              SUB scan_number, 12'd                       ; wieder auf alten Wert
                              ; kein LOWER abfragen, würde RAM wieder löschen. Weiter mit PEDAL
                              JUMP local_scan_pedal                       ; PEDAL abfragen und RETURN
                              ;
    local_scan_upper_split_4: 
                              COMPARE s8_msb_smode, 04                    ; 4 = Lower to Upper +2 Oktaven
                              JUMP NZ, local_scan_upper_unsplitted
                              ; wenn unterhalb Splitpunkt, auf LOWER schreiben, 2 Oktaven darüber
                              COMPARE scan_number, s7_lsb_spoint
                              JUMP NC, local_scan_upper_unsplitted        ; JUMP wenn scan_number > splitpoint
                              ; unterhalb Splitpunkt ausgeführt:
                              ADD scan_number, 24'd                       ; 1 Oktave addieren
                              CALL local_write_lower
                              SUB scan_number, 24'd                       ; wieder auf alten Wert
                              ; kein LOWER abfragen, würde RAM wieder löschen. Weiter mit PEDAL
                              JUMP local_scan_pedal                       ; PEDAL abfragen und RETURN
                              ;
 local_scan_upper_unsplitted: 
                              ; Split ist OFF oder scan_number oberhalb Splitpunkt
                              ; weiter mit normaler Reihenfolge
           local_write_upper: 
                              CALL local_scan_prep_upper                  ; RAM-Adresse setzen, transp. Key in s0
                              OUTPUT s3_key_status, RAM_WRDATA            ; Upper ins RAM schreiben
                              OUTPUT s3_key_status, UPPER_STROBE          ; Schreibimpuls, s0 egal
                              CALL local_states
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; LOWER SPLIT
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
            local_scan_lower: 
                              CALL local_get_lower
                              ; Split-Modus ermitteln
                              FETCH s0, s_split_on
                              AND s0, 03
                              ; COMPARE s0, 00
                              JUMP Z, local_scan_lower_unsplitted
                              ;
                              ; LOWER nur abfragen bei 0 und 5
                              COMPARE s8_msb_smode, 00
                              JUMP Z, local_scan_lower_0_5
                              COMPARE s8_msb_smode, 05
                              JUMP Z, local_scan_lower_0_5
                              RETURN 
                              ;
                              ; 0 = Pedal to Lower und 5 = Add Pedal to Lower behandeln
        local_scan_lower_0_5: 
                              COMPARE scan_number, s7_lsb_spoint
                              JUMP NC, local_scan_lower_unsplitted        ; JUMP wenn scan_number > splitpoint
                              ;
                              ; unterhalb Splitpunkt ausgeführt:
                              FETCH s0, s_splitmode
                              COMPARE s0, 05
                              JUMP Z, local_add_pedal
                              JUMP local_write_pedal                      ; und RETURN
                              ;
             local_add_pedal: 
                              CALL local_write_lower
                              JUMP local_write_pedal
                              ;
                              ;
 local_scan_lower_unsplitted: 
                              ; Split ist OFF oder scan_number oberhalb Splitpunkt
                              ; weiter mit normaler Reihenfolge
                              CALL local_write_lower                      ;
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
            local_scan_pedal: 
                              ; PEDAL nicht abfragen bei 5
                              COMPARE s8_msb_smode, 05
                              RETURN Z
                              COMPARE scan_number, c_maxbasskeys
                              RETURN NC                                   ; wenn scan_number > c_maxbasskeys
                              CALL local_get_pedal
                              ; Zustand des gescannten Kontakts:
                              ; 0 = offen, 3 = beide
           local_write_pedal: 
                              CALL local_scan_prep_pedal                  ; RAM-Adresse setzen, transp. Key in s0
                              OUTPUT s3_key_status, RAM_WRDATA            ; Pedal ins RAM schreiben
                              OUTPUT s3_key_status, PEDAL_STROBE          ; Schreibimpuls, s0 egal
                              JUMP local_states                           ; Ende und zurück
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
           local_write_lower: 
                              CALL local_scan_prep_lower                  ; RAM-Adresse setzen, transp. Key in s0
                              OUTPUT s3_key_status, RAM_WRDATA            ; Lower ins RAM schreiben
                              OUTPUT s3_key_status, LOWER_STROBE          ; Schreibimpuls, s0 egal
                              JUMP local_states
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; LOCAL SCAN RAM ADDR PREP & TRANSPOSE & UPPER/LOWER OCTAVE SHIFT
                              ; RAM-Adresse setzen für Tastennummern 12..121, ohne Schreibimpuls
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
       local_scan_prep_upper: 
                              LOAD manual_select, 00                      ; für MIDI OUTPUT Upper
                              CALL local_scan_transpose_s0
                              ; Falls Bits 4 in SPI_SPLITON gesetzt, Oktav-Shift ausführen
                              FETCH s1, s_split_on
                              TEST s1, 10                                 ; AND -> Z-Flag, Bit 4
                              JUMP Z, local_scan_prep_2                   ; Überhaupt kein Octave Shift?
                              ; Shift Upper -1 Oktave wenn manual_select = 0
                              JUMP local_scan_prep_sub12
                              ;
       local_scan_prep_lower: 
                              LOAD manual_select, 01                      ; für MIDI OUTPUT Lower
                              CALL local_scan_transpose_s0
                              ; Falls Bits 5 in SPI_SPLITON gesetzt, Oktav-Shift ausführen
                              FETCH s1, s_split_on
                              TEST s1, 20                                 ; AND -> Z-Flag, Bit 5
                              JUMP Z, local_scan_prep_2                   ; Wenn kein Lower Octave Shift
                              ; Shift Lower -1 Oktave wenn manual_select = 1
                              ; JUMP local_scan_prep_sub12
                              ;
       local_scan_prep_sub12: 
                              SUB s0, 0C
           local_scan_prep_2: 
                              STORE s0, s_midi_localkey                   ; wird für MIDI Send gebraucht
                              COMPARE s0, 40                              ; ist auf zwei Seiten aufgeteilt
                              LOAD s1, c_page_keystatus1
                              JUMP C, local_scan_prep_3                   ; wenn kleiner 63, nicht addieren
                              SUB s0, 40
                              ADD s1, 01
           local_scan_prep_3: 
                              OUTPUT s1, RAM_PAGE                         ; MPX-RAM Page
                              OUTPUT s0, RAM_ADDR
                              RETURN 
                              ;
       local_scan_prep_pedal: 
                              LOAD manual_select, 02                      ; für MIDI OUTPUT Pedal
                              CALL local_scan_transpose_s0
                              JUMP local_scan_prep_2
                              ;
     local_scan_transpose_s0: 
                              FETCH s1, s_keytranspose
                              LOAD s0, scan_number
                              ADD s0, s1
                              ADD s0, c_midi_offset                       ; transp. Key in s0
                              RETURN 
                              ;
                              ;
                              ; ##############################################################################
                              ; ############# MIDI-Routinen für Scan-Events bei Keyboard-Abfrage #############
                              ; ################## sollte bei allen Scan-Boards gleich sein ##################
                              ; ##############################################################################
                              ;
                              ; -------------------------- Mealy-Zustandsautomat -----------------------------
                              ;
                              ; State in s2: c_state_idle, c_state_forward, c_state_stopped, c_state_reverse
                              ;
                              ; ------------------------------------------------------------------------------
                              ;
                local_states: 
                              ; Zustand der State Machine holen, wg. Geschwindigheit hier separat
                              CALL local_read_timerstate_s2               ; Timer-State dieser Taste in s2
                              ; auf derzeitigen Zustand verteilen
                              COMPARE s2, c_state_idle
                              JUMP Z, local_state_idle
                              COMPARE s2, c_state_forward
                              JUMP Z, local_state_forward
                              COMPARE s2, c_state_reverse
                              JUMP Z, local_state_reverse
                              JUMP local_state_stopped                    ; s2 kann hier nur noch c_state_stopped sein
                              ;
                              ; ------------------------------- State "Idle" ---------------------------------
                              ;
            local_state_idle: 
                              ;
                              COMPARE s3_key_status, c_key_idle           ; Hat Taste mindestens ersten Kontakt erreicht?
                              JUMP NZ, local_state_forward                ; wenn ja, in Counting-State gehen
                              ; Dyntimer löschen
                              LOAD s0, FF
                              JUMP local_write_dyntimer_s0
                              ;
                              ; ------------------------------ State "Counting" ------------------------------
                              ;
         local_state_forward: 
                              COMPARE s3_key_status, c_key_dirty          ; nur 2. Kontakt?
                              JUMP Z, local_state_stopped_0               ; 2. Kontakt erreicht, 1. evt. fehlerhaft
                              COMPARE s3_key_status, c_key_on
                              JUMP Z, local_state_stopped_0               ; 1. und 2. Kontakt erreicht: neuer State, MIDI senden
       local_state_forward_0: ; Nur 1. Kontakt erreicht: Solange Taste in Bewegung ist, Timerwert verringern
                              CALL local_read_dyntimer_s0
                              SUB s0, 01
                              CALL Z, load_s0_with_01                     ; wenn 0, auf 1 setzen
                              CALL local_write_dyntimer_s0                ; Timer mit s0 neu setzen
                              COMPARE s2, c_state_forward
                              RETURN Z                                    ; State nicht neu setzen, wenn bereits Counting
                              LOAD s2, c_state_forward                    ; wenn noch nicht gestartet, neuer Timer-State
                              JUMP local_write_timerstate_s2              ; neuer Timer-State: c_state_forward
                              ;
                              ;
                              ; ------------------------------ State "Stopped" -------------------------------
                              ;
         local_state_stopped: ; 2. Kontakt erreicht
                              ; Zähler-Ende erreicht, sehr langsamer Tastendruck
                              COMPARE s3_key_status, c_key_idle
                              JUMP Z, local_state_reverse                 ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                              COMPARE s3_key_status, c_key_moving
                              JUMP Z, local_state_reverse                 ; Taste hat zweiten Kontakt verlassen, bewegt sich zurück
       local_state_stopped_0: 
                              COMPARE s2, c_state_stopped                 ; bereits gestoppt und gesendet?
                              RETURN Z                                    ; nichts machen, wenn bereits gestoppt
                              LOAD s2, c_state_stopped
                              CALL local_write_timerstate_s2              ; neuer Timer-State: c_state_stopped
                              JUMP local_states_on                        ; Dynamik-Wert holen, MIDI ON senden und Ende
                              ;
                              ; ------------------------------ State "Reverse" -------------------------------
                              ;
         local_state_reverse: 
                              COMPARE s3_key_status, c_key_idle
                              JUMP Z, local_state_reverse_off             ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                              COMPARE s3_key_status, c_key_on
                              JUMP Z, local_state_reverse_retrig          ; Taste hat Endkontakt nochmal erreicht
                              COMPARE s3_key_status, c_key_dirty
                              JUMP Z, local_state_reverse_retrig          ; Taste hat Endkontakt nochmal erreicht
                              COMPARE s2, c_state_reverse                 ; bereits c_state_reverse?
                              RETURN Z                                    ; dann zurück
                              ; erstmals auf dem Rückweg
                              LOAD s2, c_state_reverse
                              CALL local_write_timerstate_s2              ; neuer Timer-State: c_state_reverse
                              JUMP local_states_off                       ; MIDI OFF senden und Ende
                              ;
     local_state_reverse_off: ; Taste wurde erstmals als "voll losgelassen" festgestellt
                              LOAD s2, c_state_idle                       ; nächster Timer-State: Idle, OFF gesendet
                              JUMP local_write_timerstate_s2
                              ;
  local_state_reverse_retrig: ; Retrigger mit gleichem Dynamik-Wert wenn erneut ON
                              LOAD s2, c_state_stopped                    ; nächster Timer-State: Stopped
                              CALL local_write_timerstate_s2
                              JUMP local_states_on                        ; Dynamik-Wert holen, MIDI ON senden und Ende
                              ;
                              ;
                              ; ------------------------------------------------------------------------------
                              ; Lokale Dyntimer und States lesen/schreiben
                              ; ------------------------------------------------------------------------------
                              ;
     local_write_dyntimer_s0: ; zu schreibende Daten in s0, Taste in scan_number
                              LOAD page_select, c_page_dyntimer
                              OUTPUT scan_number, RAM_ADDR
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD idx_ptr, manual_select                 ; 0 oder 1
                              ADD idx_ptr, c_strobe_mask
                              OUTPUT s0, (idx_ptr)                        ; Upper, Lower oder Pedal Strobe
                              RETURN 
                              ;
      local_read_dyntimer_s0: ; Taste in scan_number, gelesene Daten später in s0
                              LOAD page_select, c_page_dyntimer
                              OUTPUT scan_number, RAM_ADDR
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD idx_ptr, manual_select                 ; 0 oder 1
                              ADD idx_ptr, c_read_mask
                              INPUT s0, (idx_ptr)                         ; Upper, Lower oder Pedal Read
                              RETURN                                      ; Zustand in s0
                              ;
   local_write_timerstate_s2: ; zu schreibende Daten in s2, Taste in scan_number
                              LOAD page_select, c_page_timerstates
                              OUTPUT scan_number, RAM_ADDR
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD idx_ptr, manual_select                 ; 0 oder 1
                              ADD idx_ptr, c_strobe_mask
                              OUTPUT s2, (idx_ptr)                        ; Upper, Lower oder Pedal Strobe
                              RETURN 
                              ;
    local_read_timerstate_s2: 
                              LOAD page_select, c_page_timerstates
                              OUTPUT scan_number, RAM_ADDR
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD idx_ptr, manual_select                 ; 0 oder 1
                              ADD idx_ptr, c_read_mask
                              INPUT s2, (idx_ptr)                         ; Timer-State dieser Taste in s2
                              RETURN 
                              ;
                              ; ------------------------------------------------------------------------------
                              ;
             local_states_on: 
                              ; Dynamik-Kurve durch variables Timer-Dekrement, simuliert 1/t
                              ; Liefert Maximalwerte, die kleiner als 255 sein können
                              ; Hier wird MIDI-Wert deshalb auf etwas über /2 korrigiert
                              ; Dynamik-Wert noch in s0
                              COMPARE manual_select, 02
                              JUMP Z, local_states_on_pedal
                              CALL local_read_dyntimer_s0
                              SR0 s0                                      ; 0..31
                              ADD s0, c_midi_mindyn                       ; MIDI-Minimalwert
                              COMPARE s0, 7F                              ; Carry bei A - B < 0
                              CALL NC, load_s0_with_7F
                              STORE s0, s_last_key_velocity               ; letzte gemessene ON-Dynamik
                              JUMP local_states_out
                              ;
       local_states_on_pedal: 
                              LOAD s0, 3F                                 ; Pedal hat keine Dynamik, nur 1 Bit (0) im RAM
                              JUMP local_states_out
                              ;
                              ;
                              ; ------------------------------------------------------------------------------
                              ;
                              ; ##### START local_states_on ALT:
                              COMPARE manual_select, 02
                              JUMP Z, local_states_on_pedal
                              CALL local_read_dyntimer_s0
                              ADD s0, 10                                  ; MIDI-Minimalwert * 2
                              CALL C, load_s0_with_FF                     ; bei Überlauf auf 255 begrenzen
                              FETCH s1, s_velocityfac                     ; 0..63, von SPI_CONFIG_1 Bits 7..2
                              SR0 s1                                      ; 0..31
                              ADD s1, 84                                  ; 80 = halbierter Wert in s8_msb_smode
                              CALL mult_soft_s0_s1                        ; s0 x s1 => s8_msb_smode, s7_lsb_spoint
                              LOAD s0, s8_msb_smode
                              COMPARE s0, 7F                              ; Carry bei A - B < 0
                              CALL NC, load_s0_with_7F
                              STORE s0, s_last_key_velocity               ; letzte gemessene ON-Dynamik
                              JUMP local_states_out
                              ; ##### ENDE local_states_on ALT
                              ;
                              ; ------------------------------------------------------------------------------
                              ;
            local_states_off: 
                              LOAD s0, 00
                              ; s_midi_localkey und s_midi_localdyn senden
            local_states_out: 
                              STORE s0, s_midi_localdyn
                              ; s_midi_localdyn für aktuelles Manual schreiben, Taste in s_midi_localkey
                              CALL ramwrite_localdyn_121
                              ; CANCEL-Pins abfragen, unterdrücken MIDI-Senden
                              INPUT s0, PRESCANPIN                        ; Bit 0 ist Cancel MIDI Kanal OM
                              XOR s0, FF                                  ; invertiert!
                              AND s0, 03
                              SUB s0, 01
                              COMPARE s0, manual_select
                              RETURN Z
                              ; Manual in manual_select, On/Off-Dynamik in s_midi_localdyn
                              ; immer auch an SAM5504 dh. MIDI_TX_2 senden
                              FETCH s0, s_midich                          ; eingestellter Kanal
                              LOAD s1, manual_select                      ; Manual-Nummer addieren
                              ADD s0, s1
                              OR s0, 90
                              CALL midi_tx_both
                              FETCH s0, s_midi_localkey
                              CALL midi_tx_both
                              ;
                              FETCH s0, s_midi_localdyn                   ; gemessene Dynamik
                              JUMP midi_tx_both                           ; 0 = OFF senden
                              ;
                              ; ##############################################################################
                              ;
                              ; Multiplier 8x8 unsigned, s0 x s1, Ergebnis in msb und lsb, s0 wird nicht verändert
                              ;
              square_soft_s0: ; s0 squared => s8_msb_smode, s7_lsb_spoint
                              LOAD s1, s0
             mult_soft_s0_s1: ; s0 x s1 => s8_msb_smode, s7_lsb_spoint
                              LOAD s8_msb_smode, 00
                              LOAD idx_ptr, 08                            ; Schleifenzähler
                   mult_loop: 
                              SR0 s1
                              JUMP NC, mult_shift
                              ADD s8_msb_smode, s0
                  mult_shift: 
                              SRA s8_msb_smode
                              SRA s7_lsb_spoint
                              SUB idx_ptr, 01
                              JUMP NZ, mult_loop
                              RETURN 
                              ;
                              ;
             load_s0_with_FF: 
                              LOAD s0, FF
                              RETURN 
                              ;
             load_s0_with_7F: 
                              LOAD s0, 7F
                              RETURN 
                              ;
             load_s0_with_01: 
                              LOAD s0, 01
                              RETURN 
                              ;
                              ; ###############################################################################
                              ; ########################## Eigene Schleife EVENT-LOOP #########################
                              ; ###############################################################################
                              ;
                              ; Variablen unabhängig von Scan-Routine benutzt
                              ; scan_number: hier Adresse des MPX-RAMs,
                              ; event_key: Adresse der 121-Tasten-RAMs
                              ;
              event_handling: 
                              LOAD s0, 00                                 ; Start mit Taste 0
                              STORE s0, s_keycount_upper
                              STORE s0, s_keycount_lower
                              STORE s0, s_keycount_pedal
                              STORE s0, s_pedal_on                        ; Speicher für gedrückte Taste
                              LOAD event_key, c_midi_firstkey             ; Start mit Taste 12
                  event_loop: ; ca. 580 µs Gesamtzeit
                              CALL event_setcontacts
                              ADD event_key, 01                           ; nächste Taste
                              COMPARE event_key, c_midi_lastkey_plus_one  ; alle Tasten abgefragt?
                              JUMP NZ, event_loop
                              ;
                              LOAD s0, 01
                              OUTPUT s0, PED_ACC_ENA                      ; normal ON
                              FETCH s0, s_pedal_on
                              OUTPUT s0, PEDAL_DOWN                       ; ist '1' wenn irgendeine Pedaltaste gedrückt ist
                              ;
                              ; Pedal-Click, simpel
                              ;
                              COMPARE s0, 00
                              JUMP Z, event_loop_reset_pedalnoise         ; wenn kein Pedal gedrückt
                              ;
                              INPUT s1, SPI_CLICKLEN
                              AND s1, 0F
                              COMPARE s1, 00
                              JUMP Z, event_loop_nopedalclick
                              ADD s1, 04
     event_loop_nopedalclick: 
                              FETCH s0, s_pedal_noisecounter
                              COMPARE s0, s1
                              JUMP Z, event_loop_pedal_noiseoff
                              ADD s0, 01
                              STORE s0, s_pedal_noisecounter
                              INPUT s0, RND_NUMBER
                              AND s0, 01
                              OUTPUT s0, PED_ACC_ENA                      ; Random Noise ausgeben
                              RETURN 
                              ;
 event_loop_reset_pedalnoise: 
                              LOAD s0, 00
                              STORE s0, s_pedal_noisecounter
   event_loop_pedal_noiseoff: 
                              LOAD s0, 01
                              OUTPUT s0, PED_ACC_ENA                      ; normal ON
                              RETURN 
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; +++++++++++ Wird mit allen event_key-Tastennummern aufgerufen ++++++++++++++++
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                event_dyn2s1: 
                              LOAD s1, 00                                 ; Default OFF
                              COMPARE s0, 00
                              RETURN Z                                    ; wenn Null, s1 nicht ändern
                              OR s1, 01                                   ; ist mindestens langsam
                              COMPARE s0, c_dyn_threshold                 ; Dynamikschwelle
                              RETURN C                                    ; war kleiner
                              OR s1, 03                                   ; ist schnell
                              RETURN 
                              ;
          event_dyn2s1_pedal: 
                              LOAD s1, 00
                              COMPARE s0, 00
                              RETURN Z                                    ; wenn Null, s1 nicht ändern
                              OR s1, 03                                   ; ist ON
                              RETURN 
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; event_setcontacts wird aus Event-Loop aufgerufen
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
           event_setcontacts: 
                              INPUT s0, SPI_CONFIG_1                      ; Early-Action-Mode?
                              TEST s0, 01                                 ; AND -> Z-Flag
                              JUMP NZ, event_get_local_early_on           ; Wenn Early Action ON
                              ;
          event_get_localdyn: 
                              ; 3 Bytes Local-Dynamik von event_key lesen und wandeln
                              CALL event_rd_localdyn_121                  ; ermittelte Dynamik holen
                              ; Dynamik in Tastenzustand umrechnen
                              FETCH s0, s_upper_localdyn
                              CALL event_dyn2s1
                              STORE s1, s_keystatus_upper
                              FETCH s0, s_lower_localdyn
                              CALL event_dyn2s1
                              STORE s1, s_keystatus_lower
                              FETCH s0, s_pedal_localdyn
                              CALL event_dyn2s1_pedal
                              STORE s1, s_keystatus_pedal
                              ; Umgerechneter Tastenzustand jetzt in s_keystatus_upper, s_keystatus_lower, s_keystatus_pedal
                              JUMP event_setcontacts_0
                              ;
    event_get_local_early_on: 
                              CALL event_rd_keystatus_121                 ; direkten Tastenzustand holen
                              ; Direkter Tastenzustand jetzt in s_keystatus_upper, s_keystatus_lower, s_keystatus_pedal
                              FETCH s0, s_keystatus_upper
                              COMPARE s0, 00
                              JUMP Z, event_get_local_early_on_0          ; wenn OFF
                              FETCH s0, s_last_key_velocity               ; letzte gemessene Dynamik
                              CALL event_dyn2s1
                              STORE s1, s_keystatus_upper
                              ;
  event_get_local_early_on_0: 
                              FETCH s0, s_keystatus_lower
                              COMPARE s0, 00
                              JUMP Z, event_get_local_early_on_1          ; wenn OFF
                              FETCH s0, s_last_key_velocity               ; letzte gemessene Dynamik
                              CALL event_dyn2s1
                              STORE s1, s_keystatus_lower
  event_get_local_early_on_1: 
         event_setcontacts_0: 
                              CALL event_rd_mididyn_121                   ; 3 Bytes MIDI-Dynamik von event_key lesen
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; UPPER
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              FETCH s0, s_upper_mididyn
                              ; Dynamik in Tastenzustand umrechnen
                              CALL event_dyn2s1
                              LOAD s3_key_status, s1
                              ; Local Enable-Bit UPPER gesetzt?
                              INPUT s0, SPI_LOCALDISABLES
                              TEST s0, 01
                              JUMP NZ, event_exit_upper                   ; Local überspringen, wenn ON
                              FETCH s0, s_keystatus_upper
                              OR s3_key_status, s0
            event_exit_upper: 
                              LOAD manual_select, 00                      ; 0 = UPPER
                              CALL mpx_set_key
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; LOWER
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              FETCH s0, s_lower_mididyn
                              ; Dynamik in Tastenzustand umrechnen
                              CALL event_dyn2s1
                              LOAD s3_key_status, s1
                              ; Local Enable-Bit LOWER gesetzt?
                              INPUT s0, SPI_LOCALDISABLES
                              TEST s0, 02
                              JUMP NZ, event_exit_lower                   ; Local überspringen, wenn ON
                              ;
                              FETCH s0, s_keystatus_lower
                              OR s3_key_status, s0
            event_exit_lower: 
                              LOAD manual_select, 01                      ; 1 = LOWER
                              CALL mpx_set_key
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; PEDAL
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                              FETCH s0, s_pedal_mididyn
                              ; Dynamik in Tastenzustand umrechnen
                              CALL event_dyn2s1_pedal
                              LOAD s3_key_status, s1
                              ; Local Enable-Bit PEDAL gesetzt?
                              INPUT s0, SPI_LOCALDISABLES
                              TEST s0, 04
                              JUMP NZ, event_exit_pedal                   ; Local überspringen, wenn ON
                              ;
                              FETCH s0, s_keystatus_pedal
                              OR s3_key_status, s0
            event_exit_pedal: 
                              LOAD manual_select, 02                      ; 2 = PEDAL
                              JUMP mpx_set_key
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
       event_rd_localdyn_121: 
                              ; Local-Tastendynamik
                              ; Taste in event_key, gelesene Dynamik danach in s_xxx_localdyn
                              LOAD s0, event_key
                              LOAD page_select, c_page_localdyn1
                              CALL adjust_page_select
                              OUTPUT s0, RAM_ADDR                         ; Tastennummer in s0
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD s0, s0                                 ; Delay!
                              INPUT s0, RD_PEDAL
                              STORE s0, s_pedal_localdyn
                              INPUT s0, RD_LOWER
                              STORE s0, s_lower_localdyn
                              INPUT s0, RD_UPPER
                              STORE s0, s_upper_localdyn
                              RETURN                                      ; Zustand in s0
                              ;
        event_rd_mididyn_121: 
                              ; MIDI-Tastenzustand
                              ; Taste in event_key, gelesene Daten später in s_xxx_mididyn
                              LOAD s0, event_key
                              LOAD page_select, c_page_midirx1
                              CALL adjust_page_select
                              OUTPUT s0, RAM_ADDR                         ; Tastennummer in s0
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD s0, s0                                 ; Delay!
                              INPUT s0, RD_PEDAL
                              STORE s0, s_pedal_mididyn
                              INPUT s0, RD_LOWER
                              STORE s0, s_lower_mididyn
                              INPUT s0, RD_UPPER
                              STORE s0, s_upper_mididyn
                              RETURN                                      ; Zustand in s0
                              ;
      event_rd_keystatus_121: 
                              ; Taste in event_key, gelesene Daten danach in s0
                              LOAD s0, event_key
                              LOAD page_select, c_page_keystatus1
    event_rd_keystatus_121_0: 
                              CALL adjust_page_select
                              OUTPUT s0, RAM_ADDR                         ; Tastennummer in s0
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD s0, s0                                 ; Delay!
                              INPUT s0, RD_PEDAL
                              STORE s0, s_keystatus_pedal
                              INPUT s0, RD_LOWER
                              STORE s0, s_keystatus_lower
                              INPUT s0, RD_UPPER
                              STORE s0, s_keystatus_upper
                              RETURN                                      ; Zustand in s0
                              ;
   event_rd_oldkeystatus_121: 
                              ; Taste in event_key, gelesene Daten danach in s0 - NOCH NICHT BENUTZT!
                              LOAD s0, event_key
                              LOAD page_select, c_page_oldkeystatus1
                              JUMP event_rd_keystatus_121_0
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; für alle Manuale, muss wg. Noise-Timer-Update ständig aufgerufen werden
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                 mpx_set_key: 
                              ; Offsets und Split auswerten, virtuelle Tastenkontakte setzen
                              FETCH scan_number, s_gentranspose
                              ADD scan_number, event_key
                              COMPARE scan_number, c_gen_firstkey         ; Carry bei scan_number - 36?
                              RETURN C                                    ; Carry nicht gesetzt >=36
                              COMPARE scan_number, c_gen_lastkey_plus_one ; Carry bei scan_number - 97?
                              RETURN NC                                   ; Carry nicht gesetzt >=36
                              ; scan_number ist jetzt innerhalb 36..96
                              SUB scan_number, c_midi_offset              ; -36
                              ; scan_number ist jetzt innerhalb Generator-Bereich 0..60
                              COMPARE manual_select, 02                   ; Pedal?
                              JUMP Z, mpx_pedal
                              ; Letzten Kontakt-Zustand holen und merken. Wir verwenden diesen Wert
                              ; auch gleich zum Ermitteln der tatsächlich eingeschalteten Tasten.
                              CALL ramread_vcont_61
                              STORE s0, s_old_contacts
                              OR s0, s3_key_status
                              RETURN Z                                    ; nur wenn beide schon 0 sind
                              ;
                              COMPARE s0, 00                              ; alter Zustand vom letzen Durchlauf
                              JUMP Z, mpx_onoff
                              ; s_keycount_* bei tatsächlich klingenden Noten erhöhen
                              LOAD idx_ptr, manual_select                 ; 0 oder 1
                              ADD idx_ptr, s_keycount_upper               ; Basisadresse
                              FETCH s0, (idx_ptr)
                              ADD s0, 01
                              STORE s0, (idx_ptr)
                              ; scan_number für Split merken, Taste is ON
                              STORE scan_number, s_lastkey_on
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Zugriff auf die virtuellen Tastenkontakte
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                   mpx_onoff: 
                              ; Sostenuto-Flag setzen, wenn SOSTENUTO aktiv und KEY ON
                              COMPARE s3_key_status, 00
                              JUMP Z, mpx_off                             ; wenn aktueller Zustand OFF
                              FETCH s0, s_old_contacts                    ; letzter Zustand
                              COMPARE s0, 15'd
                              RETURN Z                                    ; ist bereits ganz an, nichts machen
                              CALL mpx_changed
                              COMPARE s3_key_status, 01
                              JUMP Z, mpx_slow                            ; nur 1. Kontakt, slow inc
                              JUMP mpx_fast                               ; 1. und/oder 2. Kontakt
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                 mpx_changed: 
                              ; Tastenkontaktzustand hat sich geändert.
                              ; Flag setzen, wenn Sostenuto-Pedal NICHT aktiv ist und Taste gedrückt wird.
                              ; Die dann gedrückten Tasten werden beim Ausschalten übersprungen, d.h. bleiben an
                              LOAD idx_ptr, manual_select                 ; Sostenuto-Pedal für dieses Manual?
                              ADD idx_ptr, s_sosten_upr
                              FETCH s0, (idx_ptr)
                              XOR s0, FF                                  ; invertieren
                              AND s0, s3_key_status
                              ; s0 ist EIN, wenn Taste EIN und Sostenuto AUS
                              CALL ramwrite_sostenutoflag_61
                              RETURN 
                     mpx_off: 
                              ; Taste ist erstmals aus.
                              LOAD idx_ptr, manual_select                 ; Sostenuto-Pedal für dieses Manual?
                              ADD idx_ptr, s_sosten_upr
                              FETCH s0, (idx_ptr)
                              COMPARE s0, 00
                              JUMP Z, mpx_off_0                           ; Sostenuto ist aus
                              CALL ramread_sostenutoflag_61
                              COMPARE s0, 00
                              ; die bei Sostenuto NICHT gedrückten Tasten beim Ausschalten überspringen
                              RETURN NZ
                   mpx_off_0: 
                              LOAD idx_ptr, manual_select                 ; Sustain-Pedal für dieses Manual?
                              ADD idx_ptr, s_sustain_upr
                              FETCH s0, (idx_ptr)
                              COMPARE s0, 00
                              RETURN NZ                                   ; nicht abschalten, Sustain ist aktiv
                              CALL reset_noisetimer
                              FETCH s0, s_old_contacts
                              AND s0, 15'd                                ; Noise wegmaskieren
                              LOAD s1, s0                                 ; Noise lassen
                              INPUT s2, SPI_CLICKLEN
                              AND s2, 0F
                              COMPARE s2, 05                              ; A < B -> C set, A >= B -> C cleared
                              CALL C, mpx_clear_s1                        ; ist kleiner als 8
                              SL0 s0                                      ; Zustand halbieren, halber Pegel
                              JUMP mpx_set_contacts
                mpx_clear_s1: 
                              LOAD s1, 00                                 ; KeyOff-Noise löschen wenn ClickLen < 8
                              RETURN 
                              ;
                    mpx_fast: 
                              ; Taste ist nicht offen
                              ; zweiter Kontakt geschlossen, voll gedrückt, fast inc to max.
                              CALL start_noisetimer_fastkey               ; starten, falls noch in Ruhe
                              FETCH s0, s_noisetimerval
                              COMPARE s0, FF                              ; Timer-Wert noch in s0
                              JUMP Z, mpx_fullon                          ; Klick beendet?
                              JUMP mpx_fullnoise
                    mpx_slow: 
                              ; Taste ist nicht offen
                              ; nur erster Kontakt geschlossen
                              CALL start_noisetimer_slowkey               ; ggf starten; aktueller Timer-Wert in s_noisetimerval
                              FETCH s0, s_noisetimerval
                              COMPARE s0, FF                              ; Timer-Wert noch in s0
                              JUMP Z, mpx_fullon                          ; Klick beendet?
                              COMPARE s0, FD                              ; Timer-Wert noch in s0
                              JUMP NC, mpx_halfon                         ; 2 ms vor Ende halber Steady-Pegel, JUMP wenn Timer-Wert in s0 > $FD
                              COMPARE s0, FB                              ; Timer-Wert noch in s0
                              JUMP NC, mpx_fullnoise                      ; 4 ms vor Ende voller Noise-Pegel, JUMP wenn Timer-Wert in s0 > $F9
               mpx_halfnoise: 
                              LOAD s0, 00                                 ; half level
                              LOAD s1, 07
                              JUMP mpx_set_contacts
               mpx_fullnoise: 
                              LOAD s0, 08                                 ; full level
                              LOAD s1, 07                                 ; all noise
                              JUMP mpx_set_contacts
                  mpx_halfon: 
                              LOAD s0, 07
                              LOAD s1, 00
                              JUMP mpx_set_contacts
                  mpx_fullon: 
                              LOAD s0, 0F                                 ; full
                              LOAD s1, 00                                 ; no noise
                              ; jump mpx_set_contacts
            mpx_set_contacts: 
                              ; Steady- (s0) und Noise-Anteil (s1) INPUT mpx-RAM schreiben
                              ; Tastennnummer in scan_number
                              ; Im Steady-Nibble s0: 0..7 Half Level, 8..15 Full Level (Bit 3)
                              ; in ein Byte packen und zum MPX-RAM schicken
                              ; in manual_select ist aktuell abgefragtes Manual
                              SL0 s1
                              SL0 s1
                              SL0 s1
                              SL0 s1
                              AND s0, 15'd
                              OR s0, s1
                              JUMP ramwrite_vcont_61
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                   mpx_pedal: 
                              ; kleine Sonderbehandlung für Pedal, hat keine Dynamik und keine Noise-Bits:
                              ; s3_key_status enthält 0 (Taste aus) oder anderen Wert (Taste an),
                              ; Falls sich neue Taste geändert hat, alte Taste löschen
                              ; Vorher gespielte Pedaltaste löschen, Nummer der neue Pedaltaste merken
                              ; manual_select enthält 2
                              ;
                              COMPARE s3_key_status, 00
                              JUMP Z, mpx_pedal_0                         ; Taste ist aus wenn 0
                              LOAD s3_key_status, 01                      ; nur zwei Zustände zulassen, hier ON
                              FETCH s0, s_pedal_on                        ; Speicher für gedrückte Taste
                              OR s0, s3_key_status
                              STORE s0, s_pedal_on                        ; kann innerhalb Pedalschleife '1' werden
                 mpx_pedal_0: 
                              ; get_state/set_state hier nicht benötigt, weil kein Noise berücksichtigt wird
                              LOAD s0, s3_key_status
                              JUMP ramwrite_vcont_61                      ; Taste in scan_number, Zustand in s0
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Werte in MPX/Scratch-RAM setzen mit aktuellem manual_select und scan_number
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
          adjust_page_select: 
                              COMPARE s0, 40                              ; ist auf zwei Seiten aufgeteilt
                              RETURN C                                    ; wenn kleiner 63, nicht addieren
                              SUB s0, 40
                              ADD page_select, 01
                              RETURN 
                              ;
    ramread_sostenutoflag_61: 
                              ; Sostenuto-Flag
                              ; Taste in scan_number, gelesene Daten später in s0
                              LOAD page_select, c_page_sostenutoflags
                              JUMP ramread_61
            ramread_vcont_61: ; Virtuelle Tastenkontakte
                              ; Taste in scan_number, gelesene Daten später in s0
                              LOAD page_select, c_page_vcontacts
                  ramread_61: 
                              ; Taste in scan_number, gelesene Daten später in s0
                              LOAD s0, scan_number
                  ramread_s0: 
                              ; Tasten-Adresse INPUT s0
                              OUTPUT s0, RAM_ADDR                         ; Tastennummer in s0
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD idx_ptr, manual_select                 ; 0 oder 1
                              ADD idx_ptr, c_read_mask
                              INPUT s0, (idx_ptr)                         ; Upper, Lower oder Pedal Read
                              RETURN                                      ; Zustand in s0
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                 ramwrite_s0: 
                              ; Tasten-Adresse INPUT s0
                              OUTPUT s0, RAM_ADDR
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page
                              LOAD idx_ptr, manual_select                 ; 0 oder 1
                              ADD idx_ptr, c_strobe_mask
                              OUTPUT s0, (idx_ptr)                        ; Upper, Lower oder Pedal Strobe
                              RETURN 
                              ;
                              ;
       ramwrite_localdyn_121: 
                              ; Scanned-RAM Dynamik
                              ; Taste in s_midi_localkey, s_midi_localdyn und manual_select
                              LOAD page_select, c_page_localdyn1
                              FETCH s0, s_midi_localdyn                   ; Dynamik dieser Taste
                              OUTPUT s0, RAM_WRDATA                       ; zu schreibende Dynamik in s0
                              FETCH s0, s_midi_localkey                   ; Local-Key in s0, geht von 12 bis 121
                              CALL adjust_page_select
                              JUMP ramwrite_s0
                              ;
           ramwrite_midi_121: 
                              ; Empfangsdaten, MIDI-Taste/Dynamik s_midi_data1, s_midi_data2 und manual_select ins RAM, 12..121
                              LOAD page_select, c_page_midirx1
                              FETCH s0, s_midi_data2                      ; Dynamik dieser Taste
                              OUTPUT s0, RAM_WRDATA                       ; zu schreibende Dynamik in s0
                              FETCH s0, s_midi_data1                      ; MIDI-Key in s0, geht von 12 bis 121
                              CALL adjust_page_select
                              JUMP ramwrite_s0
                              ;
   ramwrite_sostenutoflag_61: 
                              ; zu schreibende Daten in s0
                              LOAD page_select, c_page_sostenutoflags
                              JUMP ramwrite_61
           ramwrite_vcont_61: 
                              ; zu schreibende Daten in s0
                              LOAD page_select, c_page_vcontacts
                 ramwrite_61: 
                              ; zu schreibende Daten in s0, page_select muss gesetzt sein, 0..61
                              OUTPUT s0, RAM_WRDATA
                              LOAD s0, scan_number
                              JUMP ramwrite_s0
                              ;
                              ; ##############################################################################
                              ; Hilfsroutinen: Werte in Timer/Scratch-RAM lesen oder schreiben
                              ; manual_select = 0 für Upper, manual_select = 1 für Lower Manual
                              ; ##############################################################################
                              ;
    start_noisetimer_fastkey: 
                              ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                              CALL get_noisetimer
                              STORE s0, s_noisetimerval
                              COMPARE s0, 00
                              RETURN NZ                                   ; wenn bereits gestartet
                              ;
                              INPUT s1, RND_NUMBER                        ; zufällige Länge
                              AND s1, 03                                  ; 0 bis 3
                              FETCH s0, s_clicklen                        ; Timer-Startwert,  237..252
                              SUB s0, s1                                  ; um Zufallswert verlängern
                              JUMP set_noisetimer
                              ;
    start_noisetimer_slowkey: 
                              ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                              CALL get_noisetimer
                              STORE s0, s_noisetimerval
                              COMPARE s0, 00
                              RETURN NZ                                   ; wenn bereits gestartet
                              ;
                              INPUT s1, RND_NUMBER                        ; zufällige Länge
                              AND s1, 01                                  ; 0 oder 1
                              FETCH s0, s_clicklen                        ; Timer-Startwert,  237..255
                              SR1 s0                                      ; Timer-Startwert verdoppelt,  246..255
                              SUB s0, s1                                  ; um kleinen Zufallswert verlängern
                              SUB s0, 01                                  ; um kleinen Festwert verlängern
              set_noisetimer: 
                              LOAD page_select, c_page_noisetimer
                              JUMP ramwrite_61
            reset_noisetimer: 
                              LOAD s0, 00
                              JUMP set_noisetimer
              get_noisetimer: 
                              LOAD page_select, c_page_noisetimer
                              JUMP ramread_61
                              ;
                              ; ##############################################################################
                              ; Dynamik- und Noise-Timer für beide Manuale aktualisieren
                              ; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014
                              ; wird einmal pro Scan-Durchlauf aufgerufen, dauert ca. 52 µs
                              ; ##############################################################################
          update_noisetimers: 
                              LOAD page_select, c_page_noisetimer
                              OUTPUT page_select, RAM_PAGE                ; MPX-RAM Page Noise-Timer
                              LOAD scan_number, 00
                              ;
           update_timer_loop: 
                              OUTPUT scan_number, RAM_ADDR
                              ADD scan_number, 01
                              INPUT s0, RD_UPPER
                              COMPARE s0, 00
                              JUMP Z, update_timer_done1                  ; noch nicht gestartet
                              COMPARE s0, FF
                              JUMP Z, update_timer_done1                  ; bereits abgelaufen
                              ADD s0, 01
                              OUTPUT s0, RAM_WRDATA                       ; zu schreibende Daten in s0
                              LOAD s0, 00                                 ; NOP
                              OUTPUT s0, UPPER_STROBE
                              LOAD s0, 00                                 ; NOP
          update_timer_done1: 
                              INPUT s0, RD_LOWER
                              COMPARE s0, 00
                              JUMP Z, update_timer_done2                  ; noch nicht gestartet
                              COMPARE s0, FF
                              JUMP Z, update_timer_done2                  ; bereits abgelaufen
                              ADD s0, 01
                              OUTPUT s0, RAM_WRDATA                       ; zu schreibende Daten in s0
                              LOAD s0, 00                                 ; NOP
                              OUTPUT s0, LOWER_STROBE
          update_timer_done2: 
                              COMPARE scan_number, 64'd
                              JUMP NZ, update_timer_loop
                              RETURN 
                              ; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
                 allnotesoff: 
                              ; alle Töne, Flags und Timer löschen
                              LOAD s0, 00
                              STORE s0, s_sustain_upr
                              STORE s0, s_sustain_lwr
                              STORE s0, s_sosten_upr
                              STORE s0, s_sosten_lwr
                              OUTPUT s0, RAM_WRDATA                       ; Enables und Werte auf 0
                              OUTPUT s0, PEDAL_DOWN
                              LOAD scan_number, 00
                              LOAD page_select, 00
          allnotesoff_loop_0: 
                              OUTPUT scan_number, RAM_ADDR
                              OUTPUT page_select, RAM_PAGE
                              ADD scan_number, 01
                              OUTPUT s0, UPPER_STROBE
                              OUTPUT s0, LOWER_STROBE
                              OUTPUT s0, PEDAL_STROBE
                              COMPARE scan_number, 64'd                   ; 64 Durchläufe?
                              JUMP NZ, allnotesoff_loop_0
                              LOAD scan_number, 00
                              ADD page_select, 01
                              COMPARE page_select, 16'd                   ; 16 Durchläufe?
                              JUMP NZ, allnotesoff_loop_0
                              ;
             reset_dyntimers: 
                              LOAD scan_number, 00
                              LOAD page_select, c_page_dyntimer
           reset_dyntimers_1: 
                              LOAD s0, FF                                 ; alle Dyntimer auf 255 setzen
                              OUTPUT s0, RAM_WRDATA                       ; Enables und Werte auf 0
                              OUTPUT scan_number, RAM_ADDR
                              OUTPUT page_select, RAM_PAGE
                              ADD scan_number, 01
                              OUTPUT s0, UPPER_STROBE
                              OUTPUT s0, LOWER_STROBE
                              COMPARE scan_number, 64'd                   ; 64 Durchläufe?
                              JUMP NZ, reset_dyntimers_1
                              RETURN                                      ; fertig
                              ;
                              ;
                              ; ##############################################################################
                              ; ################## M I D I   R E C E I V E   DISPATCHER ######################
                              ; ##############################################################################
                              ;
                              ;
                              ; MIDI-Subroutinen für MIDI-Empfang
                              ; Dispatcher stellt fest, ob und was es zu tun gibt
                              ; wird regelmäßig aus Hauptschleife aufgerufen
                              ;
               midi_dispatch: 
        midi_dispatch_loop_1: 
                              INPUT s0, MIDI_IN1_STATUS
                              COMPARE s0, 00                              ; Daten empfangen?
                              JUMP Z, midi_dispatch_loop_2                ; wenn nein, weiter mit MIDI In 2 (SAM/USB)
                              CALL midi_1_receive                         ; Buffer lesen/leeren, Realtime filtern, Flags setzen
                              COMPARE midi_1_rxflag, 00
                              CALL NZ, midi_dispatch_1                    ; interpretieren, falls komplett
                              JUMP midi_dispatch_loop_1
                              ;
        midi_dispatch_loop_2: 
                              INPUT s0, MIDI_IN2_STATUS
                              COMPARE s0, 00                              ; Daten empfangen?
                              JUMP Z, midi_dispatch_loop_3                ; wenn nein, weiter mit MIDI In 3 (AVR)
                              CALL midi_2_receive                         ; Buffer leeren
                              COMPARE midi_2_rxflag, 00
                              CALL NZ, midi_dispatch_2                    ; interpretieren, falls komplett
                              JUMP midi_dispatch_loop_2
                              ;
        midi_dispatch_loop_3: 
                              INPUT s0, MIDI_AVR_STATUS
                              AND s0, 0E                                  ; Daten empfangen?
                              RETURN Z                                    ; wenn nein, zurück zur Main Loop
                              CALL midi_3_receive                         ; Buffer lesen/leeren, Flags setzen
                              COMPARE midi_3_rxflag, 00
                              CALL NZ, midi_dispatch_3                    ; interpretieren, falls komplett
                              JUMP midi_dispatch_loop_3
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ; Daten auswerten, hier kein SysEx mehr
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
             midi_dispatch_1: 
                              ; Daten vom erstem MIDI-Eingang interpretieren, falls vollständig
                              LOAD midi_1_rxflag, 00                      ; Rx-Flag löschen
                              FETCH s0, s_midi_1_cmd                      ; von IRQ gesetzte Bytes
                              STORE s0, s_midi_cmd
                              FETCH s0, s_midi_1_data1
                              STORE s0, s_midi_data1
                              FETCH s0, s_midi_1_data2
                              STORE s0, s_midi_data2
                              FETCH s0, s_midi_1_len
                              STORE s0, s_midi_len
                              JUMP midi_dispatch_all                      ; Ende und RETURN
                              ;
             midi_dispatch_2: 
                              ; Daten vom zweiten MIDI-Eingang interpretieren, falls vollständig
                              LOAD midi_2_rxflag, 00                      ; Rx-Flag löschen
                              FETCH s0, s_midi_2_cmd                      ; von IRQ gesetzte Bytes
                              STORE s0, s_midi_cmd
                              FETCH s0, s_midi_2_data1
                              STORE s0, s_midi_data1
                              FETCH s0, s_midi_2_data2
                              STORE s0, s_midi_data2
                              FETCH s0, s_midi_2_len
                              STORE s0, s_midi_len
                              JUMP midi_dispatch_all                      ; Ende und RETURN
                              ;
             midi_dispatch_3: 
                              ; bei AVR  Controller Change nur auf ALL NOTES OFF prüfen, sonst senden
                              LOAD midi_3_rxflag, 00                      ; Rx-Flag löschen
                              FETCH s0, s_midi_3_cmd
                              AND s0, F0
                              COMPARE s0, B0                              ; Control Change?
                              JUMP NZ, midi_dispatch_3_send
                              FETCH s0, s_midi_3_cmd
                              AND s0, 0F                                  ; Kanal isolieren
                              STORE s0, s_midi_chan_masked                ; für allnotesoff_manual
                              FETCH s0, s_midi_3_data1
                              COMPARE s0, 123'd                           ; All Notes OFF?
                              JUMP Z, allnotesoff_manual
        midi_dispatch_3_send: 
                              ; empfangenen Datensatz 1 bis 3 Bytes vom AVR an SAM und DIN-Buchse senden
                              FETCH s0, s_midi_3_cmd
                              CALL midi_tx_both
                              FETCH s0, s_midi_3_len
                              COMPARE s0, 00
                              RETURN Z
                              ;
                              FETCH s0, s_midi_3_data1
                              CALL midi_tx_both
                              FETCH s0, s_midi_3_len
                              COMPARE s0, 01
                              RETURN Z
                              ;
                              FETCH s0, s_midi_3_data2
                              JUMP midi_tx_both
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
           midi_dispatch_all: 
                              ; MIDI-Datensatz vollständig, dekodieren und ggf. RAM beschreiben
                              CALL midi_out2_waitbuf                      ; SAM5504-Buffer aufnahmebereit?
                              FETCH s1, s_midi_len
                              FETCH s0, s_midi_cmd
                              OUTPUT s0, MIDI_TX_2                        ; immer alles an SAM5504 senden
                              COMPARE s1, 00
                              JUMP Z, midi_dispatch_all_0
                              FETCH s0, s_midi_data1
                              OUTPUT s0, MIDI_TX_2
                              COMPARE s1, 01
                              JUMP Z, midi_dispatch_all_0
                              FETCH s0, s_midi_data2
                              OUTPUT s0, MIDI_TX_2
         midi_dispatch_all_0: 
                              FETCH s0, s_midi_cmd
                              AND s0, 0F                                  ; Kanal isolieren
                              STORE s0, s_midi_chan_masked
                              FETCH s0, s_midi_cmd
                              AND s0, F0                                  ; Befehl isolieren
                              STORE s0, s_midi_cmd_masked
                              ;
                              LOAD manual_select, 00                      ; Default upper
                              FETCH s1, s_midi_chan_masked
                              FETCH s0, s_midich                          ; eingestellter Kanal, Piano-Maske
                              COMPARE s1, s0                              ; eingestellter gleich empfangener Kanal?
                              JUMP Z, midi_dispatch_all_onoff             ; mit manual_select = 0, upper
                              ;
                              ADD s0, 01
                              LOAD manual_select, 01
                              COMPARE s1, s0                              ; eingestellter Kanal +1?
                              JUMP Z, midi_dispatch_all_onoff
                              ;
                              ADD s0, 01
                              LOAD manual_select, 02                      ; mit manual_select = 2, Pedal
                              COMPARE s1, s0                              ; eingestellter Kanal +2?
                              JUMP Z, midi_dispatch_pedal
                              ;
                              ; Sonderkanal +3 für Touchpad-CC, nur an AVR
                              ADD s0, 01
                              COMPARE s1, s0                              ; eingestellter Kanal +3?
                              JUMP Z, midi_to_avr
                              RETURN 
                              ;
                              ; Pedal-Sonderbehandlung, weil nur ein Bit statt ein Byte abgespeichert wird
                              ;
         midi_dispatch_pedal: 
                              FETCH s0, s_midi_cmd_masked
                              COMPARE s0, 80
                              JUMP Z, midi_dispatch_all_off               ; 0 speichern
                              COMPARE s0, 90
                              JUMP NZ, midi_dispatch_rest                 ; wenn kein ON/OFF
                              ;
                              FETCH s0, s_midi_data2
                              COMPARE s0, 00
                              JUMP Z, midi_dispatch_all_off               ; war $90 mit Dynamik 0
                              ;
                              LOAD s0, 01
                              STORE s0, s_midi_data2
                              JUMP midi_dispatch_all_write
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
     midi_dispatch_all_onoff: 
                              ; MIDI-NoteOn/NoteOff-Befehle? Dynamik bereits in s2, Manual in manual_select
                              FETCH s0, s_midi_cmd_masked
                              COMPARE s0, 90
                              JUMP Z, midi_dispatch_all_write
                              COMPARE s0, 80
                              JUMP NZ, midi_dispatch_rest                 ; wenn kein ON/OFF
                              ; ist ein ON/OFF-Befehl
       midi_dispatch_all_off: 
                              LOAD s0, 00                                 ; MIDI-Befehl Taste OFF, Dynamik 0
                              STORE s0, s_midi_data2                      ; Dynamik dieser Taste 0
     midi_dispatch_all_write: 
                              ; jetzt Notenwert und Dynamik abspeichern
                              ; Dynamik ist 0 bei Key-Off-Befehl
                              CALL midi_adjust_foldbacks                  ; Sollte abschaltbar sein!
                              JUMP ramwrite_midi_121
                              ;
                              ; MIDI-Tasten außerhalb des 5-Oktaven-Umfangs oktavweise verschieben
                              ;
       midi_adjust_foldbacks: 
                              FETCH s0, s_midi_data1
     midi_adjust_foldbacks_1: 
                              COMPARE s0, c_gen_firstkey                  ; Carry bei scan_number - 36?
                              JUMP NC, midi_adjust_foldbacks_2            ; Carry nicht gesetzt >=36
                              ADD s0, 12'd
                              JUMP midi_adjust_foldbacks_1
                              ;
     midi_adjust_foldbacks_2: 
                              STORE s0, s_midi_data1
                              COMPARE s0, c_gen_lastkey_plus_one          ; Carry bei scan_number - 97?
                              RETURN C
                              SUB s0, 12'd
                              JUMP midi_adjust_foldbacks_2
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
          midi_dispatch_rest: 
                              ; Program Change und Controller? Dann an AVR
                              COMPARE s0, C0
                              JUMP Z, midi_to_avr
                              COMPARE s0, E0
                              JUMP Z, midi_to_avr
                              COMPARE s0, B0
                              RETURN NZ                                   ; alles andere unberücksichtigt
                midi_cchange: 
                              ; bei Controller Change auf ALL NOTES OFF prüfen, dann weiter wie Program Change
                              FETCH s0, s_midi_data1
                              COMPARE s0, 123'd                           ; All Notes OFF?
                              JUMP Z, allnotesoff_manual                  ; falls nicht, weiter mit AVR-IRQ
                              ;
                 midi_to_avr: 
                              ; AVR-IRQ auslösen; MIDI-Daten an SPI
                              FETCH s0, s_midi_cmd
                              OUTPUT s0, MIDI_CMD
                              FETCH s1, s_midi_data1                      ; s1 wird gleich weiterbenutzt
                              OUTPUT s1, MIDI_DB1
                              FETCH s0, s_midi_data2
                              OUTPUT s0, MIDI_DB2
                              CALL midi_strobe_avr                        ; an AVR senden, benutzt s0
                              ;
                              FETCH s0, s_midi_cmd_masked
                              COMPARE s0, B0                              ; Control Change empfangen?
                              RETURN NZ
                              ; ab hier nur noch Control Change Bx, auf allen benutzten Kanälen
                              ;
                              INPUT s0, SPI_MIDIOPT                       ; Bit 7 (MSB): USE SOST/SUSTAIN freigeschaltet?
                              AND s0, 80
                              RETURN Z                                    ; wenn 0, dann nicht behandeln, abgeschaltet
                              ;
                midi_sustain: 
                              ; manual_select enthält empfangenes Ziel (0, 1 oder 2)
                              COMPARE s1, 40
                              JUMP NZ, midi_sustain_sostenuto
                              ;
                              LOAD idx_ptr, s_sustain_upr
                              JUMP midi_sustain_1                         ; evt. von SAM5504-HW-Input, muss auch gesendet werden
                              ;
      midi_sustain_sostenuto: 
                              COMPARE s1, 42
                              RETURN NZ
                              LOAD idx_ptr, s_sosten_upr
              midi_sustain_1: 
                              ADD idx_ptr, manual_select
                              FETCH s2, s_midi_data2
                              STORE s2, (idx_ptr)
                              ; OUTPUT s0, AUXPORT                    ; ### TEST - nur in MIDI-Scantreiber benutzen! ###
                              ;
                              ; Sustain und Sostenuto weitersenden, könnte vom DSP (Eingangs-Pins über Jumper) stammen
                              CALL midi_out_waitbuf                       ; benutzt s1!
                              FETCH s0, s_midi_cmd
                              OUTPUT s0, MIDI_TX_1                        ; TX Midi auf DIN-Buchse
                              FETCH s0, s_midi_data1
                              OUTPUT s0, MIDI_TX_1                        ; TX Midi auf DIN-Buchse
                              FETCH s0, s_midi_data2
                              OUTPUT s0, MIDI_TX_1                        ; TX Midi auf DIN-Buchse
                              RETURN 
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
          allnotesoff_manual: 
                              LOAD s0, 00                                 ; Dynamik dieser Taste
                              ; alle Tasten löschen
                              FETCH idx_ptr, s_midi_chan_masked
                              FETCH s1, s_midich                          ; eingestellter Kanal
                              SUB idx_ptr, s1                             ; Manual in idx_ptr
                              ADD idx_ptr, c_strobe_mask                  ; 0 bis 2 plus Offset
                              OUTPUT s0, RAM_WRDATA                       ; zu schreibende Dynamik INPUT s0
                              LOAD s0, c_page_midirx1
                              OUTPUT s0, RAM_PAGE                         ; MPX-RAM Page
                              LOAD s1, 00                                 ; Schleifenzähler
                              ; keine set_ram-Routine, da page_select, scan_number etc. nicht gültig!
    allnotesoff_manual_loop1: 
                              OUTPUT s1, RAM_ADDR                         ; Tastennummer INPUT s1
                              LOAD s0, c_page_midirx1
                              OUTPUT s0, RAM_PAGE                         ; MPX-RAM Page
                              OUTPUT s0, (idx_ptr)                        ; Upper, Lower oder Pedal Strobe
                              LOAD s0, c_page_midirx2
                              OUTPUT s0, RAM_PAGE                         ; MPX-RAM Page
                              OUTPUT s0, (idx_ptr)                        ; Upper, Lower oder Pedal Strobe
                              LOAD s0, c_page_keystatus1
                              OUTPUT s0, RAM_PAGE                         ; MPX-RAM Page
                              OUTPUT s0, (idx_ptr)                        ; Upper, Lower oder Pedal Strobe
                              LOAD s0, c_page_keystatus2
                              OUTPUT s0, RAM_PAGE                         ; MPX-RAM Page
                              OUTPUT s0, (idx_ptr)                        ; Upper, Lower oder Pedal Strobe
                              ADD s1, 01
                              COMPARE s1, 64'd
                              JUMP NZ, allnotesoff_manual_loop1
                              RETURN 
                              ;
            midi_out_waitbuf: ; MIDI MAIN OUT
                              INPUT s1, TX_STATUS                         ; half full?
                              COMPARE s1, 00                              ; nur 0, wenn beide TX1 und TX2 weniger als halbvoll
                              JUMP NZ, midi_out_waitbuf                   ; auf Buffer-Leerung warten
                              RETURN 
                              ;
           midi_out2_waitbuf: ; SAM5504-Buffer aufnahmebereit? zweiter interner MIDI-Ausgang
                              INPUT s1, TX_STATUS                         ; half full?
                              AND s1, 02
                              COMPARE s1, 02
                              JUMP Z, midi_out2_waitbuf                   ; auf Buffer-Leerung warten
                              RETURN 
                              ;
                              ; ##############################################################################
                              ; ###################### M I D I   I N P U T  1 (DIN1) #########################
                              ; ##############################################################################
                              ;
                              ; MIDI Daten wurden von Input 1 empfangen
                              ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                              ;
              midi_1_receive: 
                              INPUT s0, MIDI_IN1
                              COMPARE s0, F0                              ; RealTime ab $F0?
                              JUMP C, midi_1_channel_message              ; wenn kleiner als F0, mit Channel Messages weiter
                              COMPARE s0, F8                              ; RealTime ab $F8?
                              RETURN NC                                   ; Realtime ab #F8 ohne Daten, verwerfen
                              COMPARE s0, F0                              ; Start of SysEX, Flag setzen
                              JUMP Z, midi_1_start_sysex_to_avr
                              COMPARE s0, F7                              ; End of SysEX, Flag löschen
                              JUMP Z, midi_1_stop_sysex_to_avr
                              ; ab hier nur noch Werte zwischen F1 und F6 übrig:
                              ; F1 Timecode Quarter Frame, F2 Song Position Pointer, F3 Select Song
                              LOAD s1, FF
                              STORE s1, s_midi_1_ignoreflag               ; Flag setzen: folgende Daten ignorieren
                              RETURN 
                              ;
      midi_1_channel_message: 
                              TEST s0, 80
                              JUMP Z, midi_1_is_databyte
                              ; ist ab hier eine Channel Message
                              STORE s0, s_midi_1_cmd
                              LOAD s1, 00                                 ; ist ein neuer (Running) Status
                              STORE s1, s_midi_1_counter
                              STORE s1, s_midi_1_ignoreflag               ; Flag löschen: bald folgende Daten wieder relevant
                              COMPARE midi_1_SysExFlag, 00
                              JUMP NZ, midi_1_stop_sysex_to_avr           ; Sysex durch Channel-Command beendet
                              RETURN 
                              ;
          midi_1_is_databyte: 
                              COMPARE midi_1_SysExFlag, 00                ; Läuft SysEx-Übertragung?
                              JUMP NZ, midi_1_sysex_to_avr_s0             ; dann Daten zum AVR senden
                              ;
                              FETCH s1, s_midi_1_ignoreflag               ; Daten von Sytem Common F1, F2, F3?
                              COMPARE s1, 00
                              RETURN NZ                                   ; Datenbytes ignorieren wenn ja
                              ;
                              FETCH s1, s_midi_1_counter
                              ADD s1, 01
                              STORE s1, s_midi_1_counter
                              COMPARE s1, 02
                              JUMP Z, midi_1_is_second_databyte
                              ;
                              ; erstes Datenbyte empfangen:
                              ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                              ; Datensatz ist mit einem Datenbyte vollständig!
                              FETCH s1, s_midi_1_cmd
                              AND s1, F0                                  ; Kanal ausmaskieren
                              COMPARE s1, C0                              ; program change
                              JUMP Z, midi_1_is_singledatabyte
                              COMPARE s1, D0                              ; channel pressure
                              JUMP Z, midi_1_is_singledatabyte
    midi_1_is_first_databyte: 
                              STORE s0, s_midi_1_data1
                              RETURN 
                              ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
    midi_1_is_singledatabyte: 
                              STORE s0, s_midi_1_data1
   midi_1_is_second_databyte: 
                              STORE s0, s_midi_1_data2
                              FETCH s1, s_midi_1_counter
                              STORE s1, s_midi_1_len                      ; letzte Anzahl empfangener Datenbytes
                              LOAD s1, 00                                 ; Datensatz vollständig
                              STORE s1, s_midi_1_counter                  ; neue Anzahl empfangener Datenbytes
                              LOAD midi_1_rxflag, FF                      ; jetzt vollständig, Flag setzen
                              RETURN 
                              ;
   midi_1_start_sysex_to_avr: 
                              ; SysEx-Start $F0 wurde empfangen, ist in s0
                              LOAD midi_1_SysExFlag, 01
                              JUMP midi_1_sysex_to_avr_s0
                              ;
    midi_1_stop_sysex_to_avr: 
                              LOAD midi_1_SysExFlag, 00
                              LOAD s0, F7
      midi_1_sysex_to_avr_s0: 
                              ; 3 Bytes werden parallel übertragen, deshalb Umsetzung auf Controller für AVR-SPI
                              LOAD s1, B0
                              OUTPUT s1, MIDI_CMD
                              LOAD s1, 78                                 ; eigener Controller $7B = 123, eigentlich AllNotesOff
                              OUTPUT s1, MIDI_DB1
                              OUTPUT s0, MIDI_DB2                         ; SysEx-Daten einschl. F0 und F7, hier 8 Bit zulässig!
                              JUMP midi_strobe_avr                        ; und RETURN
                              ;
                              ; ##############################################################################
                              ; ################# M I D I   I N P U T  2 (DIN2/SAM/USB) ######################
                              ; ##############################################################################
                              ;
                              ; MIDI Daten wurden von Input 2 empfangen
                              ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                              ;
              midi_2_receive: 
                              INPUT s0, MIDI_IN2
                              COMPARE s0, F0                              ; RealTime ab $F0?
                              JUMP C, midi_2_channel_message              ; wenn kleiner als F0, mit Channel Messages weiter
                              COMPARE s0, F8                              ; RealTime ab $F8?
                              RETURN NC                                   ; Realtime ab #F8 ohne Daten, verwerfen
                              COMPARE s0, F0                              ; Start of SysEX, Flag setzen
                              JUMP Z, midi_2_start_sysex_to_avr
                              COMPARE s0, F7                              ; End of SysEX, Flag löschen
                              JUMP Z, midi_2_stop_sysex_to_avr
                              ; ab hier nur noch Werte zwischen F1 und F6 übrig:
                              ; F1 Timecode Quarter Frame, F2 Song Position Pointer, F3 Select Song
                              LOAD s1, FF
                              STORE s1, s_midi_2_ignoreflag               ; Flag setzen: folgende Daten ignorieren
                              RETURN 
                              ;
      midi_2_channel_message: 
                              TEST s0, 80
                              JUMP Z, midi_2_is_databyte
                              ; ist ab hier eine Channel Message
                              STORE s0, s_midi_2_cmd
                              LOAD s1, 00                                 ; ist ein neuer (Running) Status
                              STORE s1, s_midi_2_counter
                              STORE s1, s_midi_2_ignoreflag               ; Flag löschen: bald folgende Daten wieder relevant
                              COMPARE midi_2_SysExFlag, 00
                              JUMP NZ, midi_2_stop_sysex_to_avr           ; Sysex durch Channel-Command beendet
                              RETURN 
                              ;
          midi_2_is_databyte: 
                              COMPARE midi_2_SysExFlag, 00                ; Läuft SysEx-Übertragung?
                              JUMP NZ, midi_2_sysex_to_avr_s0             ; dann Daten zum AVR senden
                              ;
                              FETCH s1, s_midi_2_ignoreflag               ; Daten von Sytem Common F1, F2, F3?
                              COMPARE s1, 00
                              RETURN NZ                                   ; Datenbytes ignorieren wenn ja
                              ;
                              FETCH s1, s_midi_2_counter
                              ADD s1, 01
                              STORE s1, s_midi_2_counter
                              COMPARE s1, 02
                              JUMP Z, midi_2_is_second_databyte
                              ;
                              ; erstes Datenbyte empfangen:
                              ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                              ; Datensatz ist mit einem Datenbyte vollständig!
                              FETCH s1, s_midi_2_cmd
                              AND s1, F0                                  ; Kanal ausmaskieren
                              COMPARE s1, C0                              ; program change
                              JUMP Z, midi_2_is_singledatabyte
                              COMPARE s1, D0                              ; channel pressure
                              JUMP Z, midi_2_is_singledatabyte
    midi_2_is_first_databyte: 
                              STORE s0, s_midi_2_data1
                              RETURN 
                              ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
    midi_2_is_singledatabyte: 
                              STORE s0, s_midi_2_data1
   midi_2_is_second_databyte: 
                              STORE s0, s_midi_2_data2
                              FETCH s1, s_midi_2_counter
                              STORE s1, s_midi_2_len                      ; letzte Anzahl empfangener Datenbytes
                              LOAD s1, 00                                 ; Datensatz vollständig
                              STORE s1, s_midi_2_counter                  ; neue Anzahl empfangener Datenbytes
                              LOAD midi_2_rxflag, FF                      ; jetzt vollständig, Flag setzen
                              RETURN 
                              ;
   midi_2_start_sysex_to_avr: 
                              LOAD midi_2_SysExFlag, FF
                              JUMP midi_2_sysex_to_avr_s0
                              ;
                              ; SysEx-Datenübertragung immer komplett abwarten
    midi_2_stop_sysex_to_avr: 
                              LOAD midi_2_SysExFlag, 00
                              LOAD s0, F7
      midi_2_sysex_to_avr_s0: 
                              ; SysEx-Start $F0 wurde empfangen, ist in s0
                              ; 3 Bytes werden parallel übertragen, deshalb Umsetzung auf Controller für AVR-SPI
                              LOAD s1, B0
                              OUTPUT s1, MIDI_CMD
                              LOAD s1, 78                                 ; eigener Controller $7B = 123, eigentlich AllNotesOff
                              OUTPUT s1, MIDI_DB1
                              OUTPUT s0, MIDI_DB2                         ; SysEx-Daten einschl. F0 und F7, hier 8 Bit zulässig!
                              JUMP midi_strobe_avr                        ; und RETURN
                              ;
                              ; ##############################################################################
                              ; ###################### M I D I   I N P U T  3 (AVR) ##########################
                              ; ##############################################################################
                              ;
                              ; SPI-MIDI Daten wurden von AVR empfangen
                              ; vereinfachte SysEx-Behandlung
              midi_3_receive: 
                              ;
                              ; LOAD s1, FA ; ##### TEST #####
                              ; OUTPUT s1, AUXPORT ; Trigger für LA
                              ; OUTPUT s0, AUXPORT ; ##### TEST #####
                              INPUT s0, MIDI_AVR
                              COMPARE s0, F0                              ; SysEx-Start?
                              JUMP Z, midi_3_startSysEx
                              COMPARE s0, F7                              ; SysEx-Ende?
                              JUMP Z, midi_3_stopSysEx
                              FETCH s1, s_midi_3_SysExFlag
                              COMPARE s1, 00
                              JUMP NZ, midi_tx_both                       ; s0 Senden, Übertragung läuft noch
                              ;
                              TEST s0, 80
                              JUMP Z, midi_3_is_databyte
                              LOAD s1, 00                                 ; ist ein neuer (Running) Status
                              STORE s1, s_midi_3_counter
                              STORE s1, s_midi_3_SysExFlag
                              STORE s0, s_midi_3_cmd
                              RETURN 
          midi_3_is_databyte: 
                              FETCH s1, s_midi_3_counter
                              ADD s1, 01
                              STORE s1, s_midi_3_counter
                              COMPARE s1, 02
                              JUMP Z, midi_3_is_second_databyte
                              ; erstes Datenbyte empfangen:
                              ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                              ; Datensatz ist mit einem Datenbyte vollständig!
                              FETCH s1, s_midi_3_cmd
                              AND s1, F0                                  ; Kanal ausmaskieren
                              COMPARE s1, C0                              ; program change
                              JUMP Z, midi_3_is_singledatabyte
                              COMPARE s1, D0                              ; channel pressure
                              JUMP Z, midi_3_is_singledatabyte
    midi_3_is_first_databyte: 
                              STORE s0, s_midi_3_data1
                              RETURN 
                              ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
    midi_3_is_singledatabyte: 
                              STORE s0, s_midi_3_data1
   midi_3_is_second_databyte: 
                              STORE s0, s_midi_3_data2
                              FETCH s1, s_midi_3_counter
                              STORE s1, s_midi_3_len                      ; Anzahl empfangener Datenbytes
                              LOAD s1, 00                                 ; Datensatz vollständig
                              STORE s1, s_midi_3_counter                  ; letzte Anzahl empfangener Datenbytes
                              LOAD midi_3_rxflag, FF                      ; jetzt vollständig, Flag setzen
                              RETURN 
                              ; SysEx-Daten vom AVR unbehandelt senden, aber Flag setzen
           midi_3_startSysEx: 
                              CALL midi_tx_both                           ; verwendet s1
                              LOAD s1, FF
                              STORE s1, s_midi_3_SysExFlag
                              RETURN 
            midi_3_stopSysEx: 
                              CALL midi_tx_both                           ; verwendet s1
                              LOAD s1, 00
                              STORE s1, s_midi_3_SysExFlag
                              RETURN 
                              ;
             midi_strobe_avr: 
                              LOAD s0, 01                                 ; pos. Flanke an MIDI-FIFO
                              OUTPUT s0, MIDI_STR
                              LOAD s0, 00
                              OUTPUT s0, MIDI_STR
                              RETURN 
                              ;
                              ; ##############################################################################
                              ; ##############################################################################
                              ; ###                           Initialisierungen                            ###
                              ; ##############################################################################
                              ; ##############################################################################
                              ;
                   scan_init: 
                              LOAD s0, 00
                              OUTPUT s0, SCANPORT
                              OUTPUT s0, STATUS
                              OUTPUT s0, MIDI_OUT_SEL
                              LOAD midi_1_rxflag, 00
                              LOAD midi_2_rxflag, 00
                              LOAD midi_1_SysExFlag, 00
                              LOAD midi_2_SysExFlag, 00
                              LOAD midi_3_rxflag, 00
                              LOAD page_select, 00
                              LOAD manual_select, 00
                              LOAD s8_msb_smode, 00
                              LOAD s7_lsb_spoint, 00
                              LOAD event_key, 00
                              LOAD scan_number, 00
                              LOAD s3_key_status, 00
                              LOAD idx_ptr, 00
                              LOAD s0, 00
           zero_scratch_loop: 
                              STORE s0, (idx_ptr)
                              ADD idx_ptr, 01
                              COMPARE idx_ptr, 40
                              JUMP NZ, zero_scratch_loop
                              ;
                              LOAD s0, 40
                              STORE s0, s_last_key_velocity
                              LOAD idx_ptr, 00
                              CALL scan_wait_init
                              CALL allnotesoff
                              LOAD s0, 00
                              OUTPUT s0, RAM_PAGE
                              CALL split_exit
                              ; INIT Message mit ScanCore Info
                              LOAD s0, c_corevers
                              OUTPUT s0, MIDI_DB2
                              LOAD s0, c_corerevi
                              OUTPUT s0, MIDI_DB1
                              LOAD s0, AA
                              OUTPUT s0, MIDI_CMD
                              CALL midi_strobe_avr
                              RETURN 
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                midi_testout: 
                              ; für Debug-Zwecke, sendet MIDI-Programchange mit Wert in s0
                              LOAD s1, C0
                              OUTPUT s1, MIDI_TX_1                        ; TX Midi auf DIN-Buchse
                              OUTPUT s1, MIDI_TX_2                        ; TX Midi an SAM
                              OUTPUT s0, MIDI_TX_1                        ; TX Midi auf DIN-Buchse
                              OUTPUT s0, MIDI_TX_2                        ; TX Midi an SAM
                              RETURN 
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
                 scan_config: 
                              LOAD s0, 00
                              FETCH s1, s_keycount_upper                  ; Anzahl gedrückter Tasten Upper
                              COMPARE s1, 00
                              CALL NZ, load_s0_with_FF
                              OUTPUT s0, KEYS_ON_UPR
                              ;
                              LOAD s0, 00
                              FETCH s1, s_keycount_lower                  ; Anzahl gedrückter Tasten Lower
                              COMPARE s1, 00
                              CALL NZ, load_s0_with_FF
                              OUTPUT s0, KEYS_ON_LWR
                              ;
                              INPUT s0, SPI_CONFIG_1
                              SR0 s0
                              SR0 s0
                              STORE s0, s_velocityfac                     ; waren Bits 7..2
                              INPUT s0, SPI_KEYTRANSPOSE
                              FETCH s1, s_keytranspose
                              COMPARE s0, s1
                              STORE s0, s_keytranspose
                              CALL NZ, split_sendallnotesoff              ; Key-Transpose geändert
                              INPUT s0, SPI_GENTRANSPOSE
                              FETCH s1, s_gentranspose
                              COMPARE s0, s1
                              STORE s0, s_gentranspose
                              CALL NZ, split_sendallnotesoff              ; Generator-Transpose geändert
                              INPUT s1, SPI_CLICKLEN
                              AND s1, 0F                                  ; max. 15 ms
                              LOAD s0, FF
                              SUB s0, s1
                              STORE s0, s_clicklen                        ; Startwert 1ms-Timer, max. 255
                              INPUT s0, SPI_CLICKLEN
                              AND s0, F0
                              SR0 s0
                              SR0 s0                                      ; Wert immer noch vervierfacht
                              ; z.B. $13(5A) = Teilfaktor 4954 für 10 kHz Samples oder 5 kHz Noise-Frequenz
                              OUTPUT s0, NOISE_FREQ
                              ; MIDI-Kanal geändert?
                              FETCH s1, s_midich
                              INPUT s0, SPI_MIDICH
                              COMPARE s0, s1
                              STORE s0, s_midich
                              CALL NZ, allnotesoff                        ; wenn MIDI-Kanal geändert
                              ; OUTPUT s0, AUXPORT ; Trigger für LA
                              INPUT s0, SPI_MIDIOPT
                              OUTPUT s0, MIDI_OUT_SEL
                              ;
                              ; Split überprüfen. In SPI_XXX befindet sich ggf. neue Split-ON/OFF-Einstellung vom Panel
                              FETCH s0, s_splitpoint
                              INPUT s1, SPI_SPLITPOINT
                              STORE s1, s_splitpoint
                              COMPARE s0, s1
                              CALL NZ, split_changed                      ; wenn geändert
                              ;
                              FETCH s0, s_splitmode
                              INPUT s1, SPI_SPLITMODE
                              STORE s1, s_splitmode
                              COMPARE s0, s1
                              CALL NZ, split_changed                      ; wenn geändert
                              ;
                              FETCH s0, s_split_on                        ; alter Split-On-Zustand
                              INPUT s1, SPI_SPLITON                       ; neu von Bedienelement
                              STORE s1, s_split_on
                              COMPARE s0, s1
                              RETURN Z                                    ; nicht geändert
                              TEST s1, 02                                 ; Split-Request-Bit gesetzt?
                              JUMP NZ, set_splitpoint                     ; anhand eigener Tastendrücke setzen
                              ; sonst nur weiter mit split_changed
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
               split_changed: 
                              CALL allnotesoff                            ; wenn geändert
              split_mode_new: 
                              FETCH s0, s_split_on
                              AND s0, 03
                              ; COMPARE s0, 00
                              JUMP Z, split_exit
                              RETURN 
                              ;
                              ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                              ;
              scan_wait_init: 
                              LOAD s0, c_scankey_delay                    ; Scan-Timer neu laden
                              OUTPUT s0, SCANTIMER_VAL
                              RETURN 
                              ; Active Sensing senden falls Timer abgelaufen
              active_sensing: 
                              FETCH s0, s_midi_activesensing              ; nach 256 ms Active Sensing senden
                              ADD s0, 01
                              STORE s0, s_midi_activesensing
                              COMPARE s0, 00
                              RETURN NZ
                              ; TEST: Active Sensing abgeschaltet
                              ; RETURN
                              CALL midi_out_waitbuf
                              LOAD s0, FE
                              OUTPUT s0, MIDI_TX_1
                              OUTPUT s0, MIDI_TX_2
                              RETURN 
                              ;
                              ; ##############################################################################
                              ; Splitmode setzen:
                              ; 0 = PedalToLower,
                              ; 1 = LowerToUpper
                              ; 2 = PedalToUpper
                              ; 3 = LowerToUpper + 1 Oktave
                              ; 4 = LowerToUpper + 2 Oktaven
                              ; 5 = Add Pedal to Lower
                              ; ##############################################################################
                              ;
              set_splitpoint: 
                              FETCH s0, s_split_on
                              AND s0, 03
                              ; COMPARE s0, 00                            ; nun ausgeschaltet?
                              JUMP Z, split_exit                          ; dann All Notes Off und Ende
                              ; Split-Funktion wurde seit letztem Durchlauf von OFF auf ON geändert.
                              ; Feststellen, ob Keyboard-Tasten gedrückt wurden, dann diese setzen und als
                              ; Splitpoint an AVR senden.
                              FETCH s0, s_keycount_upper
                              FETCH s1, s_keycount_lower
                              ADD s0, s1
                              COMPARE s0, 00
                              JUMP Z, split_exit                          ; keine Tasten gedrückt, alter Splitmode
                              FETCH s7_lsb_spoint, s_lastkey_on
                              STORE s7_lsb_spoint, s_splitpoint
                              ;
                              COMPARE s1, 00
                              JUMP Z, set_splitpoint_upper                ; keine Tasten auf Lower, also Upper
                              SUB s1, 01
                              COMPARE s1, 00
                              JUMP Z, set_splitpoint_store                ; wenn nur eine Taste gedrückt, SplitMode 0 speichern
                              LOAD s1, 05                                 ; sonst 5 = Add Pedal to Lower
                              JUMP set_splitpoint_store
                              ;
        set_splitpoint_upper: 
                              ; Anzahl der Tasten Obermanual ist zufällig auch Splitmode 0..4
                              FETCH s1, s_keycount_upper
        set_splitpoint_store: 
                              STORE s1, s_splitmode
                              ; gewünschten Splitmode an AVR senden, über internal MIDI an Controller $70 und $71
                              LOAD s0, B0
                              OUTPUT s0, MIDI_CMD
                              LOAD s0, 76
                              OUTPUT s0, MIDI_DB1
                              OUTPUT s1, MIDI_DB2
                              CALL midi_strobe_avr
                              ; MIDI_CMD bleibt!
                              LOAD s0, 77
                              OUTPUT s0, MIDI_DB1
                              OUTPUT s7_lsb_spoint, MIDI_DB2
                              CALL midi_strobe_avr
                              ;
                  split_exit: 
       split_sendallnotesoff: 
                              CALL allnotesoff
                              FETCH s0, s_midich
                              ADD s0, B0
                              CALL midi_tx_both
                              CALL split_sendoff_data
                              FETCH s0, s_midich
                              ADD s0, B1
                              CALL midi_tx_both
                              CALL split_sendoff_data
                              FETCH s0, s_midich
                              ADD s0, B2
                              CALL midi_tx_both
          split_sendoff_data: 
                              LOAD s0, 7B                                 ; Controller 123
                              OUTPUT s0, MIDI_TX_1
                              OUTPUT s0, MIDI_TX_2
                              LOAD s0, 7F                                 ; 127
                              OUTPUT s0, MIDI_TX_1
                              OUTPUT s0, MIDI_TX_2
                              RETURN 
